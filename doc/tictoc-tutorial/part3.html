<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Tictoc Tutorial: 3. Turning it into a real network</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="part3">3. Turning it into a real network</a></h1>PREV: <a class="el" href="part2.html">2. Enhancing the 2-node TicToc</a> UP: <a class="el" href="index.html#contents">Contents</a><h2><a class="anchor" name="s9">
Step 9: More than two nodes</a></h2>
Now we'll make a big step: create several tic modules and connect them into a network. For now, we'll keep it simple what they do: one of the nodes generates a message, and the others keep tossing it around in random directions until it arrives at a predetermined destination node.<p>
The NED file will need a few changes. First of all, the Txc module will need to have multiple input and output gates:<p>
 <div class="fragment"><pre class="fragment">simple <a class="code" href="classTxc9.html">Txc9</a>
    gates:
        in: in[];  <span class="comment">// declare in[] and out[] to be vector gates</span>
        out: out[];
endsimple
</pre></div><p>
The [ ] turns the gates into gate vectors. The size of the vector (the number of gates) will be determined where we use Txc to build the network.<p>
<div class="fragment"><pre class="fragment">module Tictoc9
    submodules:
        tic: <a class="code" href="classTxc9.html">Txc9</a>[6];   <span class="comment">// we'll have 6 Txc modules</span>
            display: <span class="stringliteral">"i=block/process"</span>;
    connections:
        tic[0].out++ --&gt; delay 100ms --&gt; tic[1].in++;
        tic[0].in++ &lt;-- delay 100ms &lt;-- tic[1].out++;

        tic[1].out++ --&gt; delay 100ms --&gt; tic[2].in++;
        tic[1].in++ &lt;-- delay 100ms &lt;-- tic[2].out++;

        tic[1].out++ --&gt; delay 100ms --&gt; tic[4].in++;
        tic[1].in++ &lt;-- delay 100ms &lt;-- tic[4].out++;

        tic[3].out++ --&gt; delay 100ms --&gt; tic[4].in++;
        tic[3].in++ &lt;-- delay 100ms &lt;-- tic[4].out++;

        tic[4].out++ --&gt; delay 100ms --&gt; tic[5].in++;
        tic[4].in++ &lt;-- delay 100ms &lt;-- tic[5].out++;
endmodule
</pre></div><p>
Here we created 6 modules as a module vector, and connected them.<p>
The resulting topology looks like this:<p>
<div align="center">
<img src="step9.gif" alt="step9.gif">
</div>
<p>
In this version, tic[0] will generate the message to be sent around. This is done in initialize(), with the help of the index() function which returns the index of the module in the vector.<p>
The meat of the code is the forwardMessage() function which we invoke from handleMessage() whenever a message arrives at the node. It draws a random gate number (size() is the size of the gate vector), and sends out message on that gate.<p>
 <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="classTxc9.html#9c592e4e26df1a28a1dc264a63904e78">Txc9::forwardMessage</a>(<a class="codeRef" doxygen="opptags.xml:../api//" href="../api//classcMessage.html">cMessage</a> *msg)
{
    <span class="comment">// In this example, we just pick a random gate to send it on.</span>
    <span class="comment">// We draw a random number between 0 and the size of gate `out[]'.</span>
    <span class="keywordtype">int</span> n = <a class="codeRef" doxygen="opptags.xml:../api//" href="../api//classcModule.html#eb396a6d57228b3dd505d9463c35f133">gate</a>(<span class="stringliteral">"out"</span>)-&gt;<a class="codeRef" doxygen="opptags.xml:../api//" href="../api//classcGate.html#5a9421972c178b3c37b99f953470c6f6">size</a>();
    <span class="keywordtype">int</span> k = intuniform(0,n-1);

    <a class="codeRef" doxygen="opptags.xml:../api//" href="../api//group__Envir.html#g3cf804e7182ab12879c33c914e1c5cd8">ev</a> &lt;&lt; <span class="stringliteral">"Forwarding message "</span> &lt;&lt; msg &lt;&lt; <span class="stringliteral">" on port out["</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">"]\n"</span>;
    <a class="codeRef" doxygen="opptags.xml:../api//" href="../api//classcSimpleModule.html#03a9558a2c1f86db6e079fc25e7799d6">send</a>(msg, <span class="stringliteral">"out"</span>, k);
}
</pre></div><p>
When the message arrives at tic[3], its handleMessage() will delete the message.<p>
See the full code in <a class="el" href="txc9.cc.html">txc9.cc</a>.<p>
<em>Exercise: you'll notice that this simple "routing" is not very efficient: often the packet keeps bouncing between two nodes for a while before it is sent to a different direction. This can be improved somewhat if nodes don't send the packet back to the sender. Implement this. Hints: <a class="elRef" doxygen="opptags.xml:../api//" href="../api//classcMessage.html#c787a791161245df014300e7be0452a8">cMessage::arrivalGate()</a>, <a class="elRef" doxygen="opptags.xml:../api//" href="../api//classcGate.html#40083a7f8c9df89c916d300fa3bfe621">cGate::index()</a>. Note that if the message didn't arrive via a gate but was a self-message, then arrivalGate() returns NULL. </em><p>
Sources: <a class="el" href="tictoc9.ned.html">tictoc9.ned</a>, <a class="el" href="txc9.cc.html">txc9.cc</a>, <a class="el" href="omnetpp.ini.html">omnetpp.ini</a><h2><a class="anchor" name="s10">
Step 10: Defining our message class</a></h2>
In this step the destination address is no longer hardcoded tic[3] -- we draw a random destination, and we'll add the destination address to the message.<p>
The best way is to subclass <a class="elRef" doxygen="opptags.xml:../api//" href="../api//classcMessage.html">cMessage</a> and add destination as a data member. Hand-coding the message class is usually tedious because it contains a lot of boilerplate code, so we let OMNeT++ generate the class for us. The message class specification is in tictoc10.msg:<p>
 <div class="fragment"><pre class="fragment">message TicTocMsg10
{
    fields:
        <span class="keywordtype">int</span> source;
        <span class="keywordtype">int</span> destination;
        <span class="keywordtype">int</span> hopCount = 0;
}
</pre></div><p>
The makefile is set up so that the message compiler, opp_msgc is invoked and it generates tictoc10_m.h and tictoc10_m.cc from the message declaration. They will contain a generated TicTocMsg10 class subclassed from <a class="elRef" doxygen="opptags.xml:../api//" href="../api//classcMessage.html">cMessage</a>; the class will have getter and setter methods for every field.<p>
We'll include tictoc10_m.h into our C++ code, and we can use TicTocMsg10 as any other class.<p>
 <div class="fragment"><pre class="fragment"><span class="preprocessor">#include "tictoc10_m.h"</span>
</pre></div><p>
For example, we use the following lines in generateMessage() to create the message and fill its fields.<p>
<div class="fragment"><pre class="fragment">    TicTocMsg10 *msg = <span class="keyword">new</span> TicTocMsg10(msgname);
    msg-&gt;setSource(src);
    msg-&gt;setDestination(dest);
    <span class="keywordflow">return</span> msg;
</pre></div><p>
Then, handleMessage() begins like this:<p>
 <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="classTxc10.html#0173701fdb662ebea73223bab4b75fb9">Txc10::handleMessage</a>(<a class="codeRef" doxygen="opptags.xml:../api//" href="../api//classcMessage.html">cMessage</a> *msg)
{
    TicTocMsg10 *ttmsg = check_and_cast&lt;TicTocMsg10 *&gt;(msg);

    <span class="keywordflow">if</span> (ttmsg-&gt;getDestination()==<a class="codeRef" doxygen="opptags.xml:../api//" href="../api//classcModule.html#40083a7f8c9df89c916d300fa3bfe621">index</a>())
</pre></div><p>
In the argument to handleMessage(), we get the message as a <a class="elRef" doxygen="opptags.xml:../api//" href="../api//classcMessage.html">cMessage</a> * pointer. However, we can only access its fields defined in TicTocMsg10 if we cast msg to TicTocMsg10 *. Plain C-style cast (<code>(TicTocMsg10 *)msg</code>) is not safe because if the message is <em>not</em> a TicTocMsg10 after all the program will just crash, causing an error which is difficult to explore.<p>
C++ offers a solution which is called dynamic_cast. Here we use <a class="elRef" doxygen="opptags.xml:../api//" href="../api//group__Functions.html#gd76c0d388dfc7a6109856de8e60cb276">check_and_cast&lt;&gt;()</a> which is provided by OMNeT++: it tries to cast the pointer via dynamic_cast, and if it fails it stops the simulation with an error message, similar to the following:<p>
<div align="center">
<img src="step10e.gif" alt="step10e.gif">
</div>
<p>
In the next line, we check if the destination address is the same as the node's address. The <code>index()</code> member function returns the index of the module in the submodule vector (remember, in the NED file we declarared it as <code>tic: <a class="el" href="classTxc10.html">Txc10</a>[6]</code>, so our nodes have addresses 0..5).<p>
To make the model execute longer, after a message arrives to its destination the destination node will generate another message with a random destination address, and so forth. Read the full code: <a class="el" href="txc10.cc.html">txc10.cc</a>.<p>
When you run the model, it'll look like this:<p>
<div align="center">
<img src="step10a.gif" alt="step10a.gif">
</div>
<p>
You can double-click on the messages to open an inspector for them. (You'll either have to temporarily stop the simulation for that, or to be very fast in handling the mouse). The inspector window displays lots of useful information; the message fields can be seen on the Contents page.<p>
<div align="center">
<img src="step10b.gif" alt="step10b.gif">
</div>
<p>
Sources: <a class="el" href="tictoc10.ned.html">tictoc10.ned</a>, <a class="el" href="tictoc10.msg.html">tictoc10.msg</a>, <a class="el" href="txc10.cc.html">txc10.cc</a>, <a class="el" href="omnetpp.ini.html">omnetpp.ini</a><p>
<em>Exercise: In this model, there is only one message underway at any given moment: nodes only generate a message when another message arrives at them. We did it this way to make it easier to follow the simulation. Change the module class so that instead, it generates messages periodically. The interval between messages should be a module parameter, returning exponentially distributed random numbers. </em><p>
NEXT: <a class="el" href="part4.html">4. Adding statistics collection</a> <hr size="1"><address style="align: right;"><small>Generated on Sun Nov 19 13:30:42 2006 for Tictoc Tutorial by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
