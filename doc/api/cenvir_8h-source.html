<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OMNeT++/OMNEST Simulation Library: cenvir.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="dir_559b0ddaca1bdb28c313d8ffeea4eba0.html">include</a></div>
<h1>cenvir.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//==========================================================================</span>
<a name="l00002"></a>00002 <span class="comment">//  CENVIR.H - part of</span>
<a name="l00003"></a>00003 <span class="comment">//</span>
<a name="l00004"></a>00004 <span class="comment">//                     OMNeT++/OMNEST</span>
<a name="l00005"></a>00005 <span class="comment">//            Discrete System Simulation in C++</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">//</span>
<a name="l00008"></a>00008 <span class="comment">//  Declaration of the following classes:</span>
<a name="l00009"></a>00009 <span class="comment">//    cEnvir    : user interface class</span>
<a name="l00010"></a>00010 <span class="comment">//</span>
<a name="l00011"></a>00011 <span class="comment">//==========================================================================</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="comment">/*--------------------------------------------------------------*</span>
<a name="l00014"></a>00014 <span class="comment">  Copyright (C) 1992-2005 Andras Varga</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">  This file is distributed WITHOUT ANY WARRANTY. See the file</span>
<a name="l00017"></a>00017 <span class="comment">  `license' for details on this and other legal matters.</span>
<a name="l00018"></a>00018 <span class="comment">*--------------------------------------------------------------*/</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#ifndef __CENVIR_H</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span><span class="preprocessor">#define __CENVIR_H</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include "defs.h"</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="keyword">class </span><a class="code" href="classcObject.html">cObject</a>;
<a name="l00028"></a>00028 <span class="keyword">class </span><a class="code" href="classcMessage.html">cMessage</a>;
<a name="l00029"></a>00029 <span class="keyword">class </span><a class="code" href="classcGate.html">cGate</a>;
<a name="l00030"></a>00030 <span class="keyword">class </span><a class="code" href="classcModule.html">cModule</a>;
<a name="l00031"></a>00031 <span class="keyword">class </span><a class="code" href="classcSimpleModule.html">cSimpleModule</a>;
<a name="l00032"></a>00032 <span class="keyword">class </span><a class="code" href="classcStatistic.html">cStatistic</a>;
<a name="l00033"></a>00033 <span class="keyword">class </span><a class="code" href="classcRNG.html">cRNG</a>;
<a name="l00034"></a>00034 <span class="keyword">class </span><a class="code" href="classcConfiguration.html">cConfiguration</a>;
<a name="l00035"></a>00035 <span class="keyword">class </span><a class="code" href="classcXMLElement.html">cXMLElement</a>;
<a name="l00036"></a>00036 <span class="keyword">class </span>TOmnetApp;
<a name="l00037"></a>00037 <span class="keyword">class </span><a class="code" href="classcEnvir.html">cEnvir</a>;
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="keyword">using</span> std::endl;
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="comment">//</span>
<a name="l00042"></a>00042 <span class="comment">// std::streambuf used by cEnvir's ostream base. It redirects writes to</span>
<a name="l00043"></a>00043 <span class="comment">// cEnvir::sputn(s,n). Flush is done at the end of each line, meanwhile</span>
<a name="l00044"></a>00044 <span class="comment">// writes are buffered in a stringbuf.</span>
<a name="l00045"></a>00045 <span class="comment">//</span>
<a name="l00046"></a>00046 <span class="keyword">template</span> &lt;<span class="keyword">class</span> E, <span class="keyword">class</span> T = std::<span class="keywordtype">char</span>_traits&lt;E&gt; &gt;
<a name="l00047"></a>00047     <span class="keyword">class </span>basic_evbuf : <span class="keyword">public</span> std::basic_stringbuf&lt;E,T&gt; {
<a name="l00048"></a>00048 <span class="keyword">public</span>:
<a name="l00049"></a>00049     basic_evbuf(<a class="code" href="classcEnvir.html">cEnvir</a> *<a class="code" href="group__Envir.html#g64df4cf1ebaf5fbc18bbf3de9ef03226">ev</a>) : _ev(<a class="code" href="group__Envir.html#g64df4cf1ebaf5fbc18bbf3de9ef03226">ev</a>) {}
<a name="l00050"></a>00050     <span class="comment">// gcc&gt;=3.4 needs either this-&gt; or std::basic_stringbuf&lt;E,T&gt;:: in front of pptr()/pbase()</span>
<a name="l00051"></a>00051     <span class="keywordtype">bool</span> isempty() {<span class="keywordflow">return</span> this-&gt;pptr()==this-&gt;pbase();}
<a name="l00052"></a>00052 <span class="keyword">protected</span>:
<a name="l00053"></a>00053     <span class="keyword">virtual</span> <span class="keywordtype">int</span> sync();
<a name="l00054"></a>00054     <span class="keyword">virtual</span> std::streamsize xsputn(<span class="keyword">const</span> E *s, std::streamsize n) {
<a name="l00055"></a>00055 <span class="preprocessor">#if !defined(_MSC_VER) || _MSC_VER&gt;1200</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span>        std::streamsize r = std::basic_stringbuf&lt;E,T&gt;::xsputn(s,n);
<a name="l00057"></a>00057 <span class="preprocessor">#else</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span>        <span class="comment">// **HACK** The above line (calling the same function in the base class)</span>
<a name="l00059"></a>00059         <span class="comment">// doesn't work with MSVC6.0: it gives a weird compilation error.</span>
<a name="l00060"></a>00060         <span class="comment">// So as a workaround I copied here the body of the original xsputn()</span>
<a name="l00061"></a>00061         <span class="comment">// function from the MSVC header, VC98/Include/streambuf.</span>
<a name="l00062"></a>00062         <span class="keyword">const</span> E *_S = s;
<a name="l00063"></a>00063         std::streamsize _N = n;
<a name="l00064"></a>00064         std::streamsize _M, _Ns;
<a name="l00065"></a>00065         <span class="keywordflow">for</span> (_Ns = 0; 0 &lt; _N; )
<a name="l00066"></a>00066             <span class="keywordflow">if</span> (pptr() != 0 &amp;&amp; 0 &lt; (_M = epptr() - pptr()))
<a name="l00067"></a>00067                 {<span class="keywordflow">if</span> (_N &lt; _M)
<a name="l00068"></a>00068                     _M = _N;
<a name="l00069"></a>00069                 T::copy(pptr(), _S, _M);
<a name="l00070"></a>00070                 _S += _M, _Ns += _M, _N -= _M, pbump(_M); }
<a name="l00071"></a>00071             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (T::eq_int_type(T::eof(),
<a name="l00072"></a>00072                 overflow(T::to_int_type(*_S))))
<a name="l00073"></a>00073                 <span class="keywordflow">break</span>;
<a name="l00074"></a>00074             <span class="keywordflow">else</span>
<a name="l00075"></a>00075                 ++_S, ++_Ns, --_N;
<a name="l00076"></a>00076         std::streamsize r = _Ns;
<a name="l00077"></a>00077 <span class="preprocessor">#endif</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span>        <span class="keywordflow">for</span>(;n&gt;0;n--,s++)
<a name="l00079"></a>00079             <span class="keywordflow">if</span> (*s==<span class="charliteral">'\n'</span>)
<a name="l00080"></a>00080                {sync();<span class="keywordflow">break</span>;}
<a name="l00081"></a>00081         <span class="keywordflow">return</span> r;
<a name="l00082"></a>00082     }
<a name="l00083"></a>00083     <a class="code" href="classcEnvir.html">cEnvir</a> *_ev;
<a name="l00084"></a>00084 };
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 <span class="keyword">typedef</span> basic_evbuf&lt;char&gt; evbuf;
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 
<a name="l00107"></a>00107 ENVIR_API <span class="keyword">extern</span> <a class="code" href="classcEnvir.html">cEnvir</a> <a class="code" href="group__Envir.html#g64df4cf1ebaf5fbc18bbf3de9ef03226">ev</a>;
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 ENVIR_API <span class="keywordtype">bool</span> memoryIsLow();
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 
<a name="l00143"></a><a class="code" href="classcEnvir.html">00143</a> <span class="keyword">class </span>ENVIR_API cEnvir : <span class="keyword">public</span> std::ostream
<a name="l00144"></a>00144 {
<a name="l00145"></a>00145   <span class="keyword">public</span>:
<a name="l00146"></a>00146     <span class="comment">// internal variables</span>
<a name="l00147"></a>00147     TOmnetApp *app;  <span class="comment">// the application" instance</span>
<a name="l00148"></a>00148     <span class="keywordtype">bool</span> disable_tracing;
<a name="l00149"></a>00149     <span class="keywordtype">bool</span> debug_on_errors;
<a name="l00150"></a>00150   <span class="keyword">private</span>:
<a name="l00151"></a>00151     <span class="comment">// further internal vars</span>
<a name="l00152"></a>00152     evbuf ev_buf;
<a name="l00153"></a>00153     <span class="keywordtype">bool</span> isgui;
<a name="l00154"></a>00154 
<a name="l00155"></a>00155   <span class="keyword">public</span>:
<a name="l00156"></a>00156     <span class="comment">// internal: writes the first n characters of string s.</span>
<a name="l00157"></a>00157     <span class="comment">// evbuf (the streambuf underlying cEnvir's ostream base class)</span>
<a name="l00158"></a>00158     <span class="comment">// writes via this function.</span>
<a name="l00159"></a>00159     <span class="keywordtype">void</span> sputn(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <span class="keywordtype">int</span> n);
<a name="l00160"></a>00160 
<a name="l00161"></a>00161     <span class="comment">// internal: flushes the internal stream buffer by terminating last line if needed</span>
<a name="l00162"></a>00162     <span class="comment">// note: exploits the fact that evbuf does sync() on "\n"'s</span>
<a name="l00163"></a>00163     <span class="keywordtype">void</span> flushlastline() {<span class="keywordflow">if</span> (!ev_buf.isempty()) ev_buf.sputn(<span class="stringliteral">"\n"</span>,1);}
<a name="l00164"></a>00164 
<a name="l00165"></a>00165   <span class="keyword">public</span>:
<a name="l00171"></a>00171 
<a name="l00175"></a>00175     cEnvir();
<a name="l00176"></a>00176 
<a name="l00180"></a>00180     ~cEnvir();
<a name="l00182"></a>00182 
<a name="l00185"></a>00185 
<a name="l00190"></a>00190     <span class="keywordtype">void</span> setup(<span class="keywordtype">int</span> ac, <span class="keywordtype">char</span> *av[]);
<a name="l00191"></a>00191 
<a name="l00197"></a>00197     <span class="keywordtype">int</span> run();
<a name="l00198"></a>00198 
<a name="l00202"></a>00202     <span class="keywordtype">void</span> shutdown();
<a name="l00204"></a>00204 
<a name="l00207"></a>00207 
<a name="l00214"></a>00214     <span class="keywordtype">void</span> objectDeleted(<a class="code" href="classcObject.html">cObject</a> *object);
<a name="l00215"></a>00215 
<a name="l00229"></a>00229     <span class="keywordtype">void</span> messageSent(<a class="code" href="classcMessage.html">cMessage</a> *msg, <a class="code" href="classcGate.html">cGate</a> *directToGate=NULL);
<a name="l00230"></a>00230 
<a name="l00234"></a>00234     <span class="keywordtype">void</span> moduleReparented(<a class="code" href="classcModule.html">cModule</a> *module, <a class="code" href="classcModule.html">cModule</a> *oldparent);
<a name="l00235"></a>00235 
<a name="l00243"></a>00243     <span class="keywordtype">void</span> messageDelivered(<a class="code" href="classcMessage.html">cMessage</a> *msg);
<a name="l00244"></a>00244 
<a name="l00249"></a>00249     <span class="keywordtype">void</span> breakpointHit(<span class="keyword">const</span> <span class="keywordtype">char</span> *lbl, <a class="code" href="classcSimpleModule.html">cSimpleModule</a> *mod);
<a name="l00250"></a>00250 
<a name="l00256"></a>00256     <span class="keywordtype">void</span> moduleMethodCalled(<a class="code" href="classcModule.html">cModule</a> *from, <a class="code" href="classcModule.html">cModule</a> *to, <span class="keyword">const</span> <span class="keywordtype">char</span> *method);
<a name="l00257"></a>00257 
<a name="l00263"></a>00263     <span class="keywordtype">void</span> moduleCreated(<a class="code" href="classcModule.html">cModule</a> *newmodule);
<a name="l00264"></a>00264 
<a name="l00276"></a>00276     <span class="keywordtype">void</span> moduleDeleted(<a class="code" href="classcModule.html">cModule</a> *module);
<a name="l00277"></a>00277 
<a name="l00282"></a>00282     <span class="keywordtype">void</span> connectionCreated(<a class="code" href="classcGate.html">cGate</a> *srcgate);
<a name="l00283"></a>00283 
<a name="l00288"></a>00288     <span class="keywordtype">void</span> connectionRemoved(<a class="code" href="classcGate.html">cGate</a> *srcgate);
<a name="l00289"></a>00289 
<a name="l00294"></a>00294     <span class="keywordtype">void</span> displayStringChanged(<a class="code" href="classcGate.html">cGate</a> *gate);
<a name="l00295"></a>00295 
<a name="l00299"></a>00299     <span class="comment">// TBD: how does module name change propagate to gui?</span>
<a name="l00300"></a>00300     <span class="keywordtype">void</span> displayStringChanged(<a class="code" href="classcModule.html">cModule</a> *submodule);
<a name="l00301"></a>00301 
<a name="l00305"></a>00305     <span class="keywordtype">void</span> backgroundDisplayStringChanged(<a class="code" href="classcModule.html">cModule</a> *parentmodule);
<a name="l00306"></a>00306 
<a name="l00311"></a>00311     <span class="keywordtype">void</span> undisposedObject(<a class="code" href="classcObject.html">cObject</a> *obj);
<a name="l00313"></a>00313 
<a name="l00316"></a>00316 
<a name="l00322"></a>00322     std::string getParameter(<span class="keywordtype">int</span> run_no, <span class="keyword">const</span> <span class="keywordtype">char</span> *parname);
<a name="l00323"></a>00323 
<a name="l00328"></a>00328     <span class="keywordtype">bool</span> getParameterUseDefault(<span class="keywordtype">int</span> run_no, <span class="keyword">const</span> <span class="keywordtype">char</span> *parname);
<a name="l00329"></a>00329 
<a name="l00339"></a>00339     <span class="keywordtype">bool</span> isModuleLocal(<a class="code" href="classcModule.html">cModule</a> *parentmod, <span class="keyword">const</span> <span class="keywordtype">char</span> *modname, <span class="keywordtype">int</span> index);
<a name="l00340"></a>00340 
<a name="l00362"></a>00362     <a class="code" href="classcXMLElement.html">cXMLElement</a> *getXMLDocument(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename, <span class="keyword">const</span> <span class="keywordtype">char</span> *path=NULL);
<a name="l00363"></a>00363 
<a name="l00368"></a>00368     <span class="keywordtype">unsigned</span> extraStackForEnvir();
<a name="l00369"></a>00369 
<a name="l00377"></a>00377     <a class="code" href="classcConfiguration.html">cConfiguration</a> *config();
<a name="l00379"></a>00379 
<a name="l00382"></a>00382 
<a name="l00388"></a><a class="code" href="classcEnvir.html#68603e7947f6d2e9bc8963d23ba9ec94">00388</a>     <span class="keywordtype">bool</span> isGUI()  {<span class="keywordflow">return</span> isgui;}
<a name="l00389"></a>00389 
<a name="l00406"></a><a class="code" href="classcEnvir.html#7302b533b64fcd539a0ab8f5d3144d4b">00406</a>     <span class="keywordtype">bool</span> disabled() {<span class="keywordflow">return</span> disable_tracing;}
<a name="l00407"></a>00407 
<a name="l00411"></a>00411     <span class="keywordtype">void</span> bubble(<a class="code" href="classcModule.html">cModule</a> *mod, <span class="keyword">const</span> <span class="keywordtype">char</span> *text);
<a name="l00412"></a>00412 
<a name="l00417"></a>00417     <span class="keywordtype">void</span> printfmsg(<span class="keyword">const</span> <span class="keywordtype">char</span> *fmt,...);
<a name="l00418"></a>00418 
<a name="l00426"></a>00426     <span class="keywordtype">void</span> printf(<span class="keyword">const</span> <span class="keywordtype">char</span> *fmt=<span class="stringliteral">"\n"</span>,...);
<a name="l00427"></a>00427 
<a name="l00432"></a>00432     <span class="keywordtype">void</span> puts(<span class="keyword">const</span> <span class="keywordtype">char</span> *s) _OPPDEPRECATED;
<a name="l00433"></a>00433 
<a name="l00440"></a>00440     cEnvir&amp; flush();
<a name="l00441"></a>00441 
<a name="l00446"></a>00446     std::string gets(<span class="keyword">const</span> <span class="keywordtype">char</span> *prompt, <span class="keyword">const</span> <span class="keywordtype">char</span> *defaultreply=NULL);
<a name="l00447"></a>00447 
<a name="l00451"></a>00451     <span class="keywordtype">bool</span> gets(<span class="keyword">const</span> <span class="keywordtype">char</span> *prompt, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> len=255) _OPPDEPRECATED;
<a name="l00452"></a>00452 
<a name="l00458"></a>00458     <span class="keywordtype">bool</span> askYesNo(const <span class="keywordtype">char</span> *msgfmt,...);
<a name="l00460"></a>00460 
<a name="l00463"></a>00463 
<a name="l00468"></a>00468     <span class="keywordtype">int</span> numRNGs();
<a name="l00469"></a>00469 
<a name="l00473"></a>00473     <a class="code" href="classcRNG.html">cRNG</a> *rng(<span class="keywordtype">int</span> k);
<a name="l00474"></a>00474 
<a name="l00479"></a>00479     <span class="keywordtype">void</span> getRNGMappingFor(<a class="code" href="classcModule.html">cModule</a> *mod);
<a name="l00481"></a>00481 
<a name="l00491"></a>00491 
<a name="l00498"></a>00498     <span class="keywordtype">void</span> *registerOutputVector(const <span class="keywordtype">char</span> *modulename, const <span class="keywordtype">char</span> *vectorname, <span class="keywordtype">int</span> tuple);
<a name="l00499"></a>00499 
<a name="l00503"></a>00503     <span class="keywordtype">void</span> deregisterOutputVector(<span class="keywordtype">void</span> *vechandle);
<a name="l00504"></a>00504 
<a name="l00510"></a>00510     <span class="keywordtype">bool</span> recordInOutputVector(<span class="keywordtype">void</span> *vechandle, simtime_t t, <span class="keywordtype">double</span> value);
<a name="l00511"></a>00511 
<a name="l00517"></a>00517     <span class="keywordtype">bool</span> recordInOutputVector(<span class="keywordtype">void</span> *vechandle, simtime_t t, <span class="keywordtype">double</span> value1, <span class="keywordtype">double</span> value2);
<a name="l00519"></a>00519 
<a name="l00529"></a>00529 
<a name="l00533"></a>00533     <span class="keywordtype">void</span> recordScalar(<a class="code" href="classcModule.html">cModule</a> *module, const <span class="keywordtype">char</span> *name, <span class="keywordtype">double</span> value);
<a name="l00535"></a>00535 
<a name="l00543"></a>00543 
<a name="l00547"></a>00547     std::ostream *getStreamForSnapshot();
<a name="l00548"></a>00548 
<a name="l00552"></a>00552     <span class="keywordtype">void</span> releaseStreamForSnapshot(std::ostream *os);
<a name="l00554"></a>00554 
<a name="l00560"></a>00560     <span class="keywordtype">int</span> argCount();
<a name="l00561"></a>00561 
<a name="l00565"></a>00565     <span class="keywordtype">char</span> **argVector();
<a name="l00566"></a>00566 
<a name="l00570"></a>00570     <span class="keywordtype">int</span> getParsimProcId();
<a name="l00571"></a>00571 
<a name="l00576"></a>00576     <span class="keywordtype">int</span> getParsimNumPartitions();
<a name="l00577"></a>00577 
<a name="l00581"></a>00581     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> getUniqueNumber();
<a name="l00582"></a>00582 
<a name="l00596"></a>00596     <span class="keywordtype">bool</span> idle();
<a name="l00598"></a>00598 };
<a name="l00599"></a>00599 
<a name="l00600"></a>00600 template &lt;class E, class T&gt;
<a name="l00601"></a>00601 <span class="keywordtype">int</span> basic_evbuf&lt;E,T&gt;::sync() {
<a name="l00602"></a>00602     _ev-&gt;sputn(this-&gt;pbase(), this-&gt;pptr()-this-&gt;pbase());
<a name="l00603"></a>00603     setp(this-&gt;pbase(),this-&gt;epptr());
<a name="l00604"></a>00604     <span class="keywordflow">return</span> 0;
<a name="l00605"></a>00605 }
<a name="l00606"></a>00606 
<a name="l00607"></a>00607 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Nov 19 13:30:33 2006 for OMNeT++/OMNEST Simulation Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
