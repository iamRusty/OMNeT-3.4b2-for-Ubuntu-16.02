<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>OMNeT++ - Manual</TITLE>
   <META NAME="Author" CONTENT="Andras Varga">
</HEAD>

<style type="text/css">
h1,h2,h3,h4,h5,h6,.subheading,.toc {font-family: "Trebuchet MS", Geneva, Arial, Helvetica, sans-serif;}
h1 {color: #006f00;}
h2 {color: #006f00;}
h3 {color: #006f00;}
pre { margin-left:8pt; font-size:8pt; background:#fffff4; padding:5pt; border:1px solid; border-color:#a0a0a0 }
table {background:#fffff4; margin-left:8pt; border-collapse:collapse; border: 2px solid}
td,th {text-align:left; vertical-align:top; border:1px solid; padding:3pt; border-color:#000000}
.subheading {color: black; font-weight: bold;}
a {text-decoration: none;}
a:visited {text-decoration: none;}
# a:hover {text-decoration: underline;}
</style>

<BODY TEXT="#000000" BGCOLOR="#FFFFE8" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000">

<br>
<img src="omnetpp.gif" border="0">
<!--
<h1><FONT COLOR="#FF0000"><B><FONT SIZE=+4>OMNeT++ </FONT></B>
<I><FONT SIZE=+1>Discrete Event Simulation System</FONT></I></FONT></h1>
-->

<H1><B>User Manual</B></H1><H3>OMNeT++ version 3.2</H3><H1>Chapters</H1>
<p>
<B><A HREF="#toc_1" class="toc">1 Introduction</A></B><BR>
<B><A HREF="#toc_2" class="toc">2 Overview</A></B><BR>
<B><A HREF="#toc_3" class="toc">3 The NED Language</A></B><BR>
<B><A HREF="#toc_4" class="toc">4 Simple Modules</A></B><BR>
<B><A HREF="#toc_5" class="toc">5 Messages</A></B><BR>
<B><A HREF="#toc_6" class="toc">6 The Simulation Library</A></B><BR>
<B><A HREF="#toc_7" class="toc">7 Building Simulation Programs</A></B><BR>
<B><A HREF="#toc_8" class="toc">8 Configuring and Running Simulations</A></B><BR>
<B><A HREF="#toc_9" class="toc">9 Network Graphics And Animation</A></B><BR>
<B><A HREF="#toc_10" class="toc">10 Analyzing Simulation Results</A></B><BR>
<B><A HREF="#toc_11" class="toc">11 Documenting NED and Messages</A></B><BR>
<B><A HREF="#toc_12" class="toc">12 Parallel Distributed Simulation</A></B><BR>
<B><A HREF="#toc_13" class="toc">13 Customization and Embedding</A></B><BR>
<B><A HREF="#toc_14" class="toc">14 NED Language Grammar</A></B><BR>
<B><A HREF="#toc_15" class="toc">15 References</A></B><BR>
</p><HR><H1>Table of Contents</H1>
<p>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_1"/><A HREF="#sec100" class="toc">1 Introduction</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_1.1"/><A HREF="#sec101" class="toc">1.1 What is OMNeT++?</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_1.2"/><A HREF="#sec102" class="toc">1.2 Organization of this manual</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_1.3"/><A HREF="#sec103" class="toc">1.3 Credits</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_2"/><A HREF="#sec104" class="toc">2 Overview</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1"/><A HREF="#sec105" class="toc">2.1 Modeling concepts</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.1"/><A HREF="#sec106" class="toc">2.1.1 Hierarchical modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.2"/><A HREF="#sec107" class="toc">2.1.2 Module types</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.3"/><A HREF="#sec108" class="toc">2.1.3 Messages, gates, links</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.4"/><A HREF="#sec109" class="toc">2.1.4 Modeling of packet transmissions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.5"/><A HREF="#sec110" class="toc">2.1.5 Parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.6"/><A HREF="#sec111" class="toc">2.1.6 Topology description method</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.2"/><A HREF="#sec112" class="toc">2.2 Programming the algorithms</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.3"/><A HREF="#sec113" class="toc">2.3 Using OMNeT++</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.3.1"/><A HREF="#sec114" class="toc">2.3.1 Building and running simulations</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.3.2"/><A HREF="#sec115" class="toc">2.3.2 What is in the distribution</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_3"/><A HREF="#sec116" class="toc">3 The NED Language</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.1"/><A HREF="#sec117" class="toc">3.1 NED overview</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.1.1"/><A HREF="#sec118" class="toc">3.1.1 Components of a NED description</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.1.2"/><A HREF="#sec119" class="toc">3.1.2 Reserved words</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.1.3"/><A HREF="#sec120" class="toc">3.1.3 Identifiers</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.1.4"/><A HREF="#sec121" class="toc">3.1.4 Case sensitivity</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.1.5"/><A HREF="#sec122" class="toc">3.1.5 Comments</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.2"/><A HREF="#sec123" class="toc">3.2 The import directive</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.3"/><A HREF="#sec124" class="toc">3.3 Channel definitions</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.4"/><A HREF="#sec125" class="toc">3.4 Simple module definitions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.4.1"/><A HREF="#sec126" class="toc">3.4.1 Simple module parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.4.2"/><A HREF="#sec127" class="toc">3.4.2 Simple module gates</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.5"/><A HREF="#sec128" class="toc">3.5 Compound module definitions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.5.1"/><A HREF="#sec129" class="toc">3.5.1 Compound module parameters and gates</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.5.2"/><A HREF="#sec130" class="toc">3.5.2 Submodules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.5.3"/><A HREF="#sec131" class="toc">3.5.3 Submodule type as parameter</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.5.4"/><A HREF="#sec132" class="toc">3.5.4 Assigning values to submodule parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.5.5"/><A HREF="#sec133" class="toc">3.5.5 Defining sizes of submodule gate vectors</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.5.6"/><A HREF="#sec134" class="toc">3.5.6 Conditional parameters and gatesizes sections</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.5.7"/><A HREF="#sec135" class="toc">3.5.7 Connections</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.6"/><A HREF="#sec136" class="toc">3.6 Network definitions</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.7"/><A HREF="#sec137" class="toc">3.7 Expressions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.7.1"/><A HREF="#sec138" class="toc">3.7.1 Constants</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.7.2"/><A HREF="#sec139" class="toc">3.7.2 Referencing parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.7.3"/><A HREF="#sec140" class="toc">3.7.3 Operators</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.7.4"/><A HREF="#sec141" class="toc">3.7.4 The <tt>sizeof()</tt> and <tt>index</tt> operators</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.7.5"/><A HREF="#sec142" class="toc">3.7.5 The <tt>xmldoc()</tt> operator</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.7.6"/><A HREF="#sec143" class="toc">3.7.6 XML documents and the XPath subset supported</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.7.7"/><A HREF="#sec144" class="toc">3.7.7 Functions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.7.8"/><A HREF="#sec145" class="toc">3.7.8 Random values</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.7.9"/><A HREF="#sec146" class="toc">3.7.9 Defining new functions</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.8"/><A HREF="#sec147" class="toc">3.8 Parameterized compound modules</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.8.1"/><A HREF="#sec148" class="toc">3.8.1 Examples</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.8.2"/><A HREF="#sec149" class="toc">3.8.2 Design patterns for compound modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.8.3"/><A HREF="#sec150" class="toc">3.8.3 Topology templates</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.9"/><A HREF="#sec151" class="toc">3.9 Large networks</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.9.1"/><A HREF="#sec152" class="toc">3.9.1 Generating NED files</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.9.2"/><A HREF="#sec153" class="toc">3.9.2 Building the network from C++ code</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.10"/><A HREF="#sec154" class="toc">3.10 XML binding for NED files</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_4"/><A HREF="#sec155" class="toc">4 Simple Modules</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1"/><A HREF="#sec156" class="toc">4.1 Simulation concepts</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.1"/><A HREF="#sec157" class="toc">4.1.1 Discrete Event Simulation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.2"/><A HREF="#sec158" class="toc">4.1.2 The event loop</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.3"/><A HREF="#sec159" class="toc">4.1.3 Simple modules in OMNeT++</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.4"/><A HREF="#sec160" class="toc">4.1.4 Events in OMNeT++</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.5"/><A HREF="#sec161" class="toc">4.1.5 FES implementation</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.2"/><A HREF="#sec162" class="toc">4.2 Packet transmission modeling</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.2.1"/><A HREF="#sec163" class="toc">4.2.1 Delay, bit error rate, data rate</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.2.2"/><A HREF="#sec164" class="toc">4.2.2 Multiple transmissions on links</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.3"/><A HREF="#sec165" class="toc">4.3 Defining simple module types</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.3.1"/><A HREF="#sec166" class="toc">4.3.1 Overview</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.3.2"/><A HREF="#sec167" class="toc">4.3.2 Constructor</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.3.3"/><A HREF="#sec168" class="toc">4.3.3 Constructor and destructor vs initialize() and finish()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.3.4"/><A HREF="#sec169" class="toc">4.3.4 Compatibility with earlier versions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.3.5"/><A HREF="#sec170" class="toc">4.3.5 "Garbage collection" and compatibility</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.3.6"/><A HREF="#sec171" class="toc">4.3.6 An example</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.3.7"/><A HREF="#sec172" class="toc">4.3.7 Using global variables</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.4"/><A HREF="#sec173" class="toc">4.4 Adding functionality to cSimpleModule</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.4.1"/><A HREF="#sec174" class="toc">4.4.1 handleMessage()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.4.2"/><A HREF="#sec175" class="toc">4.4.2 activity()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.4.3"/><A HREF="#sec176" class="toc">4.4.3 initialize() and finish()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.4.4"/><A HREF="#sec177" class="toc">4.4.4 handleParameterChange()<sup><b>[New!]</b></sup></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.4.5"/><A HREF="#sec178" class="toc">4.4.5 Reusing module code via subclassing</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.5"/><A HREF="#sec179" class="toc">4.5 Finite State Machines in OMNeT++</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6"/><A HREF="#sec180" class="toc">4.6 Sending and receiving messages</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.1"/><A HREF="#sec181" class="toc">4.6.1 Sending messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.2"/><A HREF="#sec182" class="toc">4.6.2 Broadcasts and retransmissions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.3"/><A HREF="#sec183" class="toc">4.6.3 Delayed sending</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.4"/><A HREF="#sec184" class="toc">4.6.4 Direct message sending</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.5"/><A HREF="#sec185" class="toc">4.6.5 Receiving messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.6"/><A HREF="#sec186" class="toc">4.6.6 The wait() function</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.7"/><A HREF="#sec187" class="toc">4.6.7 Modeling events using self-messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.8"/><A HREF="#sec188" class="toc">4.6.8 Stopping the simulation</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.7"/><A HREF="#sec189" class="toc">4.7 Accessing module parameters</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.7.1"/><A HREF="#sec190" class="toc">4.7.1 Emulating parameter arrays</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.8"/><A HREF="#sec191" class="toc">4.8 Accessing gates and connections</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.8.1"/><A HREF="#sec192" class="toc">4.8.1 Gate objects</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.8.2"/><A HREF="#sec193" class="toc">4.8.2 Connection parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.8.3"/><A HREF="#sec194" class="toc">4.8.3 Transmission state</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.8.4"/><A HREF="#sec195" class="toc">4.8.4 Connectivity</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.9"/><A HREF="#sec196" class="toc">4.9 Walking the module hierarchy</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.10"/><A HREF="#sec197" class="toc">4.10 Direct method calls between modules</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.11"/><A HREF="#sec198" class="toc">4.11 Dynamic module creation</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.11.1"/><A HREF="#sec199" class="toc">4.11.1 When do you need dynamic module creation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.11.2"/><A HREF="#sec200" class="toc">4.11.2 Overview</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.11.3"/><A HREF="#sec201" class="toc">4.11.3 Creating modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.11.4"/><A HREF="#sec202" class="toc">4.11.4 Deleting modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.11.5"/><A HREF="#sec203" class="toc">4.11.5 Module deletion and finish()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.11.6"/><A HREF="#sec204" class="toc">4.11.6 Creating connections</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.11.7"/><A HREF="#sec205" class="toc">4.11.7 Removing connections</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_5"/><A HREF="#sec206" class="toc">5 Messages</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1"/><A HREF="#sec207" class="toc">5.1 Messages and packets</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.1"/><A HREF="#sec208" class="toc">5.1.1 The cMessage class</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.2"/><A HREF="#sec209" class="toc">5.1.2 Self-messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.3"/><A HREF="#sec210" class="toc">5.1.3 Modelling packets</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.4"/><A HREF="#sec211" class="toc">5.1.4 Encapsulation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.5"/><A HREF="#sec212" class="toc">5.1.5 Attaching parameters and objects</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2"/><A HREF="#sec213" class="toc">5.2 Message definitions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.1"/><A HREF="#sec214" class="toc">5.2.1 Introduction</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.2"/><A HREF="#sec215" class="toc">5.2.2 Declaring enums</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.3"/><A HREF="#sec216" class="toc">5.2.3 Message declarations</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.4"/><A HREF="#sec217" class="toc">5.2.4 Inheritance, composition</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.5"/><A HREF="#sec218" class="toc">5.2.5 Using existing C++ types</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.6"/><A HREF="#sec219" class="toc">5.2.6 Customizing the generated class</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.7"/><A HREF="#sec220" class="toc">5.2.7 Using STL in message classes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.8"/><A HREF="#sec221" class="toc">5.2.8 Summary</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.9"/><A HREF="#sec222" class="toc">5.2.9 What else is there in the generated code?</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_6"/><A HREF="#sec223" class="toc">6 The Simulation Library</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1"/><A HREF="#sec224" class="toc">6.1 Class library conventions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.1"/><A HREF="#sec225" class="toc">6.1.1 Base class</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.2"/><A HREF="#sec226" class="toc">6.1.2 Setting and getting attributes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.3"/><A HREF="#sec227" class="toc">6.1.3 className()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.4"/><A HREF="#sec228" class="toc">6.1.4 Name attribute</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.5"/><A HREF="#sec229" class="toc">6.1.5 fullName() and fullPath()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.6"/><A HREF="#sec230" class="toc">6.1.6 Copying and duplicating objects</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.7"/><A HREF="#sec231" class="toc">6.1.7 Iterators</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.8"/><A HREF="#sec232" class="toc">6.1.8 Error handling</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.2"/><A HREF="#sec233" class="toc">6.2 Logging from modules</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.3"/><A HREF="#sec234" class="toc">6.3 Simulation time conversion</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4"/><A HREF="#sec235" class="toc">6.4 Generating random numbers</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4.1"/><A HREF="#sec236" class="toc">6.4.1 Random number generators</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4.2"/><A HREF="#sec237" class="toc">6.4.2 Random number streams, RNG mapping</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4.3"/><A HREF="#sec238" class="toc">6.4.3 Accessing the RNGs</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4.4"/><A HREF="#sec239" class="toc">6.4.4 Random variates</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4.5"/><A HREF="#sec240" class="toc">6.4.5 Random numbers from histograms</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.5"/><A HREF="#sec241" class="toc">6.5 Container classes</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.5.1"/><A HREF="#sec242" class="toc">6.5.1 Queue class: cQueue</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.5.2"/><A HREF="#sec243" class="toc">6.5.2 Expandable array: cArray</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.6"/><A HREF="#sec244" class="toc">6.6 The parameter class: cPar</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.6.1"/><A HREF="#sec245" class="toc">6.6.1 Reading the value</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.6.2"/><A HREF="#sec246" class="toc">6.6.2 Changing the value</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.6.3"/><A HREF="#sec247" class="toc">6.6.3 cPar storage types</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.7"/><A HREF="#sec248" class="toc">6.7 Routing support: cTopology</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.7.1"/><A HREF="#sec249" class="toc">6.7.1 Overview</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.7.2"/><A HREF="#sec250" class="toc">6.7.2 Basic usage</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.7.3"/><A HREF="#sec251" class="toc">6.7.3 Shortest paths</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.8"/><A HREF="#sec252" class="toc">6.8 Statistics and distribution estimation</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.8.1"/><A HREF="#sec253" class="toc">6.8.1 cStatistic and descendants</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.8.2"/><A HREF="#sec254" class="toc">6.8.2 Distribution estimation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.8.3"/><A HREF="#sec255" class="toc">6.8.3 The k-split algorithm</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.8.4"/><A HREF="#sec256" class="toc">6.8.4 Transient detection and result accuracy</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.9"/><A HREF="#sec257" class="toc">6.9 Recording simulation results</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.9.1"/><A HREF="#sec258" class="toc">6.9.1 Output vectors: cOutVector</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.9.2"/><A HREF="#sec259" class="toc">6.9.2 Output scalars</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.9.3"/><A HREF="#sec260" class="toc">6.9.3 Precision<sup><b>[New!]</b></sup></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10"/><A HREF="#sec261" class="toc">6.10 Watches and snapshots</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10.1"/><A HREF="#sec262" class="toc">6.10.1 Basic watches</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10.2"/><A HREF="#sec263" class="toc">6.10.2 Read-write watches<sup><b>[New!]</b></sup></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10.3"/><A HREF="#sec264" class="toc">6.10.3 Structured watches<sup><b>[New!]</b></sup></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10.4"/><A HREF="#sec265" class="toc">6.10.4 STL watches<sup><b>[New!]</b></sup></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10.5"/><A HREF="#sec266" class="toc">6.10.5 Snapshots</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10.6"/><A HREF="#sec267" class="toc">6.10.6 Breakpoints</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10.7"/><A HREF="#sec268" class="toc">6.10.7 Getting coroutine stack usage</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.11"/><A HREF="#sec269" class="toc">6.11 Deriving new classes</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.11.1"/><A HREF="#sec270" class="toc">6.11.1 cObject or not?</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.11.2"/><A HREF="#sec271" class="toc">6.11.2 cObject virtual methods</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.11.3"/><A HREF="#sec272" class="toc">6.11.3 Class registration</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.11.4"/><A HREF="#sec273" class="toc">6.11.4 Details</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.12"/><A HREF="#sec274" class="toc">6.12 Object ownership management</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.12.1"/><A HREF="#sec275" class="toc">6.12.1 The ownership tree</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.12.2"/><A HREF="#sec276" class="toc">6.12.2 Managing ownership</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_7"/><A HREF="#sec277" class="toc">7 Building Simulation Programs</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.1"/><A HREF="#sec278" class="toc">7.1 Overview</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.2"/><A HREF="#sec279" class="toc">7.2 Using Unix and gcc</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.2.1"/><A HREF="#sec280" class="toc">7.2.1 Installation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.2.2"/><A HREF="#sec281" class="toc">7.2.2 Building simulation models</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.2.3"/><A HREF="#sec282" class="toc">7.2.3 Multi-directory models</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.2.4"/><A HREF="#sec283" class="toc">7.2.4 Static vs shared OMNeT++ system libraries</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.3"/><A HREF="#sec284" class="toc">7.3 Using Windows and Microsoft Visual C++</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.3.1"/><A HREF="#sec285" class="toc">7.3.1 Installation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.3.2"/><A HREF="#sec286" class="toc">7.3.2 Building simulation models on the command line</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.3.3"/><A HREF="#sec287" class="toc">7.3.3 Building simulation models from the MSVC IDE</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_8"/><A HREF="#sec288" class="toc">8 Configuring and Running Simulations</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.1"/><A HREF="#sec289" class="toc">8.1 User interfaces</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2"/><A HREF="#sec290" class="toc">8.2 The configuration file: omnetpp.ini<!--omnetpp.ini--></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2.1"/><A HREF="#sec291" class="toc">8.2.1 An example</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2.2"/><A HREF="#sec292" class="toc">8.2.2 The concept of simulation runs</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2.3"/><A HREF="#sec293" class="toc">8.2.3 File syntax</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2.4"/><A HREF="#sec294" class="toc">8.2.4 File inclusion</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2.5"/><A HREF="#sec295" class="toc">8.2.5 Sections</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2.6"/><A HREF="#sec296" class="toc">8.2.6 The [General] section</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.3"/><A HREF="#sec297" class="toc">8.3 Dynamic NED loading</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.4"/><A HREF="#sec298" class="toc">8.4 Setting module parameters in omnetpp.ini</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.4.1"/><A HREF="#sec299" class="toc">8.4.1 Run-specific and general sections</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.4.2"/><A HREF="#sec300" class="toc">8.4.2 Using wildcard patterns</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.4.3"/><A HREF="#sec301" class="toc">8.4.3 Applying the defaults</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.5"/><A HREF="#sec302" class="toc">8.5 Configuring output vectors</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.6"/><A HREF="#sec303" class="toc">8.6 Configuring the random number generators</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.6.1"/><A HREF="#sec304" class="toc">8.6.1 Number of RNGs</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.6.2"/><A HREF="#sec305" class="toc">8.6.2 RNG choice</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.6.3"/><A HREF="#sec306" class="toc">8.6.3 RNG mapping</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.6.4"/><A HREF="#sec307" class="toc">8.6.4 Automatic seed selection</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.6.5"/><A HREF="#sec308" class="toc">8.6.5 Manual seed configuration</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.6.6"/><A HREF="#sec309" class="toc">8.6.6 Choosing good seed values: the seedtool utility</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.7"/><A HREF="#sec310" class="toc">8.7 Cmdenv: the command-line interface</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.7.1"/><A HREF="#sec311" class="toc">8.7.1 Command-line switches</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.7.2"/><A HREF="#sec312" class="toc">8.7.2 Cmdenv ini file options</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.7.3"/><A HREF="#sec313" class="toc">8.7.3 Interpreting Cmdenv output</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.8"/><A HREF="#sec314" class="toc">8.8 Tkenv: the graphical user interface</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.8.1"/><A HREF="#sec315" class="toc">8.8.1 Command-line switches</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.8.2"/><A HREF="#sec316" class="toc">8.8.2 Tkenv ini file settings</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.8.3"/><A HREF="#sec317" class="toc">8.8.3 Using the graphical environment</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.8.4"/><A HREF="#sec318" class="toc">8.8.4 In Memoriam... </A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.9"/><A HREF="#sec319" class="toc">8.9 Repeating or iterating simulation runs</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.9.1"/><A HREF="#sec320" class="toc">8.9.1 Executing several runs</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.9.2"/><A HREF="#sec321" class="toc">8.9.2 Variations over parameter values</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.9.3"/><A HREF="#sec322" class="toc">8.9.3 Variations over seed value (multiple independent runs)</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.10"/><A HREF="#sec323" class="toc">8.10 Akaroa support: Multiple Replications in Parallel</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.10.1"/><A HREF="#sec324" class="toc">8.10.1 Introduction</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.10.2"/><A HREF="#sec325" class="toc">8.10.2 What is Akaroa</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.10.3"/><A HREF="#sec326" class="toc">8.10.3 Using Akaroa with OMNeT++</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.11"/><A HREF="#sec327" class="toc">8.11 Typical issues</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.11.1"/><A HREF="#sec328" class="toc">8.11.1 Stack problems</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.11.2"/><A HREF="#sec329" class="toc">8.11.2 Memory leaks and crashes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.11.3"/><A HREF="#sec330" class="toc">8.11.3 Simulation executes slowly</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_9"/><A HREF="#sec331" class="toc">9 Network Graphics And Animation</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.1"/><A HREF="#sec332" class="toc">9.1 Display strings</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.1.1"/><A HREF="#sec333" class="toc">9.1.1 Display string syntax</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.1.2"/><A HREF="#sec334" class="toc">9.1.2 Submodule display strings</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.1.3"/><A HREF="#sec335" class="toc">9.1.3 Background display strings</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.1.4"/><A HREF="#sec336" class="toc">9.1.4 Connection display strings</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.1.5"/><A HREF="#sec337" class="toc">9.1.5 Message display strings</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2"/><A HREF="#sec338" class="toc">9.2 Colors</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2.1"/><A HREF="#sec339" class="toc">9.2.1 Color names</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2.2"/><A HREF="#sec340" class="toc">9.2.2 Icon colorization</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.3"/><A HREF="#sec341" class="toc">9.3 The icons</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.3.1"/><A HREF="#sec342" class="toc">9.3.1 The bitmap path</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.3.2"/><A HREF="#sec343" class="toc">9.3.2 Categorized icons</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.3.3"/><A HREF="#sec344" class="toc">9.3.3 Icon size</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.4"/><A HREF="#sec345" class="toc">9.4 Layouting</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.5"/><A HREF="#sec346" class="toc">9.5 GNED -- Graphical NED Editor</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.5.1"/><A HREF="#sec347" class="toc">9.5.1 Keyboard and mouse bindings</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.6"/><A HREF="#sec348" class="toc">9.6 Enhancing animation</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.6.1"/><A HREF="#sec349" class="toc">9.6.1 Changing display strings at runtime</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.6.2"/><A HREF="#sec350" class="toc">9.6.2 Bubbles</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_10"/><A HREF="#sec351" class="toc">10 Analyzing Simulation Results</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.1"/><A HREF="#sec352" class="toc">10.1 Output vectors</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.1.1"/><A HREF="#sec353" class="toc">10.1.1 Plotting output vectors with Plove</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.1.2"/><A HREF="#sec354" class="toc">10.1.2 Format of output vector files</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.1.3"/><A HREF="#sec355" class="toc">10.1.3 Working without Plove</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.2"/><A HREF="#sec356" class="toc">10.2 Scalar statistics</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.2.1"/><A HREF="#sec357" class="toc">10.2.1 Format of output scalar files</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.2.2"/><A HREF="#sec358" class="toc">10.2.2 The Scalars tool</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.3"/><A HREF="#sec359" class="toc">10.3 Analysis and visualization tools</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.3.1"/><A HREF="#sec360" class="toc">10.3.1 Grace</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.3.2"/><A HREF="#sec361" class="toc">10.3.2 ROOT</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.3.3"/><A HREF="#sec362" class="toc">10.3.3 Gnuplot</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_11"/><A HREF="#sec363" class="toc">11 Documenting NED and Messages</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.1"/><A HREF="#sec364" class="toc">11.1 Overview</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2"/><A HREF="#sec365" class="toc">11.2 Authoring the documentation</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.1"/><A HREF="#sec366" class="toc">11.2.1 Documentation comments</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.2"/><A HREF="#sec367" class="toc">11.2.2 Text layout and formatting</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.3"/><A HREF="#sec368" class="toc">11.2.3 Special tags</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.4"/><A HREF="#sec369" class="toc">11.2.4 Additional text formatting using HTML</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.5"/><A HREF="#sec370" class="toc">11.2.5 Escaping HTML tags</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.6"/><A HREF="#sec371" class="toc">11.2.6 Where to put comments</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.7"/><A HREF="#sec372" class="toc">11.2.7 Customizing the title page</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.8"/><A HREF="#sec373" class="toc">11.2.8 Adding extra pages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.9"/><A HREF="#sec374" class="toc">11.2.9 Incorporating externally created pages</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.3"/><A HREF="#sec375" class="toc">11.3 Invoking opp_neddoc</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.3.1"/><A HREF="#sec376" class="toc">11.3.1 Multiple projects</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.4"/><A HREF="#sec377" class="toc">11.4 How does opp_neddoc work?</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_12"/><A HREF="#sec378" class="toc">12 Parallel Distributed Simulation</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.1"/><A HREF="#sec379" class="toc">12.1 Introduction to Parallel Discrete Event Simulation</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.2"/><A HREF="#sec380" class="toc">12.2 Assessing available parallelism in a simulation model</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.3"/><A HREF="#sec381" class="toc">12.3 Parallel distributed simulation support in OMNeT++</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.3.1"/><A HREF="#sec382" class="toc">12.3.1 Overview</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.3.2"/><A HREF="#sec383" class="toc">12.3.2 Parallel Simulation Example</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.3.3"/><A HREF="#sec384" class="toc">12.3.3 Placeholder modules, proxy gates</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.3.4"/><A HREF="#sec385" class="toc">12.3.4 Configuration</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.3.5"/><A HREF="#sec386" class="toc">12.3.5 Design of PDES Support in OMNeT++</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_13"/><A HREF="#sec387" class="toc">13 Customization and Embedding</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.1"/><A HREF="#sec388" class="toc">13.1 Architecture</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.2"/><A HREF="#sec389" class="toc">13.2 Embedding OMNeT++</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.3"/><A HREF="#sec390" class="toc">13.3 Sim: the simulation kernel and class library</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.3.1"/><A HREF="#sec391" class="toc">13.3.1 The global simulation object</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.3.2"/><A HREF="#sec392" class="toc">13.3.2 The coroutine package</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.4"/><A HREF="#sec393" class="toc">13.4 The Model Component Library</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.5"/><A HREF="#sec394" class="toc">13.5 Envir, Tkenv and Cmdenv</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.5.1"/><A HREF="#sec395" class="toc">13.5.1 The main() function</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.5.2"/><A HREF="#sec396" class="toc">13.5.2 The cEnvir interface</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.5.3"/><A HREF="#sec397" class="toc">13.5.3 Customizing Envir</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.5.4"/><A HREF="#sec398" class="toc">13.5.4 Implementation of the user interface: simulation applications</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_14"/><A HREF="#sec399" class="toc">14 NED Language Grammar</A></B></FONT><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_15"/><A HREF="#sec400" class="toc">15 References</A></B></FONT><BR>
</p> 
<hr><b>Document History</b>

<p>
<table border>
<TR> <TD align=left>

<p><b>Date</b> </TD> <TD align=left> <b>Author</b> </TD> <TD align=left> <b>Change</b></TD></TR>
<TR> <TD align=left> 2005/10 </TD> <TD align=left> AV </TD> <TD align=left> updated for the OMNeT++ 3.2 release</TD></TR>
<TR> <TD align=left> 2005/03 </TD> <TD align=left> AV </TD> <TD align=left> updated for the OMNeT++ 3.1 release</TD></TR>
<TR> <TD align=left> 2004/12 </TD> <TD align=left> AV </TD> <TD align=left> updated for the OMNeT++ 3.0 release</TD></TR>
<TR> <TD align=left> 2003/06 </TD> <TD align=left> AV </TD> <TD align=left> Mentioned Grace and ROOT in section "Visualizing...".
               Added section "Using STL in message classes".
               </TD></TR>
<TR> <TD align=left> 2003/06 </TD> <TD align=left> AV </TD> <TD align=left> OMNeT++ 2.3 released</TD></TR>
<TR> <TD align=left> 2003/04-06 </TD> <TD align=left> AV </TD> <TD align=left> "Design of OMNeT++" chapter revised, extended, and renamed to
               "Customization and Embedding".
               Added "Interpreting Cmdenv output" section to the
               "Running the Simulation" chapter. Added section about Akaroa
               in "Running the Simulation" chapter. Expanded section about
               writing shell scripts to control the simulation.
               Added background info about RNGs and warning about old RNG
               in "Class Library" chapter;
               revised/extended "Deriving new classes" section in same chapter.
               Bibliography converted to Bibtex, expanded and cleaned up;
               citations added to text.
               "Parallel Simulation" chapter: contents removed until new PDES
               implementation gets released.
               Revised and reorganized NED chapter. Section about message
               sending/receiving and other simple module related functions
               moved to chapter "Simple Modules"; <a href="../api/classcMessage.html">cMessage</a> treatment from
               "Simulation Library" merged with message subclassing chapter
               into new chapter "Messages". Deprecated <a href="../api/classcPacket.html">cPacket</a>.
               Removed sections "Simulation techniques" and
               "Coding conventions", and their useful fragments were incorporated
               elsewhere. Added/created sections about message transmission
               modeling, and using global variables. Added sections explaining
               how to implement broadcasts and retransmissions. Revised section
               about dynamic module creation. Deprecated putaside-queue,
               receiveNew(), receiveOn().
               Added section "Object ownership management"; removed section
               on "Using shared objects". </TD></TR>
<TR> <TD align=left> 2003/03 </TD> <TD align=left> AV </TD> <TD align=left> OMNeT++ 2.3b2 released</TD></TR>
<TR> <TD align=left> 2003/02 </TD> <TD align=left> AV </TD> <TD align=left> OMNeT++ 2.3b1 released</TD></TR>
<TR> <TD align=left> 2003/01 </TD> <TD align=left> AV </TD> <TD align=left> Added chapter about message subclassing; revised chapter about
               running the simulation and incorporated new Cmdenv options; added new
               distributions and clarified many details in NED expr. handling section</TD></TR>
<TR> <TD align=left> Summer 2002 </TD> <TD align=left> Ulrich Kaage </TD> <TD align=left> Converted from Word to LaTeX</TD></TR>
<TR> <TD align=left> 2002/03/18 </TD> <TD align=left> AV </TD> <TD align=left> Documented new ini file options about Envir plugins</TD></TR>
<TR> <TD align=left> 2002/01/24 </TD> <TD align=left> AV </TD> <TD align=left> Refinements on the Parsec chapter</TD></TR>
<TR> <TD align=left> 2001/10/23 </TD> <TD align=left> AV </TD> <TD align=left> Updated to reflect changes since 2.1 release (see include/ChangeLog)</TD></TR>
<TR> <TD align=left> </table>

<p>

<p>
</BODY>
</HTML>
<hr><hr><H1><A NAME="sec100"/>1 Introduction</H1>
<a name="cha:introduction"></a>

<p>
<H2><A NAME="sec101"/>1.1 What is OMNeT++?</H2>

<p>OMNeT++ is an object-oriented modular discrete event network simulator.
The simulator can be used for:

<p><ul>
  <li>traffic modeling of telecommunication networks
  <li>protocol modeling
  <li>modeling queueing networks
  <li>modeling multiprocessors and other distributed hardware systems
  <li>validating hardware architectures
  <li>evaluating performance aspects of complex software systems
  <li>... modeling any other system where the discrete event approach is
    suitable.
</ul>

<p>
An OMNeT++ model consists of hierarchically nested modules. The
depth of module nesting is not limited, which allows the user
to reflect the logical structure of the actual system in the
model structure. Modules communicate through message passing. Messages
can contain arbitrarily complex data structures. Modules can
send messages either directly to their destination or along a
predefined path, through gates and connections.

<p>
Modules can have their own parameters. Parameters can be used to customize
module behaviour and to parameterize the model's topology.

<p>Modules at the lowest level of the module hierarchy encapsulate
behaviour. These modules are termed simple modules, and they are
programmed in C++ using the simulation library.

<p>OMNeT++ simulations can feature varying user interfaces for
different purposes: debugging, demonstration and batch execution.
Advanced user interfaces make the inside of the model visible
to the user, allow control over simulation execution
and to intervene by changing variables/objects inside the model.
This is very useful in the development/debugging phase
of the simulation project. User interfaces also facilitate demonstration
of how a model works.

<p>The simulator as well as user interfaces and tools are portable:
they are known to work on Windows and on several Unix flavours,
using various C++ compilers.

<p>OMNeT++ also supports parallel distributed simulation. OMNeT++ can
use several mechanisms for communication between partitions of
a parallel distributed simulation, for example MPI or named pipes.
The parallel simulation algorithm can easily be extended or new
ones plugged in. Models do not need any special instrumentation
to be run in parallel -- it is just a matter of configuration.
OMNeT++ can even be used for classroom presentation of parallel
simulation algorithms, because simulations can be run in parallel
even under the GUI which provides detailed feedback on what is going on.

<p>OMNEST is the commercially supported version of OMNeT++.
OMNeT++ is only free for academic and non-profit use --
for commercial purposes one needs to obtain OMNEST licenses
from Omnest Global, Inc.

<p>

<H2><A NAME="sec102"/>1.2 Organization of this manual</H2>

<p>The manual is organized the following way:

<p><ul>
  <li>The chapters <a href="#sec100">[1]</a> and <a href="#sec104">[2]</a>
    contain introductory material
  <li>The second group of chapters,
    <a href="#sec116">[3]</a>,
    <a href="#sec155">[4]</a> and
    <a href="#sec223">[6]</a>
    are the programming guide. They present the NED language<!--ned!language-->,
    the simulation concepts and their implementation in OMNeT++, explain
    how to write simple<!--module!simple--> modules and describe the class library.
  <li>The chapters
    <a href="#sec331">[9]</a> and
    <a href="#sec363">[11]</a>
    elaborate the topic further, by explaining how one can customize
    the network graphics and how to write NED source code comments
    from which documentation can be generated.
  <li>The following chapters,
    <a href="#sec277">[7]</a>,
    <a href="#sec288">[8]</a> and
    <a href="#sec351">[10]</a> deal with practical issues
    like building and running simulations and analyzing results, and
    present the tools OMNeT++ provides to support these tasks.
  <li>Chapter <a href="#sec378">[12]</a> is devoted to the support
    of distributed execution.
  <li>Finally, Chapter <a href="#sec387">[13]</a> explains the
    architecture and the internals of OMNeT++. This chapter will be
    useful to those who want to extend the capabilities of the
    simulator or want to embed it into a larger application.
  <li>Appendix <a href="#sec399">[14]</a> provides a reference
    of the NED language<!--ned!language-->.
</ul>

<p>

<p>


<p><H2><A NAME="sec103"/>1.3 Credits</H2>

<p>OMNeT++ has been developed by Andr&aacute;s Varga (andras@omnetpp.org,
andras.varga@omnest.com).

<p>In the early stage of the project, several people have contributed
to OMNeT++. Although most contributed code is no longer part of
the OMNeT++, nevertheless I'd like to acknowledge the work of the
following people. First of all, I'd like thank Dr Gy&ouml;rgy Pongor
(pongor@hit.bme.hu), my advisor at the Technical University of Budapest
who initiated the OMNeT++ as a student project.

<p>My fellow student &Aacute;kos Kun started to program the first NED parser
in 1992-93, but it was abandoned after a few months.
The first version of nedc was finally developed in summer 1995,
by three exchange students from TU Delft: Jan Heijmans, Alex Paalvast
and Robert van der Leij. nedc was first called JAR after their initials
until it got renamed to nedc. nedc was further developed and refactored
several times until it finally retired and got replaced by nedtool in OMNeT++ 3.0.
The second group of Delft exchange students (Maurits Andr&eacute;,
George van Montfort, Gerard van de Weerd) arrived in fall 1995.
They performed some testing of the simulation library, and
wrote some example simulations, for example the original version of Token Ring,
and simulation of the NIM game which survived until OMNeT++ 3.0.
These student exchanges were organized by Dr. Leon Rothkranz
at TU Delft, and Gy&ouml;rgy Pongor at TU Budapest.

<p>The diploma thesis of Zolt&aacute;n Vass (spring 1996) was to prepare
OMNeT++ for parallel execution over PVM to OMNeT++. This code has been
replaced with the new Parallel Simulation Architecture in OMNeT++ 3.0.
G&aacute;bor Lencse (lencse@hit.bme.hu) was also interested in parallel
simulation, namely a method called Statistical Synchronization (SSM).
He implemented the FDDI model (practically unchanged until now), and added
some extensions into NED for SSM. These extensions have been removed
since then (OMNeT++ 3.0 does parallel execution on different principles).

<p>The <i>P<sup>2</sup></i> algorithm and the original implementation of the k-split algorithm
was programmed in fall 1996 by Babak Fakhamzadeh from TU Delft.
k-split was later reimplemented by Andr&aacute;s.

<p>Several bugfixes and valuable suggestions for improvements came
from the user community of OMNeT++. It would be impossible to
mention everyone here, and the list is constantly growing --
instead, the README and ChangeLog files contain acknowledgements.

<p>Between summer 2001 and fall 2004, the OMNeT++ CVS was hosted
at the University of Karlsruhe. Credit for setting
up and maintaining the CVS server goes to Ulrich Kaage.
Ulrich can also be credited with converting the User Manual from
Microsoft Word format to LaTeX, which was a huge undertaking
and great help.

<p>
</BODY>
</HTML>
<hr><hr><H1><A NAME="sec104"/>2 Overview</H1>
<a name="cha:overview"></a>

<p>
<H2><A NAME="sec105"/>2.1 Modeling concepts</H2>

<p>OMNeT++ provides efficient tools for the user to describe the
structure of the actual system. Some of the main features are:
<ul>
<li>hierarchically nested modules
<li>modules are instances of module types
<li>modules communicate with messages through channels
<li>flexible module parameters
<li>topology description language
</ul>

<p><H3><A NAME="sec106"/>2.1.1 Hierarchical modules</H3>

<p>
An OMNeT++ model consists of hierarchically nested
modules<!--module!hierarchy-->, which communicate by passing
messages to each another.
OMNeT++ models are often referred to as <i>networks</i>. The top
level module is the <i>system module</i>.  The system module
contains <i>submodules</i>, which can also contain submodules
themselves (Fig. <a href="#fig:ch-overview:modules">below</a>). The depth of module
nesting is not limited; this allows the user to reflect the logical
structure of the actual system in the model structure.

<p>Model structure is described in OMNeT++'s NED language.

<p>
<div align=center>
<img src="usmanFig2.gif">
<center><i>Figure: Simple and compound modules</i></center>
<a name="fig:ch-overview:modules"></a>
</div>

<p>

<p>Modules that contain submodules are termed <i>compound
  modules</i><!--module!compound-->, as opposed <i>simple
  modules</i><!--module!simple--> which are at the lowest level of the
module hierarchy. Simple modules contain the algorithms in the model.
The user implements the simple modules in C++, using the OMNeT++
simulation class library.

<p>
<H3><A NAME="sec107"/>2.1.2 Module types</H3>
<!--module!types-->

<p>Both simple and compound modules are instances of <i>module
  types</i>. While describing the model, the user defines module types;
instances of these module types serve as components for more complex
module types. Finally, the user creates the system module as an
instance of a previously defined module type; all modules of the
network are instantiated as submodules and sub-submodules of the
system module.

<p>When a module type is used as a building block, there is no
distinction whether it is a simple or a compound module. This allows
the user to split a simple module into several
simple modules embedded into a compound<!--module!compound--> module,
or vica versa, aggregate the functionality of a compound module into a
single simple module, without affecting existing users of the module
type.

<p>Module types can be stored in files separately from the place
of their actual usage. This means that the user can group existing
module types and create <i>component libraries</i><!--module!libraries-->. This feature
will be discussed later, in Chapter <a href="#sec288">[8]</a>.

<p>

<p><H3><A NAME="sec108"/>2.1.3 Messages, gates, links</H3>

<p>Modules communicate by exchanging
<i>messages</i><!--message!exchanging-->. In an actual simulation,
messages can represent frames or packets in a computer network, jobs
or customers in a queuing network or other types of mobile entities.
Messages can contain arbitrarily complex data structures. Simple
modules can send messages either directly to their destination or
along a predefined path, through gates and connections.

<p>
The ``local simulation time'' of a module advances when the module
receives a message. The message can arrive from another module
or from the same module (<i>self-messages</i> are used to implement
timers).

<p>
<i>Gates</i><!--gate--> are the input and output interfaces of
modules; messages are sent out through output gates and arrive through
input gates.

<p>Each <i>connection</i><!--connection--> (also called
<i>link</i><!--link-->) is created within a single level of the
module hierarchy: within a compound module, one can connect the
corresponding gates of two submodules, or a gate of one submodule and
a gate of the compound module (Fig.
<a href="#fig:ch-overview:connections">below</a>).

<p>
<div align=center>
<img src="usmanFig3.gif">
<center><i>Figure: Connections</i></center>
<a name="fig:ch-overview:connections"></a>
</div>

<p>
Due to the hierarchical structure of the model, messages typically
travel through a series of connections, to start and arrive in simple
modules. Such series of connections that go from simple module to
simple module are called <i>routes</i>.  Compound modules act as
`cardboard boxes' in the model, transparently relaying messages
between their inside and the outside world.

<p>
<H3><A NAME="sec109"/>2.1.4 Modeling of packet transmissions</H3>

<p>Connections can be assigned three parameters, which facilitate
the modeling of communication networks, but can be useful in
other models too: <i>propagation delay</i>, <i>bit error rate</i>
and <i>data rate</i>, all three being optional. One can specify
link parameters individually for each connection, or define link types
and use them throughout the whole model.

<p>Propagation delay is the amount of time the arrival of
the message is delayed by when it travels through the channel.

<p>Bit error rate speficifies the probability that a bit is incorrectly
transmitted, and allows for simple noisy channel modelling.

<p>Data rate is specified in bits/second, and it is used for calculating
transmission time of a packet.

<p>When data rates are in use, the sending of the message in the model
corresponds to the transmission of the first bit, and
the arrival of the message corresponds to the reception
of the last bit. This model is not always applicable,
for example protocols like Token Ring and FDDI do not wait
for the frame to arrive in its entirety, but rather start repeating
its first bits soon after they arrive -- in other words,
frames ``flow through'' the stations, being delayed only a few bits.
If you want to model such networks, the data rate modeling feature
of OMNeT++ cannot be used.

<p>

<p><H3><A NAME="sec110"/>2.1.5 Parameters</H3>
<!--module!parameters-->
<!--parameters|seemodule parameters-->

<p>Modules can have parameters. Parameters can be assigned either
in the NED files or the configuration file omnetpp.ini.

<p>Parameters may be used to customize simple module behaviour,
and for parameterizing the model topology.

<p>Parameters can take string, numeric or boolean values, or can
contain XML data trees. Numeric values include expressions using
other parameters and calling C functions, random variables from
different distributions, and values input interactively by the user.

<p>Numeric-valued parameters can be used to construct topologies in a
flexible way. Within a compound module, parameters can define the
number of submodules, number of gates, and the way the internal
connections are made.

<p>
<H3><A NAME="sec111"/>2.1.6 Topology description method</H3>
<!--topology!description-->
The user defines the structure of the model in NED language descriptions
(Network Description).The NED language will be discussed in detail
in Chapter <a href="#sec116">[3]</a>.

<p>
<H2><A NAME="sec112"/>2.2 Programming the algorithms</H2>

<p>The simple<!--module!simple--> modules of a model contain algorithms
as C++ functions.
The full flexibility and power of the programming language can
be used, supported by the OMNeT++ simulation class library.
The simulation programmer can choose between event-driven and process-style
description, and can freely use object-oriented concepts
(inheritance, polymorphism etc) and design patterns to extend the
functionality of the simulator.

<p>Simulation objects (messages, modules, queues etc.) are represented
by C++ classes. They have been designed to work together efficiently,
creating a powerful simulation programming framework.
The following classes are part of the simulation class library:

<p><ul>
  <li>modules, gates, connections etc.
  <li>parameters
  <li>messages
  <li>container classes (e.g. queue, array)
  <li>data collection classes
  <li>statistic and distribution estimation classes (histograms, <i>P<sup>2</sup></i>
  algorithm for calculating quantiles etc.)
  <li>transient detection and result accuracy detection classes
</ul>

<p>The classes are also specially instrumented, allowing one
to traverse objects of a running simulation and display information
about them such as name, class name, state variables or contents.
This feature has made it possible to create a simulation GUI where
all internals of the simulation are visible.

<p>


<p><H2><A NAME="sec113"/>2.3 Using OMNeT++</H2>

<p>
<H3><A NAME="sec114"/>2.3.1 Building and running simulations</H3>
<!--simulation!building-->
<!--simulation!running-->

<p>This section provides insight into working with OMNeT++ in practice:
Issues such as model files, compiling and running simulations are
discussed.

<p>An OMNeT++ model consists of the following parts:
<ul>
  <li>NED language topology description(s)<!--ned!files--> (<tt>.ned</tt> files)
    which describe the module structure with parameters, gates etc.
    NED files can be written using any text editor or the
    GNED graphical editor<!--ned!graphical editor-->.
  <li>Message definitions (<tt>.msg</tt> files). You can define various message
    types and add data fields to them. OMNeT++ will translate message definitions
    into full-fledged C++ classes.
  <li>Simple modules sources. They are C++ files, with <tt>.h</tt>/<tt>.cc</tt> suffix.
</ul>

<p>The simulation system provides the following components:
<ul>
  <li>Simulation kernel<!--simulation!kernel-->. This contains the
    code that manages the simulation and the simulation class library.
    It is written in C++, compiled and put together to form a library
    (a file with .a or .lib extension)
  <li>User interfaces<!--simulation!user interface-->.
    <!--user interface--> OMNeT++ user interfaces
    are used in simulation execution, to facilitate debugging,
    demonstration, or batch execution of simulations. There are
    several user interfaces, written in C++, compiled and put together
    into libraries (<tt>.a</tt> or <tt>.lib</tt> files).
</ul>

<p>
Simulation programs are built from the above components. First,
<tt>.msg</tt> files are translated into C++ code using the <tt>opp_msgc</tt>.
program. Then all C++ sources are compiled, and linked with the simulation
kernel and a user interface library to form a simulation executable.
NED files<!--ned!files--> can either be also translated into C++
(using <tt>nedtool</tt>) and linked in, or loaded dynamically in their original
text forms when the simulation program starts.

<p>

<p><p class="subheading">Running the simulation and analyzing the results</p>

<p>The simulation executable is a standalone program,
thus it can be run on other machines without OMNeT++ or the model files
being present. When the program is started, it reads a configuration
file<!--simulation!configuration file--> (usually called
<tt>omnetpp.ini</tt><!--omnetpp.ini-->). This file contains settings that
control how the simulation is executed, values for model parameters, etc.
The configuration file can also prescribe several simulation runs; in
the simplest case, they will be executed by the simulation program one
after another.

<p>The output of the simulation is written into data files: output vector
files<!--output!vector file-->, output scalar files
<!--output!scalar file-->, and possibly the user's own output files.
OMNeT++ provides a GUI tool named Plove to view and plot the contents
of output vector files. It is not expected that someone will
process the result files using OMNeT++ alone: output files are text
files in a format which can be read into math packages like Matlab
or Octave, or imported into spreadsheets like OpenOffice Calc,
Gnumeric or MS Excel (some preprocessing using <tt>sed</tt>, <tt>awk</tt>
or <tt>perl</tt> might be required, this will be discussed later).
All these external programs provide rich functionality for statistical
analysis and visualization, and it is outside the scope of OMNeT++ to
duplicate their efforts. This manual briefly describes
some data plotting programs and how to use them with OMNeT++.

<p>Output scalar files can be visualized using the Scalars tool.
It can draw bar charts, x-y plots (e.g. throughput vs offered load),
or export data via the clipboard for more detailed analysis into
spreadsheets and other programs.

<p>
<p class="subheading">User interfaces</p>
<!--simulation!user interface-->

<p>The primary purpose of user interfaces is to make the internals
of the model visible to the user, to control simulation execution,
and possibly allow the user to intervene by changing variables/objects
inside the model. This is very important in the development/debugging
phase of the simulation project. Just as important, a hands-on
experience allows the user to get a `feel' of the model's
behaviour. The graphical user interface can also be used to
demonstrate a model's operation.

<p>
The same simulation model can be executed with different user
interfaces, without any change in the model files themselves.
The user would test and debug the simulation with a powerful
graphical user interface, and finally run it with a simple and
fast user interface that supports batch execution.

<p>
<p class="subheading">Component libraries</p>
<!--module!libraries-->

<p>Module types can be stored in files separate from the place
of their actual use. This enables the user to group existing
module types and create component libraries.

<p>
<p class="subheading">Universal standalone simulation programs</p>

<p>
A simulation executable can store several independent models
that use the same set of simple modules. The user can specify
in the configuration file which model is to be run. This
allows one to build one large executable that contains several
simulation models, and distribute it as a standalone simulation
tool. The flexibility of the topology description language also
supports this approach.

<p>
<H3><A NAME="sec115"/>2.3.2 What is in the distribution</H3>

<p>If you installed the source distribution, the omnetpp directory on your system
should contain the following subdirectories. (If you installed a precompiled
distribution, some of the directories may be missing, or there might be
additional directories, e.g. containing software bundled with OMNeT++.)

<p>The simulation system itself:

<p><pre>
  <b>omnetpp/</b>         OMNeT++ root directory
    <b>bin/</b>           OMNeT++ executables (GNED, nedtool, etc.)
    <b>include/</b>       header files for simulation models
    <b>lib/</b>           library files
    <b>bitmaps/</b>       icons that can be used in network graphics
    <b>doc/</b>           manual (PDF), readme, license, etc.
      <b>manual/</b>      manual in HTML
      <b>tictoc-tutorial/</b>  introduction into using OMNeT++
      <b>api/</b>         API reference in HTML
      <b>nedxml-api/</b>  API reference for the NEDXML library
      <b>src/</b>         sources of the documentation
    <b>src/</b>           OMNeT++ sources
      <b>nedc/</b>        nedtool, message compiler
      <b>sim/</b>         simulation kernel
        <b>parsim/</b>    files for distributed execution
        <b>netbuilder/</b>files for dynamically reading NED files
      <b>envir/</b>       common code for user interfaces
      <b>cmdenv/</b>      command-line user interface
      <b>tkenv/</b>       Tcl/Tk-based user interface
      <b>gned/</b>        graphical NED editor
      <b>plove/</b>       output vector analyzer and plotting tool
      <b>scalars</b>      output scalar analyzer and plotting tool
      <b>nedxml/</b>      NEDXML library
      <b>utils/</b>       makefile-creator, documentation tool, etc.
    <b>test/</b>          regression test suite
      <b>core/</b>        regression test suite for the simulation library
      <b>distrib/</b>     regression test suite for built-in distributions
      ...
</pre>

<p>Sample simulations are in the <tt>samples</tt> directory.

<p><pre>
    <b>samples/</b>     directories for sample simulations
      <b>aloha/</b>     models the Aloha protocol
      <b>cqn/</b>       Closed Queueing Network
      ...
</pre>

<p>The <tt>contrib</tt> directory contains material from the OMNeT++ community.

<p><pre>
    <b>contrib/</b>     directory for contributed material
      <b>octave/</b>    Octave scripts for result processing
      <b>emacs/</b>     NED syntax highlight for Emacs
</pre>

<p>You may also find additional directories like <tt>msvc/</tt>, which contain
integration components for Microsoft Visual C++, etc.

<p>
</BODY>
</HTML>
<hr><hr><H1><A NAME="sec116"/>3 The NED Language</H1>
<a name="cha:the-ned-language"></a>

<p>
<H2><A NAME="sec117"/>3.1 NED overview</H2>

<p>The topology<!--topology--> of a model is specified using
the NED language<!--ned!language-->.
The NED language facilitates the modular description of a network.
This means that a network description<!--network!description--> may consist
of a number of component descriptions (channels<!--channel-->,
simple<!--module!simple-->/compound<!--module!compound--> module
types). The channels, simple modules and compound
modules of one network description can be reused in another network
description.

<p>Files containing network descriptions generally have a <tt>.ned</tt>
suffix. NED files can be loaded dynamically into simulation programs,
or translated into C++ by the NED compiler and linked into
the simulation executable.

<p>The EBNF description of the language can be found in Appendix
<a href="#sec399">[14]</a>.

<p>
<H3><A NAME="sec118"/>3.1.1 Components of a NED description</H3>
<!--ned!components-->

<p>A NED description can contain the following components, in arbitrary
number or order:
<ul>
  <li>import directives<!--import directives-->
  <li>channel definitions<!--channel!definitions-->
  <li>simple<!--module!simple--> and compound<!--module!compound--> module definitions
  <li>network definitions<!--network!definitions-->
</ul>

<p>
<H3><A NAME="sec119"/>3.1.2 Reserved words</H3>
<!--ned!keywords-->

<p>The writer of the network description has to take care that no
reserved words are used for names. The reserved words of the
NED language are:

<p><tt>
import channel endchannel simple endsimple module endmodule
error delay datarate const parameters gates submodules connections
gatesizes if for do endfor network endnetwork nocheck
ref ancestor true false like input numeric string bool char xml xmldoc
</tt>

<p>
<H3><A NAME="sec120"/>3.1.3 Identifiers</H3>
<!--ned!identifiers-->

<p>Identifiers are the names of modules, channels, networks,
submodules, parameters, gates, channel attributes and functions.

<p>Identifiers must be composed of letters of the English alphabet (a-z, A-Z),
numbers (0-9) and the underscore ``_''.
Identifiers may only begin with a letter or the underscore.
If you want to begin an identifier with a digit, prefix the name
you'd like to have with an underscore, e.g. <tt>_3Com</tt>.

<p>If you have identifiers that are composed of several words, the convention
is to capitalize the beginning of every word. Also, it is recommended
that you begin the names of modules, channels and networks with
a capital letter, and the names of parameters, gates and submodules
with a lower-case letter. Underscores are rarely used.

<p>
<H3><A NAME="sec121"/>3.1.4 Case sensitivity</H3>
<!--ned!case sensitivity-->

<p>The network description and all identifiers in it are case sensitive.
For example, <tt>TCP</tt> and <tt>Tcp</tt> are two different names.

<p>
<H3><A NAME="sec122"/>3.1.5 Comments</H3>
<!--ned!comments-->

<p>Comments can be placed anywhere in the NED file, with the usual C++
syntax: comments begin with a double slash `//', and last until
the end of the line. Comments are ignored by the NED compiler.

<p>NED comments can be used for documentation generation,
much like JavaDoc or Doxygen. This feature is described in
Chapter <a href="#sec363">[11]</a>.

<p>

<p><H2><A NAME="sec123"/>3.2 The import directive</H2>

<p><!--ned!import files-->
<!--ned!keywords!include-->

<p>The <tt>import</tt> directive
is used to import declarations from another network description file.
After importing a network description, one can use the components
(channels<!--channel-->, simple/compound module types) defined in it.

<p>When a file is imported, only the declaration information is used.
Also, importing a <tt>.ned</tt> file does not cause that file to be compiled
with the NED compiler when the parent file is NED compiled, i.e.,
one must compile and link all network description files --
not only the top-level ones.

<p>You can specify the name of the files with or without the
<tt>.ned</tt> extension. You can also include a path in the
filenames<!--ned!include files-->, or better, use the NED compiler's
<tt>-I &lt;path&gt;</tt> command-line option to name the directories where the
imported files reside.

<p>Example:

<p><pre>
<b>import</b> "ethernet";   // imports ethernet.ned
</pre>

<p>

<p>
<H2><A NAME="sec124"/>3.3 Channel definitions</H2>

<p><!--channel-->
<!--channel!definition-->
<!--channel!delay-->
<!--channel!error-->
<!--channel!datarate-->

<p>A channel definition specifies a connection type of given characteristics.
The channel name can be used later in the NED description to
create connections with these parameters.

<p>The syntax:

<p><pre>
<b>channel</b> ChannelName
    //...
<b>endchannel</b>
</pre>

<p>Three attributes can be assigned values in the body of the channel declaration,
all of them are optional: <tt>delay</tt>, <tt>error</tt> and <tt>datarate</tt>.
<tt>delay</tt> is the propagation delay in (simulated) seconds;
<tt>error</tt> is the bit error rate that speficifies the probability
that a bit is incorrectly transmitted; and <tt>datarate</tt>
is the channel bandwidth in bits/second, used for calculating
transmission time of a packet. The attributes can appear
in any order.

<p>The values should be constants.

<p>Example:

<p><pre>
<b>channel</b> LeasedLine
    <b>delay</b> 0.0018  // sec
    <b>error</b> 1e-8
    <b>datarate</b> 128000  // bit/sec
<b>endchannel</b>
</pre>

<p>

<p><H2><A NAME="sec125"/>3.4 Simple module definitions</H2>

<p>
Simple modules are the basic building blocks for other (compound)
modules. Simple module types are identified by names.
By convention, module names begin with upper-case letters.

<p>A simple<!--module!simple!definition--> module is defined by
declaring its parameters<!--module!parameters--> and
gates<!--gate-->.

<p>Simple modules are declared with the following syntax:

<p><pre>
<b>simple</b> SimpleModuleName
    <b>parameters</b>:
        //...
    <b>gates</b>:
        //...
<b>endsimple</b>
</pre>

<p>

<p><H3><A NAME="sec126"/>3.4.1 Simple module parameters</H3>
<a name="sec:ch-ned-lang:simple-module-param"></a>
<!--module!parameters-->
<!--ned!keywords!numeric-->
<!--ned!keywords!const-->
<!--ned!keywords!bool-->
<!--ned!keywords!string-->
<!--ned!keywords!xml-->

<p>
Parameters are variables that belong to a module. Simple module
parameters can be queried and used by simple module algorithms.
For example, a module called <tt>TrafficGen</tt> may have a parameter
called <tt>numOfMessages</tt> that determines how many messages it
should generate.

<p>Parameters are identified by names.
By convention, parameter names begin with lower-case letters.

<p>Parameters are declared by listing their names in the
<tt>parameters:</tt> section of a module description.
The parameter type can optionally be specified as <tt>numeric</tt>,
<tt>numeric const</tt> (or simply <tt>const</tt>), <tt>bool</tt>, <tt>string</tt>,
or <tt>xml</tt>. If the parameter type is omitted, <tt>numeric</tt> is assumed.

<p>Example:

<p><pre>
<b>simple</b> TrafficGen
    <b>parameters</b>:
        interarrivalTime,
        numOfMessages : <b>const</b>,
        address : <b>string</b>;
    <b>gates</b>: //...
<b>endsimple</b>
</pre>

<p>Parameters are assigned from NED (when the module is used as a building block
of a larger compound module) or from the config file <tt>omnetpp.ini</tt>.
<tt>omnetpp.ini</tt> is described in Chapter <a href="#sec288">[8]</a>.

<p>
<p class="subheading">Random parameters and const</p>
<a name="sec:ch-ned-lang:const"></a>
<!--const-->
<!--module!parameters!const-->

<p>Numeric parameters can be set to return random numbers, uniformly
distributed or from various distributions. For example, setting a
parameter to <tt>truncnormal(2,0.8)</tt> would return a new random number
from the truncated normal distribution with mean 2.0 and standard deviation 0.8
every time the parameter is read from the simple module (from C++ code).
For example, this is useful for specifying interarrival times for generated
packets or jobs.

<p>You may want the initial parameter value to be chosen randomly, but not
to change it afterwards. This can be achieved with declaring the parameter
to be <tt>const</tt>. <tt>const</tt> parameters will be evaluated only once
at the beginning of the simulation then set to a constant value.

<p>It is recommended to mark every parameter with <tt>const</tt> unless
you really want to make use of the random numbers feature.

<p>
<p class="subheading">XML parameters</p>
<!--xml-->
<!--module!parameters!xml-->

<p>Sometimes modules need more complex input than simple module parameters
can describe. Then you'd put these parameters into an external config file,
and let the modules read and process the file. You'd pass the file name
to the modules in a string parameter.

<p>These days, XML is increasingly becoming a standard format for configuration
files as well, so you might as well describe your configuration in XML.
From the 3.0 version, OMNeT++ contains built-in support for XML config files.

<p>OMNeT++ wraps the XML parser (LibXML, Expat, etc.), reads and DTD-validates
the file (if the XML document contains a DOCTYPE), caches the file
(so that if you refer to it from several modules, it'll still be loaded
only once), lets you pick parts of the document via an XPath-subset notation,
and presents the contents to you in a DOM-like object tree.

<p>This machinery can be accessed via the NED parameter type <tt>xml</tt>, and the
<tt>xmldoc()</tt> operator. You can point <tt>xml</tt>-type module parameters
to a specific XML file (or to an element inside an XML file) via the
<tt>xmldoc()</tt> operator. You can assign <tt>xml</tt> parameters both from NED
and from <tt>omnetpp.ini</tt>.

<p>
<H3><A NAME="sec127"/>3.4.2 Simple module gates</H3>
<a name="sec:ch-ned-lang:simple-module-gates"></a>

<p><!--gate-->
<!--module!simple!gates-->

<p>Gates are the connection points of modules. The starting and
ending points of the connections between modules are gates. OMNeT++
supports simplex (one-directional) connections, so there are
input and output gates. Messages are sent through
output gates and received through input gates.

<p>Gates are identified by their names.
By convention, gate names begin with lower-case letters.

<p>Gate vectors are supported: a gate vector<!--gate!vector-->
contains a number of single gates.

<p>Gates are declared by listing their names in the
<tt>gates:</tt> section of a module description. An
empty bracket pair [] denotes a gate vector<!--gate!vector-->.
Elements of the vector are numbered from zero.

<p>Examples:

<p><pre>
<b>simple</b> NetworkInterface
    <b>parameters</b>: //...
    <b>gates</b>:
        <b>in</b>:  fromPort, fromHigherLayer;
        <b>out</b>: toPort, toHigherLayer;
<b>endsimple</b>

<b>simple</b> RoutingUnit
    <b>parameters</b>: //...
    <b>gates</b>:
        <b>in</b>:  output[];
        <b>out</b>: input[];
<b>endsimple</b>
</pre>

<p>The sizes of gate vectors are given later, when the module is used as
a building block of a compound module type. Thus, every instance of
the module can have gate vectors of different sizes.

<p>

<p>

<p><H2><A NAME="sec128"/>3.5 Compound module definitions</H2>

<p>
Compound modules are modules composed of one or more submodules.
Any module type (simple or compound module) can be used as a submodule.
Like simple modules, compound modules can also have gates and parameters,
and they can be used wherever simple modules can be used.

<p>It is useful to think about compound modules as ``cardboard boxes''
that help you organize your simulation model and bring structure into
it. No active behaviour is associated with compound modules -- they
are simply for grouping modules into larger components that can
can be used either as a model (see section <a href="#sec136">[3.6]</a>)
or as a building block for other compound modules.

<p>By convention, module type names (and so compound module type names, too)
begin with upper-case letters.

<p>Submodules may use parameters of the compound module.
They may be connected with each other and/or with
the compound module itself.

<p>A compound module definition<!--module!compound!definition--> looks
similar to a simple<!--module!simple--> module definition:
it has <tt>gates</tt> and <tt>parameters</tt> sections.
There are two additional sections, <tt>submodules</tt> and
<tt>connections</tt>.

<p>The syntax for compound modules is the following:

<p><pre>
<b>module</b> CompoundModule
    <b>parameters</b>:
        //...
    <b>gates</b>:
        //...
    <b>submodules</b>:
        //...
    <b>connections</b>:
        //...
<b>endmodule</b>
</pre>

<p>All sections (<tt>parameters</tt>, <tt>gates</tt>, <tt>submodules</tt>,
<tt>connections</tt>) are optional.

<p>

<p><H3><A NAME="sec129"/>3.5.1 Compound module parameters and gates</H3>

<p>Parameters<!--module!compound!parameters--> and gates <!--gate-->
for compound modules are declared and work in the same way
as with simple modules, described in sections
<a href="#sec126">[3.4.1]</a>
and <a href="#sec127">[3.4.2]</a>.

<p>Typically, compound module parameters are passed to submodules and
used for initializing their parameters.

<p>Parameters can also be used in defining the internal structure of
the compound module: the number of submodules and sizes of gate vectors
can be defined with the help of parameters, and parameters can
also be used in defining the connections inside the compound module.
As a practical example, you can create a <tt>Router</tt> compound module
with a variable number of ports, specified in a <tt>numOfPorts</tt> parameter.

<p>Parameters affecting the internal structure should always be declared
<tt>const</tt>, so that accessing them always yields the same value.
Otherwise, if the parameter was assigned a random value, one could
get a different value each time the parameter is accessed during building
the internals of the compound module, which is surely not what was meant.

<p>Example:

<p><pre>
<b>module</b> Router
    <b>parameters</b>:
        packetsPerSecond : <b>numeric</b>,
        bufferSize : <b>numeric</b>,
        numOfPorts : <b>const</b>;
    <b>gates</b>:
        <b>in</b>: inputPort[];
        <b>out</b>: outputPort[];
    <b>submodules</b>: //...
    <b>connections</b>: //...
<b>endmodule</b>
</pre>

<p>
<H3><A NAME="sec130"/>3.5.2 Submodules</H3>

<p>Submodules<!--module!submodule--> are defined in the
<tt>submodules:</tt> section of a compound
module declaration. Submodules are identified by names.
By convention, submodule names begin with lower-case letters.

<p>Submodules are instances of a module type, either simple
or compound -- there is no distinction. The module type
must be known to the NED compiler, that is, it must have appeared
earlier in the same NED file or have been imported from another
NED file.

<p>It is possible to define vectors of submodules, and the
size of the vector may come from a parameter value.

<p>When defining submodules, you can assign values to their
parameters, and if the corresponding module type has gate vectors,
you have to specify their sizes.

<p>
Example:

<p><pre>
<b>module</b> CompoundModule
    //...
    <b>submodules</b>:
        submodule1: ModuleType1
            <b>parameters</b>:
                //...
            <b>gatesizes</b>:
                //...
        submodule2: ModuleType2
            <b>parameters</b>:
                //...
            <b>gatesizes</b>:
                //...
<b>endmodule</b>
</pre>

<p>
<p class="subheading">Module vectors</p>

<p>
It is possible to create an array<!--module!array--> of
submodules<!--submodule|seemodule--> (a module
vector<!--module!vector-->).  This is done with an expression between
brackets right behind the module type name. The expression can refer
to module parameters. A zero value as module count is also allowed.

<p>Example:

<p><pre>
<b>module</b> CompoundModule
    <b>parameters</b>:
        size: <b>const</b>;
    <b>submodules</b>:
        submod1: Node[3]
            //...
        submod2: Node[size]
            //...
        submod3: Node[2*size+1]
            //...
<b>endmodule</b>
</pre>

<p>

<p><H3><A NAME="sec131"/>3.5.3 Submodule type as parameter</H3>
<a name="sec:ch-ned-lang:like"></a>
<!--module!as parameter-->

<p>Sometimes it is convenient to make the name of a submodule type a parameter,
so that one can easily `plug in' any module there.

<p>For example, assume the purpose of your simulation study is
to compare different routing algorithms. Suppose you programmed
the needed routing algorithms as simple modules: <tt>DistVecRoutingNode</tt>,
<tt>AntNetRouting1Node</tt>, <tt>AntNetRouting2Node</tt>, etc.
You have also created the network topology as a compound module
called <tt>RoutingTestNetwork</tt>, which will serve as a testbed for your routing
algorithms. Currently, <tt>RoutingTestNetwork</tt> has <tt>DistVecRoutingNode</tt>
hardcoded (all submodules are of this type), but you want
to be able to switch to other routing algorithms easily.

<p>NED gives you the possibility to add a string-valued parameter,
say <tt>routingNodeType</tt> to the <tt>RoutingTestNetwork</tt> compound module.
Then you can tell NED that types of the submodules inside <tt>RoutingTestNetwork</tt>
are not of any fixed module type, but contained in the <tt>routingNodeType</tt>
parameter. That is all -- now you are free to assign any of
the <tt>"DistVecRoutingNode"</tt>, <tt>"AntNetRouting1Node"</tt> or
<tt>"AntNetRouting2Node"</tt> string constants to this parameter
(you can do that in NED, in the config file (<tt>omnetpp.ini</tt>),
or even enter it interactively),
and your network will use the routing algorithm you chose.

<p>If you specify a wrong value, say <tt>"FooBarRoutingNode"</tt>
when you have no <tt>FooBarRoutingNode</tt> module implemented,
you'll get a runtime error at the beginning of the simulation:
<i>module type definition not found</i>.

<p>Inside the <tt>RoutingTestNetwork</tt> module you assign parameter values
and connect the gates of the routing modules. To provide some degree
of type safety, NED wants to make sure you didn't misspell
parameter or gate names and you used them correctly.
To be able to do such checks, NED requires some help from you:
you have to name an existing module type (say <tt>RoutingNode</tt>)
and promise NED that all modules you're going you specify
in the <tt>routingNodeType</tt> parameter will have (at least) the same
parameters and gates as the <tt>RoutingNode</tt> module.
  <br><ul><font size=-1>[If you like, the above solution somewhat similar to polymorphism
  in object-oriented languages -- <tt>RoutingNode</tt> is like a
  ``base class'', <tt>DistVecRoutingNode</tt> and <tt>AntNetRouting1Node</tt>
  are like ``derived classes'', and the <tt>routingNodeType</tt> parameter
  is like a ``pointer to a base class'' which may be downcast to specific
  types.]</font></ul>

<p>All the above is achieved via the <tt>like</tt> keyword.
The syntax is the following:

<p><pre>
<b>module</b> RoutingTestNetwork
    <b>parameters</b>:
        routingNodeType: <b>string</b>; // should hold the name
                                  // of an existing module type
    <b>gates</b>: //...
    <b>submodules</b>:
        node1: routingNodeType <b>like</b> RoutingNode;
        node2: routingNodeType <b>like</b> RoutingNode;
        //...
    <b>connections nocheck</b>:
        node1.out0 --&gt; node2.in0;
        //...
<b>endmodule</b>
</pre>

<p>The <tt>RoutingNode</tt> module type does not need to be implemented in
C++, because no instance of it is created; it is merely used
to check the correctness of the NED file.

<p>On the other hand, the actual module types that will be substituted
(e.g. <tt>DistVecRoutingNode</tt>, <tt>AntNetRouting1Node</tt>,etc.)
do not need to be declared in the NED files.

<p>The <tt>like</tt> phrase lets you create families
of modules that serve similar purposes and implement the same interface
(they have the same gates and parameters)
and to use them interchangeably in NED files.

<p>

<p>
<H3><A NAME="sec132"/>3.5.4 Assigning values to submodule parameters</H3>

<p><!--module!submodule!parameters-->

<p>If the module type used as submodule has parameters, you can assign
values to them in the <tt>parameters</tt> section of the submodule
declaration.
As a value you can use a constant (such as <tt>42</tt> or
<tt>"www.foo.org"</tt>), various parameters (most commonly, parameters
of the compound module), or write an arbitrary expression containing
the above.

<p>It is not mandatory to mention and assign all parameters.
Unassigned parameters can get their values at runtime: either from
the configuration file (<tt>omnetpp.ini</tt>), or if the value
isn't there either, the simulator will prompt you to enter it
interactively. Indeed, for flexibility reasons it is often very useful
not to ``hardcode'' parameter values in the NED file,
but to leave them to <tt>omnetpp.ini</tt> where they can be
changed more easily.

<p>
Example:

<p><pre>
<b>module</b> CompoundModule
    <b>parameters</b>:
        param1: numeric,
        param2: numeric,
        useParam1: bool;
    <b>submodules</b>:
        submodule1: Node
            <b>parameters</b>:
                p1 = 10,
                p2 = param1+param2,
                p3 = useParam1==true ? param1 : param2;
        //...
<b>endmodule</b>
</pre>

<p>
The expression syntax <!--ned!expressions--> is very similar to C.
Expressions may contain constants (literals) and parameters of the
compound module being defined. Parameters can be passed by value
or by reference. The latter means that the expression is evaluated
at runtime each time its value is accessed (e.g. from simple module
code), opening up interesting possibilities for the modeler.
You can also refer to parameters of the already defined submodules,
with the syntax <tt>submodule.parametername</tt>
(or <tt>submodule[index].parametername</tt>).

<p>Expressions are described in detail in section <a href="#sec137">[3.7]</a>.

<p>
<p class="subheading">The <tt>input</tt> keyword</p>
<a name="sec:ch-ned-lang:input"></a>

<p>When a parameter does not receive a value inside NED files or in
the configuration file (<tt>omnetpp.ini</tt>), the user will be prompted
to enter its value at the beginning of the simulation.
If you plan to make use of interactive prompting, you can specify
a prompt text and a default value.

<p>The syntax is the following:

<p><pre>
   parameters:
      numCPUs = <b>input</b>(10, "Number of processors?"), // default value, prompt
      processingTime = <b>input</b>(10ms), // prompt text
      cacheSize = input;
</pre>

<p>The third version is actually the same as leaving out the parameter
from the list of assignments, but you can use it to make it explicit
that you do not want to assign a value from the NED file.

<p>
<H3><A NAME="sec133"/>3.5.5 Defining sizes of submodule gate vectors</H3>

<p><!--module!gate sizes-->
<!--gate!vector!size-->

<p>The sizes of gate vectors are defined with the
<tt>gatesizes</tt> keyword.  Gate vector sizes
can be given as constants, parameters or expressions.

<p>An example:

<p><pre>
<b>simple</b> Node
    <b>gates</b>:
        <b>in</b>: inputs[];
        <b>out</b>: outputs[];
<b>endsimple</b>

<b>module</b> CompoundModule
    <b>parameters</b>:
        numPorts: <b>const</b>;
    <b>submodules</b>:
        node1: Node
            <b>gatesizes</b>:
                inputs[2], outputs[2];
        node2: Node
            <b>gatesizes</b>:
                inputs[numPorts], outputs[numPorts];
        //...
<b>endmodule</b>
</pre>

<p>
<tt>gatesizes</tt> is not mandatory.
If you omit <tt>gatesizes</tt> for a gate vector, it will be created with zero size.

<p>One reason for omitting <tt>gatesizes</tt> is that you'll want to use
the <tt>gate++</tt> (``extend gate vector with a new gate'') notation later in the
<tt>connections</tt> section.

<p>

<p><H3><A NAME="sec134"/>3.5.6 Conditional parameters and gatesizes sections</H3>

<p>
Multiple <tt>parameters</tt><!--ned!parameters--> and
<tt>gatesizes</tt><!--ned!gatesizes--> sections can exist in a submodule
definition and each of them can be tagged with
conditions<!--gate!conditional-->.

<p>Example:

<p><pre>
<b>module</b> Chain
    <b>parameters</b>: count: <b>const</b>;
    <b>submodules</b>:
        node : Node [count]
            <b>parameters</b>:
                position = "middle";
            <b>parameters</b> <b>if</b> index==0:
                position = "beginning";
            <b>parameters</b> <b>if</b> index==count-1:
                position = "end";
            <b>gatesizes</b>:
                in[2], out[2];
            <b>gatesizes</b> <b>if</b> index==0 || index==count-1:
                in[1], in[1];
    <b>connections</b>:
        //...
<b>endmodule</b>
</pre>

<p>If the conditions are not disjoint and a parameter value or a
gate size is defined twice, the last definition will take effect,
overwriting the former ones. Thus, values intended as defaults
should appear in the first sections.

<p>

<p><H3><A NAME="sec135"/>3.5.7 Connections</H3>

<p>
The compound module definition specifies how the gates of the compound
module and its immediate sub-modules are connected<!--connection-->.

<p>You can connect two submodules or a submodule with its enclosing
compound module. (For completeness, you can also connect two gates
of the compound module on the inside, but this is rarely needed).
This means that NED does not permit connections that span
multiple levels of hierarchy -- this restriction
enforces compound modules to be self-contained, and thus promotes
reusability. Gate directions must also be observed,
that is, you cannot connect two output gates or two input gates.

<p>Only one-to-one connections are supported, so a particular gate may only
be used occur in one connection. One-to-many and many-to-one
connections can be achieved using simple modules that duplicate
messages or merge message flows. The rationale is that wherever
such fan-in or fan-out occurs in a model, it is usually associated
with some processing anyway that makes it necessary to use
simple modules.

<p>Connections<!--ned!connections--> are specified in the
<tt>connections:</tt> section of a compound
module definition. It lists the connections, separated by semicolons.

<p>Example:

<p><pre>
<b>module</b> CompoundModule
    <b>parameters</b>: //...
    <b>gates</b>: //...
    <b>submodules</b>: //...
    <b>connections</b>:
        node1.output --&gt; node2.input;
        node1.input &lt;-- node2.output;
        //...
<b>endmodule</b>
</pre>

<p>The source gate can be an output gate of a submodule or an input
gate of the compound module, and the destination gate can be
an input gate of a submodule or an output gate of the compound
module. The arrow can point either left-to-right or right-to-left.

<p>The <i>gate++</i> notation allows you to extend a gate vector
with new gates, without having to declare the vector size in advance
with <tt>gatesizes</tt>. This feature is very convenient for connecting
nodes of a network:

<p><pre>
<b>simple</b> Node
    <b>gates</b>:
        <b>in</b>: in[];
        <b>out</b>: out[];
<b>endsimple</b>

<b>module</b> SmallNet
    <b>submodules</b>:
        node: Node[6];
    <b>connections</b>:
        node[0].out++ --&gt; node[1].in++;
        node[0].in++ &lt;-- node[1].out++;

        node[1].out++ --&gt; node[2].in++;
        node[1].in++ &lt;-- node[2].out++;

        node[1].out++ --&gt; node[4].in++;
        node[1].in++ &lt;-- node[4].out++;

        node[3].out++ --&gt; node[4].in++;
        node[3].in++ &lt;-- node[4].out++;

        node[4].out++ --&gt; node[5].in++;
        node[4].in++ &lt;-- node[5].out++;
<b>endmodule</b>
</pre>

<p>
A connection:

<p><ul>
  <li>may have attributes (delay, bit error rate or data rate) or
        use a named channel;
  <li>may occur inside a for-loop (to create multiple connections);
  <li>may be conditional.
</ul>

<p>These connection types are described in the following sections.

<p>
<p class="subheading">Single connections and channels</p>

<p><!--ned!connections-->
<!--connection-->

<p>If you do not specify a channel<!--channel-->, the connection will have
no propagation delay, no transmission delay and no bit errors:

<pre>
    node1.outGate --&gt; node2.inGate;
</pre>
<p>
You can specify a channel by its name<!--channel!name-->:
<pre>
    node1.outGate --&gt; Fiber --&gt; node2.inGate;
</pre>

<p>In this case, the NED sources must contain the definition of
the channel.

<p>One can also specify the channel parameters directly<!--channel!parameters-->:
<pre>
    node1.outGate --&gt; error 1e-9 delay 0.001 --&gt; node2.inGate;
</pre>

<p>Either of the parameters can be omitted and they can be in any
order.

<p>
<p class="subheading">Loop connections</p>

<p>
If submodule or gate vectors are used, it is possible to create
more than one connection with one statement. This is termed a <i>multiple</i>
or <i>loop connection</i><!--connection!loop-->.

<p>A multiple connection is created with the <tt>for</tt>
statement:

<p><pre>
<b>for</b> i=0..4 <b>do</b>
    node1.outGate[i] --&gt; node2[i].inGate
<b>endfor</b>;
</pre>

<p>
The result of the above loop connection can be illustrated as
depicted in Fig. <a href="#fig:ch-ned-lang:loop-connection">below</a>.

<p>
<div align=center>
<img src="usmanFig7.gif">
<center><i>Figure: Loop connection</i></center>
<a name="fig:ch-ned-lang:loop-connection"></a>
</div>

<p>

<p>One can place several connections in the body of the
<tt>for</tt> statement, separated by semicolons.

<p>One can create nested loops<!--ned!nested for statements-->
by specifying more than one indices in the <tt>for</tt> statement,
with the first variable forming the outermost loop.

<p><pre>
<b>for</b> i=0..4, j=0..4 <b>do</b>
    //...
<b>endfor</b>;
</pre>

<p>One can also use an index in the lower and upper bound expressions
of the subsequent indices:

<p><pre>
<b>for</b> i=0..3, j=i+1..4 <b>do</b>
    //...
<b>endfor</b>;
</pre>

<p>
<p class="subheading">Conditional connections</p>

<p><!--connection!conditional-->

<p>Creation of a connection can be made conditional, using the <tt>if</tt>
keyword:

<p><!--ned!keywords!if-->

<p><pre>
<b>for</b> i=0..n <b>do</b>
    node1.outGate[i] --&gt; node2[i].inGate <b>if</b> i%2==0;
<b>endfor</b>;
</pre>

<p>The <tt>if</tt> condition is evaluated for each connection
(in the above example, for each <i>i</i> value), and the
decision is made individually each time whether to create the
the connection or not. In the above example we connected every
second gate. Conditions may also use random variables, as
shown in the next section.

<p>
<p class="subheading">The nocheck modifier</p>

<p>By default, NED requires that all gates be connected. Since this
check can be inconvenient at times, it can be turned off
using the <tt>nocheck</tt> modifier.

<p>The following example generates a random subgraph of a full graph.

<p><pre>
<b>module</b> RandomConnections
    <b>parameters</b>: //..
    <b>gates</b>: //..
    <b>submodules</b>: //..
    <b>connections</b> <b>nocheck</b>:
        <b>for</b> i=0..n-1, j=0..n-1 <b>do</b>
            node[i].out[j] --&gt; node[j].in[i] <b>if</b> uniform(0,1)&lt;0.3;
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>When using <tt>nocheck</tt>, it is the
simple modules' responsibility not to send messages on gates
that are not connected.

<p>
<H2><A NAME="sec136"/>3.6 Network definitions</H2>
<a name="sec:ch-ned-lang:network"></a>
<!--ned!network definition-->

<p>Module module declarations (compound and simple module declarations)
just define module types. To actually get a simulation model that
can be run, you need to write a <i>network definition</i>.

<p>A network definition declares a simulation model as an instance
of a previously defined module type. You'll typically want to use
a compound module type here, although it is also possible to
program a model as a self-contained simple module and instantiate it
as a ``network''.

<p>There can be several network definitions in your NED file or NED files.
The simulation program that uses those NED files will be
able to run any of them; you typically select the desired one
in the config file (<tt>omnetpp.ini</tt>).

<p>The syntax of a network definition is similar to that of a submodule
declaration:

<p><pre>
<b>network</b> wirelessLAN: WirelessLAN
    <b>parameters</b>:
        numUsers=10,
        httpTraffic=true,
        ftpTraffic=true,
        distanceFromHub=truncnormal(100,60);
<b>endnetwork</b>
</pre>

<p>Here, <tt>WirelessLAN</tt> is the name of previously defined
compound module type, which presumably contains further
compound modules of types <tt>WirelessHost</tt>, <tt>WirelessHub</tt>, etc.

<p>Naturally, only module types without gates can
be used in network definitions.

<p>Just as in submodules, you do not need to assign values to all
parameters. Unassigned parameters can get their values from the
config file (<tt>omnetpp.ini</tt>) or will be interactively prompted for.

<p>

<p><H2><A NAME="sec137"/>3.7 Expressions</H2>
<a name="ch-ned-lang:sec:expressions"></a>

<p>In the NED language there are a number of places where
expressions<!--ned!expressions--> are expected.

<p>Expressions have a C-style syntax. They are built with the usual math
operators<!--math operators-->; they can use parameters taken by
value or by reference; call C functions; contain random and input
values etc.

<p>When an expression is used for a parameter value, it is evaluated
each time the parameter value is accessed (unless the parameter is
declared <tt>const</tt>, see <a href="#sec126">[3.4.1]</a>). This means
that a simple module querying a non-const parameter during simulation
may get different values every time (e.g. if the value involves a
random variable, or it contains other parameters taken by reference).
Other expressions (including <tt>const</tt> parameter values)
are evaluated only once.

<p>XML-type parameters can be used to conveniently access external
XML files or parts of them. XML-type parameters can be assigned
with the <tt>xmldoc()</tt> operator, also described in this section.

<p>
<H3><A NAME="sec138"/>3.7.1 Constants</H3>

<p><p class="subheading">Numeric and string constants</p>

<p>Numeric constants are accepted in their usual decimal or
scientific notations.

<p>
<p class="subheading">String constants</p>

<p>String constants use double quotes.

<p>
<p class="subheading">Time constants</p>

<p>Anywhere you would put numeric constants<!--numeric constants-->
(integer or real) to mean time in seconds, you can also specify the
time in units like milliseconds, minutes or hours:

<p>
<pre>
    ...
    <b>parameters</b>:
        propagationDelay = 560ms, // 0.560s
        connectionTimeout = 6m 30s 500ms, // 390.5s
        recoveryIntvl = 0.5h; // 30 min
</pre>

<p>
The following units<!--time units--> can be used:

<p><table border>
<TR> <TD align=center>

<p><b>Unit</b> </TD> <TD align=left> <b>Meaning</b> </TD></TR>
<TR> <TD align=center> <tt>ns</tt>   </TD> <TD align=left> nanoseconds </TD></TR>
<TR> <TD align=center> <tt>us</tt>   </TD> <TD align=left> microseconds </TD></TR>
<TR> <TD align=center> <tt>ms</tt>   </TD> <TD align=left> milliseconds </TD></TR>
<TR> <TD align=center> <tt>s</tt>    </TD> <TD align=left> seconds </TD></TR>
<TR> <TD align=center> <tt>m</tt>    </TD> <TD align=left> minutes (60s) </TD></TR>
<TR> <TD align=center> <tt>h</tt>    </TD> <TD align=left> hours (3600s) </TD></TR>
<TR> <TD align=center> <tt>d</tt>    </TD> <TD align=left> days (86400s) </TD></TR>
</table>

<p>
<H3><A NAME="sec139"/>3.7.2 Referencing parameters</H3>

<p>Expressions can use the parameters of the enclosing compound module
(the one being defined) and of submodules defined earlier in NED file.
The syntax for the latter is <tt>submod.param</tt> or <tt>submod[index].param</tt>.

<p>There are two keywords that you can use with a parameter name:
<tt>ancestor</tt> and <tt>ref</tt>.  The first one (<tt>ancestor</tt> <i>param</i>)
means that if compound module doesn't have such a parameter,
further modules up in the module hierarchy will be searched for the parameter.
<tt>ancestor</tt> is considered bad practice because it violates the encapsulation
principle and can only be checked at runtime. It is provided for the
rare case when it is really needed.

<p><tt>ref</tt> <i>param</i> takes the parameter by reference, meaning that
runtime changes to the parameter will propagate to all modules which
take that parameter by reference. Like <tt>ancestor</tt>, <tt>ref</tt>
should also be used very sparingly. One possible use is tuning a model
at runtime, in search for an optimum: one defines a parameter
at the highest level of the model, and lets other modules take it by reference --
then if you change the parameter value at runtime
(manually or from a simple module), it will affect the whole model.
In another setup, reference parameters may be used to propagate
status values to neighbouring modules.

<p>

<p><H3><A NAME="sec140"/>3.7.3 Operators</H3>
<!--ned!expressions!operators-->

<p>The operators supported in NED are similar to C/C++ operators,
with the following differences:

<p><ul>
  <li>^ is used for power-of (and not bitwise XOR as in C)
  <li>## is used for logical XOR (same as != between logical values), and
        # is used for bitwise XOR
  <li>the precedence of bitwise operators (&amp;, |, #) have been raised
        to bind stronger than relational operations. This precedence is usually
        more convenient than the C/C++ one.
</ul>

<p>All values are represented as <tt>double</tt>s. For the bitwise operators,
<tt>double</tt>s are converted to <tt>unsigned long</tt>
  <br><ul><font size=-1>[In case you are worried about <tt>long</tt> values being not accurately
  represented in <tt>double</tt>s, this is not the case. IEEE-754 <tt>double</tt>s
  have 52 bit mantissas, and integer numbers in that range are represented
  without rounding errors.]</font></ul>
using the C/C++ builtin conversion (type cast), the operation is performed,
then the result is converted back to <tt>double</tt>.
Similarly, for the logical operators &amp;&amp;, || and ##,
the operands are converted to <tt>bool</tt> using the C/C++ builtin
conversion (type cast), the operation is performed, then the result
is converted back to <tt>double</tt>. For modulus (%), the operands are
converted to <tt>long</tt>.

<p>Here's the complete list of operators, in order of decreasing precendence:

<p><table border>
<TR> <TD align=left>

<p><b>Operator</b>                   </TD> <TD align=left> <b>Meaning</b> </TD></TR>
<TR> <TD align=left> <tt>-</tt>, <tt>!</tt>, <it>~</it> </TD> <TD align=left> unary minus, negation, bitwise complement </TD></TR>
<TR> <TD align=left> <tt>^</tt>         </TD> <TD align=left> power-of </TD></TR>
<TR> <TD align=left> <tt>*</tt>, <tt>/</tt>, <tt>%</tt>       </TD> <TD align=left> multiply, divide, modulus </TD></TR>
<TR> <TD align=left> <tt>+</tt>, <tt>-</tt>                 </TD> <TD align=left> add, subtract </TD></TR>
<TR> <TD align=left> <tt>&lt;&lt;</tt>, <tt>&gt;&gt;</tt>               </TD> <TD align=left> bitwise shift </TD></TR>
<TR> <TD align=left> <tt>&amp;</tt>, <tt>|</tt>, <tt>#</tt>      </TD> <TD align=left> bitwise and, or, xor </TD></TR>
<TR> <TD align=left> <tt>==</tt>                         </TD> <TD align=left> equal </TD></TR>
<TR> <TD align=left> <tt>!=</tt>                         </TD> <TD align=left> not equal </TD></TR>
<TR> <TD align=left> <tt>&gt;</tt>, <tt>&gt;=</tt>                </TD> <TD align=left> greater, greater or equal </TD></TR>
<TR> <TD align=left> <tt>&lt;</tt>, <tt>&lt;=</tt>                </TD> <TD align=left> less, less or equal </TD></TR>
<TR> <TD align=left> <tt>&amp;&amp;</tt>, <tt>||</tt>, <tt>##</tt> </TD> <TD align=left> logical operators and, or, xor </TD></TR>
<TR> <TD align=left> <tt>?:</tt>                         </TD> <TD align=left> the C/C++ ``inline if'' </TD></TR>
</table>

<p>

<p><H3><A NAME="sec141"/>3.7.4 The <tt>sizeof()</tt> and <tt>index</tt> operators</H3>

<p>A useful operator is <tt>sizeof()</tt><!--ned!sizeof()-->, which gives the
size of a vector gate<!--gate!vector-->. The <tt>index</tt>
operator<!--ned!index operator--> gives the index of the current
submodule in its module vector.

<p>The following example describes a router with several ports and one routing unit.
We assume that gate vectors <tt>in[]</tt> and <tt>out[]</tt> have the same size.

<p><pre>
<b>module</b> Router
    <b>gates</b>:
        <b>in</b>: in[];
        <b>out</b>: out[];
    <b>submodules</b>:
        port: PPPInterface[<b>sizeof</b>(in)]; // one PPP for each input gate
            <b>parameters</b>: interfaceId = 1+<b>index</b>; // 1,2,3...
        routing: RoutingUnit;
            <b>gatesizes</b>:
                in[<b>sizeof</b>(in)];  // one gate pair for each port
                out[<b>sizeof</b>(in)];
    <b>connections</b>:
        <b>for</b> i = 0..<b>sizeof</b>(in)-1 <b>do</b>
            in[i] --&gt; port[i].in;
            out[i] &lt;-- port[i].out;
            port[i].out --&gt; routing.in[i];
            port[i].in &lt;-- routing.out[i];
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>
<H3><A NAME="sec142"/>3.7.5 The <tt>xmldoc()</tt> operator</H3>

<p>The <tt>xmldoc()</tt> operator can be used to assign XML-type parameters,
that is, point them to XML files or to specific elements inside XML files.

<p><tt>xmldoc()</tt> has two flavours: one accepts a file name, the second accepts
a file name plus an XPath-like expression which selects an element
inside the XML file. Examples:

<p><pre>
xmlparam = <b>xmldoc</b>("someconfig.xml");
xmlparam = <b>xmldoc</b>("someconfig.xml", "/config/profile[@id='2']");
</pre>

<p>OMNeT++ supports a subset of the XPath 1.0 specification; details are
documented below.

<p>From the C++ code you'd access the XML element like this:

<pre>
<a href="../api/classcXMLElement.html">cXMLElement</a> *rootelement = par("xmlparam").xmlValue();
</pre>
<p>
The <tt><a href="../api/classcXMLElement.html">cXMLElement</a></tt> class provides a DOM-like access to the XML document.
You can then navigate the document tree, extract the information you need,
and store it in variables or your internal data structure.
<tt><a href="../api/classcXMLElement.html">cXMLElement</a></tt> is documented in Chapter <a href="#sec223">[6]</a>.

<p>You can also read XML parameters from omnetpp.ini:

<pre>
[Parameters]
**.interface[*].config = xmldoc("conf.xml")
</pre>
<p>
or

<pre>
[Parameters]
**.interface[*].config = xmldoc("all-in-one.xml", "/config/interfaces/interface[2]")
</pre>
<p>

<p><H3><A NAME="sec143"/>3.7.6 XML documents and the XPath subset supported</H3>

<p><tt>xmldoc()</tt> with two arguments accepts a path expression
to select an element within the document. The expression syntax is
similar to XPath.

<p>If the expression matches several elements, the first element
(in preorder depth-first traversal) will be selected. (This is
unlike XPath, which selects all matching nodes.)

<p>The expression syntax is the following:

<p><ul>
  <li> An expression consists of <i>path components</i> (or "steps")
        separated by "<tt>/</tt>" or "<tt>//</tt>".
  <li> A path component can be an element tag name, "<tt>*</tt>", "<tt>.</tt>"
        or "<tt>..</tt>".
  <li> "<tt>/</tt>" means child element (just as e.g. in <tt>/usr/bin/gcc</tt>);
        "<tt>//</tt>" means an element any levels under the current element.
  <li> "<tt>.</tt>", "<tt>..</tt>" and "<tt>*</tt>" mean current element,
        parent element, and an element with any tag name, respectively.
  <li> Element tag names and "<tt>*</tt>" can have an optional predicate
        in the form "<tt>[position]</tt>" or "<tt>[@attribute='value']</tt>".
        Positions start from zero.
  <li> Predicate of the form "<tt>[@attribute=<i>$param</i>]</tt>" are also
        accepted, where <tt><i>$param</i></tt> can be one of:
        <tt>$MODULE_FULLPATH</tt>, <tt>$MODULE_FULLNAME</tt>, <tt>$MODULE_NAME</tt>,
        <tt>$MODULE_INDEX</tt>, <tt>$MODULE_ID</tt>,
        <tt>$PARENTMODULE_FULLPATH</tt>, <tt>$PARENTMODULE_FULLNAME</tt>,
        <tt>$PARENTMODULE_NAME</tt>, <tt>$PARENTMODULE_INDEX</tt>, <tt>$PARENTMODULE_ID</tt>,
        <tt>$GRANDPARENTMODULE_FULLPATH</tt>, <tt>$GRANDPARENTMODULE_FULLNAME</tt>,
        <tt>$GRANDPARENTMODULE_NAME</tt>, <tt>$GRANDPARENTMODULE_INDEX</tt>,
        <tt>$GRANDPARENTMODULE_ID</tt>.<sup><b>[New!]</b></sup>
</ul>

<p>Examples:

<p><ul>
  <li> <tt>/foo</tt> -- the root element which must be called <tt>&lt;foo&gt;</tt>
  <li> <tt>/foo/bar</tt> -- first <tt>&lt;bar&gt;</tt> child of the <tt>&lt;foo&gt;</tt> root element
  <li> <tt>//bar</tt> -- first <tt>&lt;bar&gt;</tt> anywhere (depth-first search!)
  <li> <tt>/*/bar</tt> -- first <tt>&lt;bar&gt;</tt> child of the root element which may have any tag name
  <li> <tt>/*/*/bar</tt> -- first <tt>&lt;bar&gt;</tt> child two levels below the root element
  <li> <tt>/*/foo[0]</tt> -- first <tt>&lt;foo&gt;</tt> child of the root element
  <li> <tt>/*/foo[1]</tt> -- second <tt>&lt;foo&gt;</tt> child of the root element
  <li> <tt>/*/foo[@color='green']</tt> -- first <tt>&lt;foo&gt;</tt> child which has attribute "color" with value "green"
  <li> <tt>//bar[1]</tt> -- a <tt>&lt;bar&gt;</tt> element anywhere which is the second <tt>&lt;bar&gt;</tt> among its siblings
  <li> <tt>//*[@color='yellow']</tt> -- any element anywhere which has attribute "color" with value "yellow"
  <li> <tt>//*[@color='yellow']/foo/bar</tt> -- first <tt>&lt;bar&gt;</tt> child of first <tt>&lt;foo&gt;</tt> child of a "yellow-colored" element anywhere
</ul>

<p>Path support allows you put all your XML configuration into
a single XML document, when you would otherwise end up with lots
of small XML files. For example, consider the following <tt>sample.xml</tt>:

<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;root&gt;
    &lt;traffic-profile id="low"&gt;
        ...
    &lt;/traffic-profile&gt;
    &lt;traffic-profile id="medium"&gt;
        ...
    &lt;/traffic-profile&gt;
    &lt;traffic-profile id="high"&gt;
        ...
    &lt;/traffic-profile&gt;
&lt;/root&gt;
</pre>
<p>
In one simulation you can configure module parameters as
<tt>xmldoc("sample.xml", "//traffic-profile[@id='low']")</tt>;
in another run as
<tt>xmldoc("sample.xml", "//traffic-profile[@id='medium']")</tt>,
and so on.

<p>
<H3><A NAME="sec144"/>3.7.7 Functions</H3>
<!--ned!functions-->

<p>In NED expressions, you can use the following mathematical functions:
<ul>
  <li>many of the C language's <tt>&lt;math.h&gt;</tt> library functions:
    <tt>exp()</tt>, <tt>log()</tt>, <tt>sin()</tt>, <tt>cos()</tt>, <tt>floor()</tt>,
    <tt>ceil()</tt>, <tt>etc.</tt>
  <li>functions that generate random variables: <tt>uniform</tt>,
    <tt>exponential</tt>, <tt>normal</tt> and others were already
    discussed.
</ul>

<p>It is possible to add new ones, see <a href="#sec146">[3.7.9]</a>.

<p><H3><A NAME="sec145"/>3.7.8 Random values</H3>

<p>Expressions may contain random variates from different distributions.
Such parameters, unless declared as <tt>const</tt>,
return different values each time they are evaluated.

<p>If the parameter is declared as <tt>const</tt>, it is only evaluated
once at the beginning of the simulation, and subsequent queries
on the parameter will always return the same value.

<p>Random variate functions use one of the random number generators (RNGs)
provided by OMNeT++. By default this is generator 0, but you can specify
which one is to be used.

<p>OMNeT++ has the following predefined distributions<!--distribution!predefined-->:

<p><table border>
<TR> <TD align=left>
<b>Function</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=center colspan=2><b>Continuous distributions</b></TD></TR>
<TR> <TD align=left> <tt>uniform(a, b, <i>rng=0</tt>)</i> </TD> <TD align=left> uniform distribution in the range [a,b) </TD></TR>
<TR> <TD align=left> <tt>exponential(mean, <i>rng=0</tt>)</i> </TD> <TD align=left> exponential distribution with the given mean </TD></TR>
<TR> <TD align=left> <tt>normal(mean, stddev, <i>rng=0</tt>)</i> </TD> <TD align=left> normal distribution with the given mean and standard deviation </TD></TR>
<TR> <TD align=left> <tt>truncnormal(mean, stddev, <i>rng=0</tt>)</i> </TD> <TD align=left> normal distribution truncated to nonnegative values </TD></TR>
<TR> <TD align=left> <tt>gamma_d(alpha, beta, <i>rng=0</tt>)</i> </TD> <TD align=left> gamma distribution with parameters alpha&gt;0, beta&gt;0 </TD></TR>
<TR> <TD align=left> <tt>beta(alpha1, alpha2, <i>rng=0</tt>)</i> </TD> <TD align=left> beta distribution with parameters alpha1&gt;0, alpha2&gt;0 </TD></TR>
<TR> <TD align=left> <tt>erlang_k(k, mean, <i>rng=0</tt>)</i> </TD> <TD align=left> Erlang distribution with k&gt;0 phases and the given mean </TD></TR>
<TR> <TD align=left> <tt>chi_square(k, <i>rng=0</tt>)</i> </TD> <TD align=left> chi-square distribution with k&gt;0 degrees of freedom </TD></TR>
<TR> <TD align=left> <tt>student_t(i, <i>rng=0</tt>)</i> </TD> <TD align=left> student-t distribution with i&gt;0 degrees of freedom </TD></TR>
<TR> <TD align=left> <tt>cauchy(a, b, <i>rng=0</tt>)</i> </TD> <TD align=left> Cauchy distribution with parameters a,b where b&gt;0 </TD></TR>
<TR> <TD align=left> <tt>triang(a, b, c, <i>rng=0</tt>)</i> </TD> <TD align=left> triangular distribution with parameters a&lt;=b&lt;=c, a!=c </TD></TR>
<TR> <TD align=left> <tt>lognormal(m, s, rng=0)</tt> </TD> <TD align=left> lognormal distribution with mean m and variance s&gt;0 </TD></TR>
<TR> <TD align=left> <tt>weibull(a, b, <i>rng=0</tt>)</i> </TD> <TD align=left> Weibull distribution with parameters a&gt;0, b&gt;0 </TD></TR>
<TR> <TD align=left> <tt>pareto_shifted(a, b, c, <i>rng=0</tt>)</i> </TD> <TD align=left> generalized Pareto distribution with parameters a, b and shift c </TD></TR>
<TR> <TD align=center colspan=2><b>Discrete distributions</b> </TD></TR>
<TR> <TD align=left> <tt>intuniform(a, b, <i>rng=0</tt>)</i> </TD> <TD align=left> uniform integer from a..b </TD></TR>
<TR> <TD align=left> <tt>bernoulli(p, <i>rng=0</tt>)</i> </TD> <TD align=left> result of a Bernoulli trial with probability 0&lt;=p&lt;=1 (1 with probability p and 0 with probability (1-p)) </TD></TR>
<TR> <TD align=left> <tt>binomial(n, p, <i>rng=0</tt>)</i> </TD> <TD align=left> binomial distribution with parameters n&gt;=0 and 0&lt;=p&lt;=1 </TD></TR>
<TR> <TD align=left> <tt>geometric(p, <i>rng=0</tt>)</i> </TD> <TD align=left> geometric distribution with parameter 0&lt;=p&lt;=1 </TD></TR>
<TR> <TD align=left> <tt>negbinomial(n, p, <i>rng=0</tt>)</i> </TD> <TD align=left> binomial distribution with parameters n&gt;0 and 0&lt;=p&lt;=1</TD></TR>
<TR> <TD align=left> <tt>poisson(lambda, <i>rng=0</tt>)</i> </TD> <TD align=left> Poisson distribution with parameter lambda </TD></TR>
<TR> <TD align=left> 
</table>


If you do not specify the optional <tt>rng</tt> argument, the functions will
use random number generator 0.

<p>Examples:

<pre>
intuniform(0,10)/10  // one of: 0, 0.1, 0.2, ..., 0.9, 1
exponential(5)       // exponential with mean=5 (thus parameter=0.2)
2+truncnormal(5,3)   // normal distr with mean 7 truncated to &gt;=2 values
</pre>
<p>
The above distributions are implemented with C functions, and you can easily
add new ones (see section <a href="#sec146">[3.7.9]</a>).
Your distributions will be treated in the same way as the built-in ones.

<p>

<p><H3><A NAME="sec146"/>3.7.9 Defining new functions</H3>
<!--ned!functions-->
<a name="sec:ch-ned-lang:defining-functions"></a>

<p>To use user-defined functions<!--functions!user-defined-->, one has
to code the function in C++.  The C++ function must take 0, 1, 2, 3, or 4
arguments of type double and return a double. The function must be
registered in one of the C++ files with the <tt>Define_Function()</tt>
macro.

<p>An example function (the following code must appear in one of the C++
sources):

<p>
<pre>
#include &lt;omnetpp.h&gt;

double average(double a, double b)
{
  return (a+b)/2;
}

Define_Function(average, 2);
</pre>

<p>
The number 2 means that the <tt>average()</tt> function has 2
arguments.  After this, the <tt>average()</tt> function can be used in
NED files:

<p>
<pre>
<b>module</b> Compound
    <b>parameter</b>: a,b;
    <b>submodules</b>:
        proc: Processor
            <b>parameters</b>: av = average(a,b);
<b>endmodule</b>
</pre>

<p>
If your function takes parameters that are <tt>int</tt> or <tt>long</tt> or
some other type which is not <tt>double</tt>, you can create wrapper function
that takes all doubles and does the conversion. In this case you have
to register the wrapper function with the <tt>Define_Function2()</tt> macro
which allows a function to be registered with a name different from the
name of the function that implements it. You can do the same
if the return value differs from <tt>double</tt>.

<pre>
#include &lt;omnetpp.h&gt;

long factorial(int k)
{
  ...
}

static double _wrap_factorial(double k)
{
  return factorial((int)k);
}

Define_Function2(factorial, _wrap_factorial, 1);
</pre>
<p>

<p>

<p><H2><A NAME="sec147"/>3.8 Parameterized compound modules</H2>

<p><!--module!compound-->

<p>With the help of conditional parameter and gatesize blocks and
conditional connections<!--connection!conditional-->, one can
create complex topologies.

<p>
<H3><A NAME="sec148"/>3.8.1 Examples</H3>

<p><p class="subheading">Example 1: Router</p>

<p>The following example contains a router module with the number of
ports taken as parameter. The compound module is built using three
module types: Application, RoutingModule, DataLink. We assume that
their definition is in a separate NED file which we will import.

<p><pre>
<b>import</b> "modules";

<b>module</b> Router
    <b>parameters</b>:
        rteProcessingDelay, rteBuffersize,
        numOfPorts: <b>const</b>;
    <b>gates</b>:
        <b>in</b>: inputPorts[];
        <b>out</b>: outputPorts[];
    <b>submodules</b>:
        localUser: Application;
        routing: RoutingUnit
            <b>parameters</b>:
                processingDelay = rteProcessingDelay,
                buffersize = rteBuffersize;
            <b>gatesizes</b>:
                input[numOfPorts+1],
                output[numOfPorts+1];
        portIf: PPPNetworkInterface[numOfPorts]
            <b>parameters</b>:
                retryCount = 5,
                windowSize = 2;
    <b>connections</b>:
        <b>for</b> i=0..numOfPorts-1 <b>do</b>
            routing.output[i] --&gt; portIf[i].fromHigherLayer;
            routing.input[i] &lt;-- portIf[i].toHigherLayer;
            portIf[i].toPort --&gt; outputPorts[i];
            portIf[i].fromPort &lt;-- inputPorts[i];
        <b>endfor</b>;
        routing.output[numOfPorts] --&gt; localUser.input;
        routing.input[numOfPorts] &lt;-- localUser.output;
<b>endmodule</b>
</pre>

<p>
<p class="subheading">Example 2: Chain</p>

<p>
For example, one can create a chain<!--chain--> of modules like this:

<p><pre>
<b>module</b> Chain
    <b>parameters</b>: count: <b>const</b>;
    <b>submodules</b>:
        node : Node [count]
            <b>gatesizes</b>:
                in[2], out[2];
            <b>gatesizes</b> <b>if</b> index==0 || index==count-1:
                in[1], out[1];
    <b>connections</b>:
        <b>for</b> i = 0..count-2 <b>do</b>
            node[i].out[i!=0 ? 1 : 0] --&gt; node[i+1].in[0];
            node[i].in[i!=0 ? 1 : 0] &lt;-- node[i+1].out[0];
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>
<p class="subheading">Example 3: Binary Tree</p>

<p>
One can use conditional connections to build a binary tree<!--binary tree-->.
The following NED code loops through all possible node pairs, and
creates the connections needed for a binary tree.

<p><pre>
<b>simple</b> BinaryTreeNode
    <b>gates</b>:
        <b>in</b>: fromupper;
        <b>out</b>: downleft;
        <b>out</b>: downright;
<b>endsimple</b>

<b>module</b> BinaryTree
    <b>parameters</b>:
        height: <b>const</b>;
    <b>submodules</b>:
        node: BinaryTreeNode [ 2^height-1 ];
    <b>connections</b> <b>nocheck</b>:
        <b>for</b> i = 0..2^height-2, j = 0..2^height-2 <b>do</b>
            node[i].downleft --&gt; node[j].fromupper <b>if</b> j==2*i+1;
            node[i].downright --&gt; node[j].fromupper <b>if</b> j==2*i+2;
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>Note that not every gate of the modules will be connected. By default,
an unconnected gate produces a run-time error message when the
simulation is started, but this error message is turned off here with
the <tt>nocheck</tt> modifier.  Consequently, it
is the simple modules' responsibility not to send on a gate which is
not leading anywhere.

<p>An alert reader might notice that there is a better alternative
to the above code. Each node except the ones at the lowest level
of the tree has to be connected to exactly two nodes,
so we can use a single loop to create the connections.

<p><pre>
<b>module</b> BinaryTree2
    <b>parameters</b>:
        height: <b>const</b>;
    <b>submodules</b>:
        node: BinaryTreeNode [ 2^height-1 ];
    <b>connections</b> <b>nocheck</b>:
        <b>for</b> i=0..2^(height-1)-2 <b>do</b>
            node[i].downleft --&gt; node[2*i+1].fromupper;
            node[i].downright --&gt; node[2*i+2].fromupper;
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>

<p><p class="subheading">Example 4: Random graph</p>

<p>Conditional connections can also be used to generate random
topologies<!--topology!random-->.  The following code generates a
random subgraph of a full graph:

<p><pre>
<b>module</b> RandomGraph
    <b>parameters</b>:
        count: <b>const</b>,
        connectedness; // 0.0&lt;x&lt;1.0
    <b>submodules</b>:
        node: Node [count];
            <b>gatesizes</b>: <b>in</b>[count], <b>out</b>[count];
    <b>connections</b> <b>nocheck</b>:
        <b>for</b> i=0..count-1, j=0..count-1 <b>do</b>
            node[i].out[j] --&gt; node[j].in[i]
                <b>if</b> i!=j && uniform(0,1)&lt;connectedness;
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>Note the use of the <tt>nocheck</tt> modifier
here too, to turn off error messages given by the network setup code
for unconnected gates.

<p>
<H3><A NAME="sec149"/>3.8.2 Design patterns for compound modules</H3>

<p><!--module!compound!patterns-->
<!--topology!patterns-->

<p>Several approaches can be used when you want to create complex
topologies which have a regular structure; three of them are
described below.

<p>
<p class="subheading">`Subgraph of a Full Graph'</p>

<p>
This pattern takes a subset of the connections of a full graph.  A
condition is used to ``carve out'' the necessary interconnection from
the full graph:

<p><pre>
for i=0..N-1, j=0..N-1 do
    node[i].out[...] --&gt; node[j].in[...] if condition(i,j);
endfor;
</pre>

<p>The RandomGraph compound module (presented earlier) is an example of
this pattern, but the pattern can generate any graph where an
appropriate <i>condition(i,j)</i> can be formulated. For example,
when generating a tree<!--topology!tree--> structure, the condition
would return whether node <i>j</i> is a child of node <i>i</i> or
vica versa.

<p>Though this pattern is very general, its usage can be prohibitive if
the <i>N</i> number of nodes is high and the graph is sparse (it has
much fewer connections that <i>N<sup>2</sup></i>). The following
two patterns do not suffer from this drawback.

<p>
<p class="subheading">`Connections of Each Node'</p>

<p>The pattern loops through all nodes and creates the necessary
connections for each one. It can be generalized like this:

<p><pre>
for i=0..Nnodes, j=0..Nconns(i)-1 do
    node[i].out[j] --&gt; node[rightNodeIndex(i,j)].in[j];
endfor;
</pre>

<p>The Hypercube<!--topology!hypercube--> compound module (to be
presented later) is a clear example of this approach. BinaryTree can
also be regarded as an example of this pattern where the inner j loop
is unrolled.

<p>The applicability of this pattern depends on how easily the <i>rightNodeIndex(i,j)</i>
function can be formulated.

<p>
<p class="subheading">`Enumerate All Connections'</p>

<p>
A third pattern is to list all connections within a loop:

<p><pre>
for i=0..Nconnections-1 do
    node[leftNodeIndex(i)].out[...] --&gt; node[rightNodeIndex(i)].in[...];
endfor;
</pre>

<p>The pattern can be used if <i>leftNodeIndex(i)</i> and <i>rightNodeIndex(i)</i>
mapping functions can be sufficiently formulated.

<p>The Serial module is an example of this approach where the mapping
functions are extremely simple: <i>leftNodeIndex(i)=i</i> and <i>rightNodeIndex(i)=i+1</i>.
The pattern can also be used to create a random subset of a full
graph with a fixed number of connections.

<p>In the case of irregular structures where none of the above patterns
can be employed, you can resort to specifying constant submodule/gate
vector sizes and explicitly listing all connections, like you
would do it in most existing simulators.

<p>

<p>
<H3><A NAME="sec150"/>3.8.3 Topology templates</H3>
<a name="sec:ch-ned-lang:topology-templates"></a>

<p>
<p class="subheading">Overview</p>

<p>
Topology templates are nothing more than compound modules where one or
more submodule types are left as parameters (using the
<tt>like</tt> phrase of the NED language).  You can
write such modules which implement mesh<!--topology!mesh-->,
hypercube<!--topology!hypercube-->,
butterfly<!--topology!butterfly-->, perfect
shuffle<!--topology!perfect shuffle--> or other topologies, and you
can use them wherever needed in you simulations.  With topology
templates<!--topology!templates-->, you can reuse
<i>interconnection structure</i>.

<p>

<p><p class="subheading">An example: hypercube</p>

<p>
The concept is demonstrated on a network with hypercube interconnection.
When building an N-dimension hypercube, we can exploit the fact
that each node is connected to N others which differ from it
only in one bit of the binary representations of the node indices
(see Fig. <a href="#fig:ch-ned-lang:hypercube-topology">below</a>).

<p>
  <div align=center>
    <img src="usmanFig8.gif">
    <center><i>Figure: Hypercube topology</i></center>
    <a name="fig:ch-ned-lang:hypercube-topology"></a>
  </div>

<p>

<p>The hypercube topology<!--topology!hypercube--> template is the
following (it can be placed into a separate file, e.g <tt>hypercube.ned</tt>):

<p>
<pre>
<b>simple</b> Node
    <b>gates</b>:
        <b>out</b>: out[];
        <b>in</b>: in[];
<b>endsimple</b>

<b>module</b> Hypercube
    <b>parameters</b>:
        dim, nodetype;
    <b>submodules</b>:
        node: nodetype[2^dim] <b>like</b> Node
        <b>gatesizes</b>:
            out[dim], in[dim];
    <b>connections</b>:
        <b>for</b> i=0..2^dim-1, j=0..dim-1 <b>do</b>
            node[i].out[j] --&gt; node[i # 2^j].in[j]; // # is bitwise XOR
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>

<p>When you create an actual hypercube, you substitute the name
of an existing module type (e.g. <tt>"Hypercube_PE"</tt>) for the nodetype
parameter. The module type implements the algorithm the user
wants to simulate and it must have the same gates that the Node
type has. The topology template code can be used through importing
the file:

<p>
<pre>
<b>import</b> "hypercube.ned";

<b>simple</b> Hypercube_PE
    <b>gates</b>: <b>out</b>: out[]; <b>in</b>: in[];
<b>endsimple</b>

<b>network</b> hypercube: Hypercube
    <b>parameters</b>:
        dim = 4,
        nodetype = "Hypercube_PE";
<b>endnetwork</b>
</pre>

<p>

<p>If you put the nodetype parameter to the ini file, you can use the
same simulation model to test e.g. several routing algorithms in a
hypercube, each algorithm implemented with a different
simple module type -- you just have to supply
different values to nodetype, such as <tt>"WormholeRoutingNode"</tt>,
<tt>"DeflectionRoutingNode"</tt>, etc.

<p>

<p><H2><A NAME="sec151"/>3.9 Large networks</H2>

<p>There are situations when using hand-written NED files to describe
network topology is inconvenient, for example when
the topology information comes from
an external source<!--topology!external source--> like
a network management program.

<p>In such case, you have two possibilities:

<p><ol>
  <li>generating NED files from data files
  <li>building the network from C++ code
</ol>

<p>The two solutions have different advantages and disadvantages.
The first is more useful in the model development phase, while
the second one is better for writing larger scale, more productized
simulation programs. In the next sections we examine both methods.

<p>

<p><H3><A NAME="sec152"/>3.9.1 Generating NED files</H3>

<p>
Text processing programs like <tt>awk</tt> or <tt>perl</tt> are
excellent tools to read in textual data files and generate NED files
from them<!--ned!file generation-->.  Perl also has extensions to
access SQL databases, so it can also be used if the network topology
is stored in a database.

<p>The advantage is that the necessary <tt>awk</tt> or <tt>perl</tt>
program can be written in a relatively short time, and it is
inexpensive to maintain afterwards: if the structure of the data files
change, the NED-creating program can be easily modified. The
resulting NED files can either be translated by <tt>nedtool</tt>
into C++ and compiled in, or loaded dynamically.

<p>
<H3><A NAME="sec153"/>3.9.2 Building the network from C++ code</H3>

<p>Another alternative is to write C++ code which becomes part of the
simulation executable. The code would read the topology data from data
files or a database, and build the network directly, using
dynamic module creation (to be described later, in section
<a href="#sec198">[4.11]</a>).
The code which you need to write would be similar to the <tt>*_n.cc</tt>
files output by <tt>nedtool</tt>.

<p>Since writing such code is more complex than letting perl generate
NED files, this method is recommended when the simulation program
has to be somewhat more productized, for example when OMNeT++
and the simulation model is embedded into a larger program, e.g.
a network design tool.

<p>
<H2><A NAME="sec154"/>3.10 XML binding for NED files</H2>

<p>To increase interoperability, NED files (and also message definition files)
have an XML representation. Any NED file can be converted to XML, and
any XML file which corresponds to the NED DTD can be converted to NED.
  <br><ul><font size=-1>[DTD stands for Document Type Descriptor, and it defines
  a "grammar" for XML files. More info can be found on the W3C web site,
  www.w3.org.]</font></ul>

<p>XML is well suited for machine processing. For example, stylesheet
transformations (XSLT) can be used to extract information from NED files,
or the other way round, create NED files from external info present in
XML form. One practical application of XML is the <tt>opp_neddoc</tt>
documentation generation tool which is described in Chapter <a href="#sec363">[11]</a>.

<p>The <tt>nedtool</tt> program (which also translates NED to C++ code)
can be used to convert between NED and XML.

<p>Converting a NED file to XML:

<pre>
nedtool -x wireless.ned
</pre>
<p>
It generates <tt>wireless_n.xml</tt>.
Several switches control the exact content and details
of the resulting XML as well as the amount of checks
made on the input.

<p>Converting the XML representation back to NED:

<pre>
nedtool -n wireless.xml
</pre>
<p>
The result is <tt>wireless_n.ned</tt>.

<p>Using nedtool as NED compiler to generate C++ code:

<pre>
nedtool wireless.ned
</pre>
<p>
The resulting code is more compact than the
one created by <tt>nedtool</tt>'s predecessor <tt>nedc</tt>.
As a result, <tt>nedtool</tt>-created <tt>_n.cc</tt>
C++ files compile much faster.

<p>You can generate C++ code from the XML format as well:

<pre>
nedtool wireless.xml
</pre>
<p>

<p>
</BODY>
</HTML>
<hr><hr><H1><A NAME="sec155"/>4 Simple Modules</H1>
<a name="cha:simple-modules"></a>
<!--module!simple-->

<p>
<i>Simple modules</i> are the active components in the model.
Simple modules are programmed in C++, using the OMNeT++ class
library. The following sections contain a short introduction
to discrete event simulation in general, explain how its concepts are
implemented in OMNeT++, and give an overview and practical advice
on how to design and code simple modules.

<p>

<p><H2><A NAME="sec156"/>4.1 Simulation concepts</H2>

<p>This section contains a very brief introduction into how Discrete
Event Simulation (DES) works, in order to introduce terms we'll use
when explaining OMNeT++ concepts<!--simulation!concepts--> and
implementation.

<p>
<H3><A NAME="sec157"/>4.1.1 Discrete Event Simulation</H3>

<p>A <i>Discrete Event System</i> is a system where state changes
(events<!--events-->) happen at discrete instances in time, and events take zero time
to happen. It is assumed that nothing (i.e. nothing interesting)
happens between two consecutive events, that is, no state change takes
place in the system between the events (in contrast to
<i>continuous</i> systems where state changes are continuous). Those
systems that can be viewed as Discrete Event Systems can be modeled
using Discrete Event Simulation<!--discrete event simulation-->.
(Other systems can be modelled e.g. with continuous simulation models.)

<p>For example, computer networks are usually viewed as discrete
event systems. Some of the events are:

<p><ul>
  <li>start of a packet transmission
  <li>end of a packet transmission
  <li>expiry of a retransmission timeout
</ul>

<p>
This implies that between two events such as <i>start of a packet
transmission</i> and <i>end of a packet transmission</i>, nothing
interesting happens. That is, the packet's state remains <i>being
transmitted</i>. Note that the definition of ``interesting'' events and states always
depends on the intent and purposes of the person doing the modeling.
If we were interested in the transmission of individual bits, we would
have included something like <i>start of bit transmission</i> and
<i>end of bit transmission</i> among our events.

<p>
The time when events occur is often called <i>event timestamp</i>
<!--event timestamp-->; with OMNeT++ we'll say
<i>arrival time</i><!--arrival time--> (because in the class
library, the word ``timestamp'' is reserved for a user-settable
attribute in the event class). Time within the model is often called
<i>simulation time</i><!--simulation time-->, <i>model time</i>
<!--model!time--> or <i>virtual time</i><!--virtual time-->
as opposed to real time<!--real time--> or CPU time<!--CPU time-->
which refer to how long the simulation program has been running and
how much CPU time it has consumed.

<p>

<p><H3><A NAME="sec158"/>4.1.2 The event loop</H3>

<p>Discrete event simulation maintains the set of future
events<!--future events--> in a data structure often called
FES<!--FES--> (Future Event Set) or FEL<!--FEL--> (Future Event List).
Such simulators usually work according to the following pseudocode:

<p><pre>
<i>initialize -- this includes building the model and</i>
              <i>inserting initial events to FES</i>

<i>while (FES not empty and simulation not yet complete)</i>
<i>{</i>
    <i>retrieve first event from FES</i>
    <i>t:= timestamp of this event</i>
    <b><i>process event</i></b>
    <i>(processing may insert new events in FES or delete existing ones)</i>
<i>}</i>
<i>finish simulation (write statistical results, etc.)</i>
</pre>

<p>
The first, initialization step usually builds the data structures
representing the simulation model, calls any user-defined
initialization code, and inserts initial events<!--initial events-->
into the FES<!--FES--> to ensure that the simulation can start. Initialization
strategy can differ considerably from one simulator to another.

<p>
The subsequent loop consumes events from the FES<!--FES--> and processes
them. Events are processed in strict timestamp order in order
to maintain causality, that is, to ensure that no event may have
an effect on earlier events.

<p>Processing an event involves calls to user-supplied code. For example,
using the computer network simulation example, processing a ``timeout
expired'' event may consist of re-sending a copy of the network
packet, updating the retry count, scheduling another ``timeout''
event, and so on. The user code may also remove events from the FES<!--FES-->,
for example when canceling timeouts.

<p>The simulation stops when there are no events left (this happens
rarely in practice), or when it isn't necessary for the simulation
to run further because the model time or the CPU time has reached
a given limit, or because the statistics have reached the desired
accuracy. At this time, before the program exits, the user
will typically want to record statistics into output files.

<p>

<p><H3><A NAME="sec159"/>4.1.3 Simple modules in OMNeT++</H3>
<a name="sec:simple-modules-in-opp"></a>

<p>In OMNeT++, events occur inside simple modules<!--module!simple-->.
Simple modules encapsulate C++ code that generates events and reacts to events,
in other words, implements the behaviour of the model.

<p>The user creates simple module types by subclassing the <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>
class, which is part of the OMNeT++ class library.
<tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>, just as <tt><a href="../api/classcCompoundModule.html">cCompoundModule</a></tt>, is derived
from a common base class, <tt><a href="../api/classcModule.html">cModule</a></tt>.

<p><tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>, although packed with simulation-related
functionality, doesn't do anything useful by itself -- you have
to redefine some virtual member functions to make it do useful work.

<p>
These member functions are the following:
<ul>
  <li>void <tt>initialize()</tt>
  <li>void <tt>handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)</tt>
  <li>void <tt>activity()</tt>
  <li>void <tt>finish()</tt>
</ul>

<p>In the initialization step, OMNeT++ builds the network: it creates the
necessary simple<!--module!simple--> and compound modules and
connects them according to the NED definitions. OMNeT++ also calls the
<tt>initialize()</tt> functions of all modules.

<p>The <tt>handleMessage()</tt> and <tt>activity()</tt> functions are
called during event processing. This means that the user will
implement the model's behavior in these functions.
<tt>handleMessage()</tt> and <tt>activity()</tt> implement
different event processing strategies: for each simple module, the user
has to redefine exactly one of these functions.

<p><tt>handleMessage()</tt> is a method that is called
by the simulation kernel when the module receives a message.
<tt>activity()</tt> is a coroutine-based<!--coroutine--> solution
which implements the process interaction approach (coroutines are
non-preemptive (i.e. cooperative) threads). Generally, it is recommended
that you prefer <tt>handleMessage()</tt> to <tt>activity()</tt> --
mainly because <tt>activity()</tt> doesn't scale well.
Later in this chapter we'll discuss both methods including their advantages
and disadvantages.

<p>Modules written with <tt>activity()</tt> and <tt>handleMessage()</tt>
can be freely mixed within a simulation model.

<p>The <tt>finish()</tt> functions are called when the simulation
terminates successfully. The most typical use of <tt>finish()</tt>
is the recording of statistics collected during simulation.

<p>

<p><H3><A NAME="sec160"/>4.1.4 Events in OMNeT++</H3>

<p>OMNeT++ uses messages<!--message--> to represent
events<!--events-->. Each event is represented by an instance of the
<tt><a href="../api/classcMessage.html">cMessage</a></tt> class or one its subclasses; there is no separate
event class. Messages are sent from one module to another -- this
means that the place where the ``event will occur'' is the
<i>message's destination module</i>, and the model time when the
event occurs is the <i>arrival time</i><!--arrival time--> of the
message. Events like ``timeout expired'' are implemented by the
module sending a message to itself.

<p>Simulation time in OMNeT++ is stored in the C++ type
<tt>simtime_t</tt>, which is a typedef for <tt>double</tt>.

<p>Events are consumed from the FES<!--FES--> in arrival time order, to
maintain causality. More precisely, given two messages, the following
rules apply:
<ol>
<li>the message with <b>earlier arrival time</b> is executed
    first.  If arrival times are equal,
<li>the one with <b>smaller priority value</b> is executed first.
    If priorities are the same,
<li>the one <b>scheduled or sent earlier</b> is executed first.
</ol>

<p><i>Priority</i><!--message!priority--> is a user-assigned integer
attribute of messages.

<p>Storing simulation time in doubles may sometimes cause inconveniences.
Due to finite machine precision, two doubles calculated in two
different ways do not always compare equal even if they mathematically
should be. For example, addition is not an associative operation
when it comes to floating point calculations: <i>(x+y)+z != x+(y+z)</i>!
(See~[<a href="#bib-Goldberg91what">Goldberg91what</a>]).
This means that it is generally not a good idea to rely on
arrival times of two events being the same unless they are
calculated in exactly the same way.

<p>One may suggest introducing a small <i>simtime_precision</i> parameter in
the simulation kernel that would force <i>t<sub>1</sub></i> and <i>t<sub>2</sub></i> to be regarded
equal if they are ``very close'' (if they differ
less than <i>simtime_precision</i>). This approach, however, would
be more likely to cause confusion than actually cure the problem.


<H3><A NAME="sec161"/>4.1.5 FES implementation</H3>

<p>The implementation of the FES<!--FES--> is a crucial factor in the
performance of a discrete event simulator. In OMNeT++, the FES is
implemented with <i>binary heap</i><!--binary heap-->, the most
widely used data structure for this purpose. Heap is also the best
algorithm we know, although exotic data structures like
<i>skiplist</i><!--skiplist--> may perform better than heap in some
cases. In case you're interested, the FES implementation is in the
<tt><a href="../api/classcMessageHeap.html">cMessageHeap</a></tt> class, but as a simulation programmer you won't
ever need to care about that.

<p>

<p>

<p><H2><A NAME="sec162"/>4.2 Packet transmission modeling</H2>
<a name="ch:simple-modules:packet-transmission"></a>

<p><H3><A NAME="sec163"/>4.2.1 Delay, bit error rate, data rate</H3>

<p>Connections can be assigned three parameters, which facilitate
the modeling of communication networks, but can be useful for
other models too:
<ul>
  <li>propagation delay (sec)<!--channel!delay-->
  <li>bit error rate (errors/bit)<!--channel!error-->
  <li>data rate (bits/sec)<!--channel!datarate-->
</ul>

<p>
Each of these parameters is optional. One can specify link parameters
individually for each connection, or define link types (also
called <i>channel</i> <i>types</i>) once and use them throughout the
whole model.

<p>The <i>propagation delay</i> is the amount of time the arrival of
the message is delayed by when it travels through the channel.
Propagation delay is specified in seconds.

<p>The <i>bit error rate</i> has influence on the transmission of messages
through the channel. The bit error rate (<i>ber</i>) is the probability that
a bit is incorrectly transmitted. Thus, the probability that
a message of <i>n</i> bits length is transferred without bit errors is:<br>

<p><i>P<sub>no bit error</sub> = (1 - ber)<sup>length</sup></i>

<p>The message has an error flag which is set in case of transmission
errors.

<p>The <i>data rate</i> is specified in bits/second, and it is used
for transmission delay calculation. The sending time of the message
normally corresponds to the transmission of the first bit, and
the arrival time of the message corresponds to the reception
of the last bit (Fig. <a href="#fig:ch-overview:message-transm">below</a>).

<p>
<div align=center>
<img src="usmanFig4.gif">
<center><i>Figure: Message transmission</i></center>
<a name="fig:ch-overview:message-transm"></a>
</div>

<p>
The above model may not be suitable to model all protocols. In Token Ring
and FDDI, stations start to repeat bits before the whole frame arrives;
in other words, frames ``flow through'' the stations, being delayed only a few bits.
In such cases, the data rate modeling feature of OMNeT++ cannot be used.

<p>If a message travels along a route, passing through successive links and
compound modules, the model behaves as if each module waited until the
last bit of the message arrives and only started its transmission
afterwards.
(Fig. <a href="#fig:ch-overview:msg-multiple-ch">below</a>).

<p>
<div align=center>
<img src="usmanFig5.gif">
<center><i>Figure: Message sending over multiple channels</i></center>
<a name="fig:ch-overview:msg-multiple-ch"></a>
</div>

<p>
Since the above effect is usually not the desired one, typically
you will want to assign data rate to only one connection in the
route.

<p>

<p><H3><A NAME="sec164"/>4.2.2 Multiple transmissions on links</H3>

<p>
If a data rate<!--data rate--> is specified for a connection, a message
will have a certain nonzero transmission time<!--transmission
  time-->, depending on the length of the connection. This implies that
a message that is passsing through an output gate, ``reserves'' the gate
for a given period (``it is being transmitted'').

<p>
  <div align=center>
    <img src="usmanFig9.gif">
    <center><i>Figure: Connection with a data rate</i></center>
    <a name="fig:ch-simple-modules:conn-w-data-rate"></a>
  </div>

<p>
While a message is under transmission, other messages have to wait
until the transmission is completed. You can still send messages
while the gate is busy, but the beginning of the modeled
message transmission will be delayed, just as if the gate had
an internal queue for the messages waiting to be transmitted.

<p>The OMNeT++ class library provides functions to check
whether a certain output gate is transmitting or to learn when
it finishes transmission.

<p>If the connection with a data rate is not directly connected
to the simple module's output gate but is the second
one in the route, you have to check the second gate's busy
condition<!--gate!busy condition-->.

<p>
<p class="subheading">Implementation of message sending</p>

<p>
Message sending is implemented like this: the arrival
time<!--arrival time--> and the bit error<!--bit error--> flag of a
message are calculated immediately after the <tt>send()</tt> (or a similar)
function is invoked. That is, if the message travels through several
links before it reaches its destination, it is <i>not</i> scheduled
individually for each link, but rather, every calculation is done
once, within the <tt>send()</tt> call. This implementation was chosen
because of its run-time efficiency.

<p>In the actual implementation of queuing the messages at busy gates and
modeling the transmission delay, messages do not actually queue up in
gates; gates do not have internal queues. Instead, as the time when
each gate will finish transmission is known at the time of sending the
message, the arrival time<!--arrival time--> of the message can be
calculated in advance. Then the message will be stored in the event
queue (FES)<!--FES--> until the simulation time advances to its
arrival time and it is retrieved by its destination module.



<p><p class="subheading">Consequence</p>

<p>
The implementation has the following consequence. If you change the
delay (or the bit error rate, or the data rate) of a link<!--link
  delay--> during simulation, the modeling of messages sent ``just
before'' the parameter change will not be accurate. Namely, if link
parameters change while a message is ``under way'' in the model, that
message will not be affected by the parameter change, although it
should. However, all subsequent messages will be modelled correctly.
Similar for data rate: if a data rate changes during the simulation,
the change will affect only the messages that are <i>sent</i> after
the change.

<p>If it is important to model gates and channels with changing
properties, you can chose one of two paths:
<ul>
  <li>write a sender module such that it schedules events for when the
    gate finishes its current transmission and sends then;
  <li>alternatively, you can implement channels with
    simple modules (``active channels'').
</ul>

<p>
<p class="subheading">The approach of some other simulators</p>

<p>
Note that some simulators (e.g. OPNET) assign <i>packet queues</i>
to input gates (ports), and messages sent are buffered at the
destination module (or the remote end of the link) until they are
received by the destination module. With that approach, events and
messages are separate entities, that is, a <i>send</i> operation
includes placing the message in the packet queue <i>and</i> scheduling
an event, which signals the arrival of the packet. In some implementations,
output gates also have packet queues where packets will be buffered until
the channel is ready (available for transmission).

<p>OMNeT++ gates<!--gate--> don't have associated queues. The place
where sent but not yet received messages are buffered in the
FES<!--FES-->.  OMNeT++'s approach is potentially faster
than the solution mentioned above because it doesn't have the
enqueue/dequeue overhead and also spares an event creation. The
drawback is, that changes to channel parameters do not take effect
immediately.

<p>In OMNeT++ one can implement <i>point-to-point transmitter</i> modules
with packet queues if needed. For example, the INET Framework
follows this approach.

<p>

<p>
<H2><A NAME="sec165"/>4.3 Defining simple module types</H2>

<p><H3><A NAME="sec166"/>4.3.1 Overview</H3>

<p>As mentioned before <a href="#sec159">[4.1.3]</a>, a simple module<!--module!simple-->
is nothing more than a C++ class which has to be subclassed from
<tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>, with one or more virtual member functions redefined
to define its behavior.

<p>The class has to be registered with OMNeT++ via the <tt>Define_Module()</tt> macro.
The <tt>Define_Module()</tt> line should always be put into <tt>.cc</tt> or <tt>.cpp</tt>
files and not header file (<tt>.h</tt>), because the compiler generates code from it.
      <br><ul><font size=-1>[For completeness, there is also a <tt>Define_Module_Like()</tt>
                macro, but its use is discouraged and might even be removed in
                future OMNeT++ releases.]</font></ul>

<p>The following <tt>HelloModule</tt> is about the simplest simple module one could write.
(We could have left out the <tt>initialize()</tt> method as well to make it even smaller,
but how would it say Hello then?) Note <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt> as base class,
and the <tt>Define_Module()</tt> line.

<pre>
// file: HelloModule.cc
#include &lt;omnetpp.h&gt;

class HelloModule : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
};

// register module class with OMNeT++
Define_Module(HelloModule);

void HelloModule::initialize()
{
    ev &lt;&lt; "Hello World!\n";
}

void HelloModule::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    delete msg; // just discard everything we receive
}
</pre>
<p>
In order to be able to refer to this simple<!--module!simple--> module type
in NED files, we also need an associated NED declaration which might
look like this:

<p><pre>
// file: HelloModule.ned
<b>simple</b> HelloModule
    <b>gates</b>:
        <b>in:</b> in;
<b>endsimple</b>
</pre>

<p>
<H3><A NAME="sec167"/>4.3.2 Constructor</H3>

<p>Simple modules are never instantiated by the user directly, but rather by
the simulation kernel. This implies that one cannot write arbitrary
constructors: the signature must be what is expected by the simulation kernel.
Luckily, this contract is very simple: the constructor must be public, and must take
no arguments:

<pre>
  public:
    HelloModule();  // constructor takes no arguments
</pre>
<p>
<tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt> itself has two constructors:
<ol>
  <li><tt><a href="../api/classcSimpleModule.html">cSimpleModule</a>()</tt> -- one without arguments
  <li><tt><a href="../api/classcSimpleModule.html">cSimpleModule</a>(size_t stacksize)</tt> -- one that accepts the coroutine
        stack size<!--module!stack size--><!--stack!size-->
</ol>

<p>The first version should be used with <tt>handleMessage()</tt> simple modules,
and the second one with <tt>activity()</tt> modules.
(With the latter, the <tt>activity()</tt> method of the module class
runs as a coroutine<!--coroutine--> which needs a separate CPU stack,
usually of 16..32K. This will be discussed in detail later.)
Passing zero stack size to the latter constructor also selects <tt>handleMessage()</tt>.

<p>Thus, the following constructor definitions are all OK, and select
<tt>handleMessage()</tt> to be used with the module:

<pre>
HelloModule::HelloModule() {...}
HelloModule::HelloModule() : <a href="../api/classcSimpleModule.html">cSimpleModule</a>() {...}
</pre>
<p>
It is also OK to omit the constructor altogether, because the
compiler-generated one is suitable too.

<p>The following constructor definition selects <tt>activity()</tt> to be used
with the module, with 16K of coroutine stack:

<pre>
HelloModule::HelloModule() : <a href="../api/classcSimpleModule.html">cSimpleModule</a>(16384) {...}
</pre>
<p>

<p><H3><A NAME="sec168"/>4.3.3 Constructor and destructor vs initialize() and finish()</H3>

<p>The <tt>initialize()</tt> and <tt>finish()</tt> methods will be discussed
in a later section in detail, but because their apparent similarity
to the constructor and the destructor is prone to cause some confusion,
we'll briefly cover them here.

<p>The constructor gets called when the module is created, as part of the
model setup process. At that time, everything is just being built,
so there isn't a lot things one can do from the constructor.
In contrast, <tt>initialize()</tt> gets called just before the
simulation starts executing, when everything else has been set up
already.

<p><tt>finish()</tt> is for recording statistics, and it only gets called
when the simulation has terminated normally. It does not get called when
the simulations stops with an error message. The destructor always
gets called at the end, no matter how the simulation stopped, but
at that time it is fair to assume that the simulation model has been
halfway demolished already.

<p>Based on the above, the following conventions exist for these four methods:

<p><b>Constructor conventions:</b>

<p>Set pointer members of the module class to <tt>NULL</tt>; postpone all other
initialization tasks to <tt>initialize()</tt>.

<p><b><tt>initialize()</tt> conventions:</b>

<p>Perform all initialization tasks: read module parameters, initialize
class variables, allocate dynamic data structures with <tt>new</tt>;
also allocate and initialize self-messages (timers) if needed.

<p><b><tt>finish()</tt> conventions:</b>

<p>Record statistics. Do <b>not</b> <tt>delete</tt> anything or cancel timers --
all cleanup must be done in the destructor.

<p><b>destructor conventions:</b>

<p>Delete everything which was allocated by <tt>new</tt> and is still held
by the module class. With self-messages (timers), use the
<tt>cancelAndDelete(msg)</tt> function! It is almost always wrong
to just delete a self-message from the destructor, because it might be
in the scheduled events list. The <tt>cancelAndDelete(msg)</tt> function
checks for that first, and cancels the message before deletion if necessary.

<p>
<H3><A NAME="sec169"/>4.3.4 Compatibility with earlier versions</H3>

<p>OMNeT++ versions earlier than 3.2 expected a different module class
constructor, with the following signature:

<pre>
MyModule(const char *name, <a href="../api/classcModule.html">cModule</a> *parentModule, size_t stack=&lt;stacksize&gt;);
</pre>
<p>
For convenience, a macro named <tt>Module_Class_Members()</tt> was also
provided, which expanded to a default (i.e. do-nothing) constructor implementation.

<p>In OMNeT++ 3.2, the <tt>Module_Class_Members()</tt> macro has been retained
but expands to the new constructor definition. Thus a module which uses
<tt>Module_Class_Members()</tt> does not need to be changed to work with
OMNeT++ 3.2 or later. When compatiblity with older versions is no longer
required, the macro call can simply be deleted.

<p>Some (few) modules have hand-coded constructors instead of using
<tt>Module_Class_Members()</tt>. These modules will produce a compile
error with OMNeT++ 3.2 or later, saying <i>no appropriate constructor
available</i>. The easiest way to get them working is to add <tt>=NULL</tt>
default value to both the <tt>name</tt> and the <tt>parentModule</tt> arguments:

<pre>
MyModule(const char *name=NULL, <a href="../api/classcModule.html">cModule</a> *parentModule=NULL, size_t stack=&lt;stacksize&gt;);
</pre>
<p>
Again, when compatibility with older OMNeT++ versions is no longer required,
the redundant constructor arguments can be removed.

<p>
<H3><A NAME="sec170"/>4.3.5 "Garbage collection" and compatibility</H3>
<a name="sec:garbage-collection"></a>

<p>OMNeT++ versions before the 3.2 release had a feature which often was,
informally and also somewhat incorrectly, called <i>"garbage
collection"</i> (GC). The purpose of this feature was to mitigate the need for
writing destructors, and often constructors as well by providing automatic
cleanup at the end of the simulation. (It did not do anything during
simulation, as the name might suggest.)

<p>OMNeT++ (all versions) keep track of user-allocated simulation objects
(typically: messages) and their ownerships. What the <i>"garbage
collection"</i> feature did was that during the cleanup of the model, after
each module destructor finished, it checked whether there were simulations
objects left that were apparently owned by that module but not deallocated
by the destructor -- and if it found such objects, it invoked <tt>delete</tt>
on them.

<p>It worked out nicely in 90 percent of cases, but occasionally it resulted
in spurious crashes which were hard to debug for users not familiar
with OMNeT++ internals or lacking advanced C++ skills.
    <br><ul><font size=-1>[These crashes occurred due to lack of information available
              to the GC mechanism, e.g. C++ provides no way to detect
              from the pointer whether an object is part of an array, or is
              inside a struct or class. The solution was to use pointers:
              pointer array, pointer as class member, etc.]</font></ul>

<p>Starting from OMNeT++ 3.2, this cleanup-time GC mechanism has been disabled by default
(<tt>perform-gc=</tt> configuration option, see <a href="#sec296">[8.2.6]</a>),
and it generally not recommended to turn it back on. It does not do any harm
to run any simulation model without GC (apart from the memory leak).

<p>It is expected that existing modules will be updated for OMNeT++ 3.2 sooner
or later, by adding proper constructors and destructors. To catalyse this
process, OMNeT++ dumps the list of unreleased objects at the end of the
simulation. This dump can also be turned off in the configuration
(<tt>print-undisposed=</tt> configuration option, see <a href="#sec296">[8.2.6]</a>).

<p>
<H3><A NAME="sec171"/>4.3.6 An example</H3>

<p>The following code is a bit longer but actually useful simple module
implementation. It demonstrates several of the above concepts, plus
some others which will be explained in later sections:
<ol>
  <li>constructor, initialize and destructor conventions
  <li>using messages for timers
  <li>accessing module parameters
  <li>recording statistics at the end of the simulation
  <li>documenting the programmer's assumptions using ASSERT()
</ol>

<pre>
// file: FFGenerator.h

#include &lt;omnetpp.h&gt;

/**
 * Generates messages or jobs; see NED file for more info.
 */
class FFGenerator : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  private:
    <a href="../api/classcMessage.html">cMessage</a> *sendMessageEvent;
    long numSent;

  public:
    FFGenerator();
    virtual ~FFGenerator();

  protected:
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
    virtual void finish();
};
</pre>
<p>
<pre>
// file: FFGenerator.cc

#include "FFGenerator.cc"

// register module class with OMNeT++
Define_Module(FFGenerator);

FFGenerator::FFGenerator()
{
    sendMessageEvent = NULL;
}

void FFGenerator::initialize()
{
    numSent = 0;
    sendMessageEvent = new <a href="../api/classcMessage.html">cMessage</a>("sendMessageEvent");
    scheduleAt(0.0, sendMessageEvent);
}

void FFGenerator::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    ASSERT(msg==sendMessageEvent);

    <a href="../api/classcMessage.html">cMessage</a> *m = new <a href="../api/classcMessage.html">cMessage</a>("packet");
    m-&gt;setLength(par("msgLength"));
    send(m, "out");
    numSent++;

    double deltaT = (double)par("sendIaTime");
    scheduleAt(simTime()+deltaT, sendMessageEvent);
}

void FFGenerator::finish()
{
    recordScalar("packets sent", numSent);
}

FFGenerator::~FFGenerator()
{
    cancelAndDelete(sendMessageEvent);
}
</pre>

<p>It also needs a NED declaration to be able to use it in NED files:

<p><pre>
// file: FFGenerator.ned
<b>simple</b> FFGenerator
    <b>parameters</b>:
        sendIaTime: <b>numeric</b>;
    <b>gates</b>:
        <b>out:</b> out;
<b>endsimple</b>
</pre>

<p>

<p>
<H3><A NAME="sec172"/>4.3.7 Using global variables</H3>
<!--global variables-->

<p>If possible, avoid using global variables, including
static class members. They are prone to cause several problems.
First, they are not reset to their initial values (to zero)
when you rebuild the simulation in Tkenv, or start another run
in Cmdenv. This may produce surprising results.
Second, they prevent you from running your simulation in parallel.
When using parallel simulation, each partition of your model
(may) run in a separate process, having its own copy of the
global variables. This is usually not what you want.

<p>The solution is to encapsulate the variables into simple modules
as private or protected data members, and expose them via public methods.
Other modules can then call these public methods to get or set the values.
Calling methods of other modules will be discussed in section
<a href="#sec197">[4.10]</a>.
Examples of such modules are the <tt>Blackboard</tt> in the <i>Mobility Framework</i>,
and <tt>InterfaceTable</tt> and <tt>RoutingTable</tt> in the <i>INET Framework</i>.

<p>

<p><H2><A NAME="sec173"/>4.4 Adding functionality to <a href="../api/classcSimpleModule.html">cSimpleModule</a></H2>

<p>This section discusses <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>'s four previously
mentioned member functions, intended to be redefined by the user:
<tt>initialize()</tt>, <tt>handleMessage()</tt>, <tt>activity()</tt>
and <tt>finish()</tt>, plus a fifth, less frequently used one,
<tt>handleParameterChange</tt>.

<p>

<p><H3><A NAME="sec174"/>4.4.1 handleMessage()</H3>

<p><p class="subheading">Function called for each event</p>

<p>
The idea is that at each event<!--event--> (message arrival) we
simply call a user-defined function. This function,
<tt>handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)</tt> is a
virtual member function of <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt> which does
nothing by default -- the user has to redefine it in subclasses
and add the message processing code.

<p>The <tt>handleMessage()</tt> function will be called for every message
that arrives at the module. The function should process the message
and return immediately after that. The simulation time is potentially
different in each call. No simulation time elapses within a call
to <tt>handleMessage()</tt>.

<p>The event loop inside the simulator handles both <tt>activity()</tt>
and <tt>handleMessage()</tt> simple modules, and it corresponds
to the following pseudocode:

<p><pre>
<i>while (FES not empty and simulation not yet complete)</i>
{
    retrieve first event from FES
    t:= timestamp of this event
    m:= module containing this event
    if (m works with handleMessage())
        <b>m-&gt;handleMessage( event )</b>
    else // m works with activity()
        transferTo( m )
}
</pre>

<p>Modules with <tt>handleMessage()</tt> are NOT started automatically:
the simulation kernel creates starter messages<!--starter messages-->
only for modules with <tt>activity()</tt>. This means that you have to
schedule self-messages<!--self-message--> from the
<tt>initialize()</tt> function if you want a <tt>handleMessage()</tt>
simple module to start working ``by itself'', without first receiving
a message from other modules.

<p>
<p class="subheading">Programming with handleMessage()</p>

<p>
To use the <tt>handleMessage()</tt> mechanism in a
simple module, you must specify <i>zero
  stack size</i><!--zero stack size--> for the module. This is
important, because this tells OMNeT++ that you want to use
<tt>handleMessage()</tt> and not <tt>activity()</tt>.

<p>Message/event related functions you can use in <tt>handleMessage()</tt>:

<p><ul>
  <li><tt>send()</tt> family of functions -- to send messages to other modules
  <li><tt>scheduleAt()</tt> -- to schedule an event (the module ``sends a message to itself'')
  <li><tt>cancelEvent()</tt> -- to delete an event scheduled with <tt>scheduleAt()</tt>
</ul>

<p>You cannot use the <tt>receive()</tt> family and
<tt>wait()</tt> functions in <tt>handleMessage()</tt>, because they are
coroutine-based by nature, as explained in the section about
<tt>activity()</tt>.

<p>You have to add data members to the module class for every piece
of information you want to preserve. This information cannot
be stored in local variables of <tt>handleMessage()</tt> because they
are destroyed when the function returns. Also, they cannot be
stored in static variables in the function (or the class), because
they would be shared between all instances of the class.

<p>
Data members to be added to the module class will typically include
things like:

<p><ul>
  <li>state (e.g. IDLE/BUSY, CONN_DOWN/CONN_ALIVE/...)
  <li>other variables which belong to the state of the module: retry
    counts, packet queues, etc.
  <li>values retrieved/computed once and then stored: values of module
    parameters, gate indices, routing information, etc.
  <li>pointers of message objects created once and then reused for
    timers, timeouts, etc.
  <li>variables/objects for statistics collection
</ul>

<p>You can initialize these variables from the <tt>initialize()</tt>
function.  The constructor<!--module!constructor--> is not a very good place
for this purpose, because it is called in the network setup phase when
the model is still under construction, so a lot of information you may
want to use is not yet available.

<p>Another task you have to do in <tt>initialize()</tt> is to schedule
initial event(s)<!--events!initial--> which trigger the first call(s)
to <tt>handleMessage()</tt>.  After the first call,
<tt>handleMessage()</tt> must take care to schedule further events for
itself so that the ``chain'' is not broken. Scheduling events is not
necessary if your module only has to react to messages coming from
other modules.

<p><tt>finish()</tt> is normally used to record statistics information
accumulated in data members of the class at the end of the simulation.

<p>
<p class="subheading">Application area</p>

<p>
<tt>handleMessage()</tt> is in most cases a better choice than <tt>activity()</tt>:

<p><ol>
  <li>When you expect the module to be used in large simulations,
      involving several thousand modules. In such cases, the module stacks
      required by <tt>activity()</tt> would simply consume too much memory.
  <li>For modules which maintain little or no state information,
      such as packet sinks, <tt>handleMessage()</tt> is more convenient to program.
  <li>Other good candidates are modules with a large state space and
      many arbitrary state transition possibilities (i.e. where there
      are many possible subsequent states for any state). Such algorithms
      are difficult to program with <tt>activity()</tt>, or the result is code
      which is better suited for <tt>handleMessage()</tt> (see rule of thumb
      below). Most communication protocols are like this.
</ol>

<p>
<p class="subheading">Example 1: Protocol models</p>

<p>Models of protocol layers in a communication network tend to have
a common structure on a high level because fundamentally they all have to react
to three types of events: to messages arriving from higher layer protocols
(or apps), to messages arriving from lower layer protocols (from the network),
and to various timers and timeouts (that is, self-messages).

<p>This usually results in the following source code pattern:

<pre>
class FooProtocol : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    // state variables
    // ...

    virtual void processMsgFromHigherLayer(<a href="../api/classcMessage.html">cMessage</a> *packet);
    virtual void processMsgFromLowerLayer(FooPacket *packet);
    virtual void processTimer(<a href="../api/classcMessage.html">cMessage</a> *timer);

    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
};

// ...

void FooProtocol::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    if (msg-&gt;isSelfMessage())
        processTimer(msg);
    else if (msg-&gt;arrivedOn("fromNetw"))
        processMsgFromLowerLayer(check_and_cast&lt;FooPacket *&gt;(msg));
    else
        processMsgFromHigherLayer(msg);
}
</pre>
<p>
The functions <tt>processMsgFromHigherLayer()</tt>, <tt>processMsgFromLowerLayer()</tt>
and <tt>processTimer()</tt> are then usually split further: there are separate
methods to process separate packet types and separate timers.

<p>
<p class="subheading">Example 2: Simple traffic generators and sinks</p>

<p>
The code for simple packet generators and sinks programmed with <tt>handleMessage()</tt> might
be as simple as the following pseoudocode:

<pre>
PacketGenerator::handleMessage(msg)
{
    create and send out a new packet;
    schedule msg again to trigger next call to handleMessage;
}

PacketSink::handleMessage(msg)
{
    delete msg;
}
</pre>
<p>
Note that <i>PacketGenerator</i> will need to redefine <tt>initialize()</tt>
to create <i>m</i> and schedule the first event.

<p>The following simple module generates packets with exponential
inter-arrival time. (Some details in the source haven't been
discussed yet, but the code is probably understandable nevertheless.)

<p>
<pre>
class Generator : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  public:
    Generator() : <a href="../api/classcSimpleModule.html">cSimpleModule</a>() 
  protected:
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
};

Define_Module(Generator);

void Generator::initialize()
{
    // schedule first sending
    scheduleAt(simTime(), new <a href="../api/classcMessage.html">cMessage</a>);
}

void Generator::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    // generate & send packet
    <a href="../api/classcMessage.html">cMessage</a> *pkt = new <a href="../api/classcMessage.html">cMessage</a>;
    send(pkt, "out");
    // schedule next call
    scheduleAt(simTime()+exponential(1.0), msg);
}
</pre>

<p>

<p><p class="subheading">Example 3: Bursty traffic generator</p>

<p>
A bit more realistic example is to rewrite our Generator to create
packet bursts, each consisting of <tt>burstLength</tt> packets.

<p>We add some data members to the class:
<ul>
<li><tt>burstLength</tt> will store the parameter that specifies how many
    packets a burst must contain,
<li><tt>burstCounter</tt> will count in how many packets are left to be sent
    in the current burst.
</ul>

<p>The code:

<p><pre>
class BurstyGenerator : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    int burstLength;
    int burstCounter;

    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
};

Define_Module(BurstyGenerator);

void BurstyGenerator::initialize()
{
    // init parameters and state variables
    burstLength = par("burstLength");
    burstCounter = burstLength;
    // schedule first packet of first burst
    scheduleAt(simTime(), new <a href="../api/classcMessage.html">cMessage</a>);
}

void BurstyGenerator::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    // generate & send packet
    <a href="../api/classcMessage.html">cMessage</a> *pkt = new <a href="../api/classcMessage.html">cMessage</a>;
    send(pkt, "out");
    // if this was the last packet of the burst
    if (--burstCounter == 0)
    {
        // schedule next burst
        burstCounter = burstLength;
        scheduleAt(simTime()+exponential(5.0), msg);
    }
    else
    {
        // schedule next sending within burst
        scheduleAt(simTime()+exponential(1.0), msg);
    }
}
</pre>

<p>

<p><p class="subheading">Pros and Cons of using <tt>handleMessage()</tt></p>

<p>
Pros:
<ul>
  <li>consumes less memory: no separate stack needed for simple modules
  <li>fast: function call is faster than switching between coroutines<!--coroutine-->
</ul>

<p>Cons:
<ul>
  <li>local variables cannot be used to store state information
  <li>need to redefine <tt>initialize()</tt>
</ul>

<p>Usually, <tt>handleMessage()</tt> should be preferred to <tt>activity()</tt>.

<p>
<p class="subheading">Other simulators</p>

<p>
Many simulation packages use a similar approach, often topped with
something like a state machine<!--finite state machine-->
(FSM<!--FSM-->) which hides the underlying function calls. Such
systems are:
<ul>
  <li>OPNET<i><sup>TM</sup></i> which uses FSM's designed using a graphical editor;
  <li>NetSim++ clones OPNET's approach;
  <li>SMURPH (University of Alberta) defines a (somewhat eclectic)
      language to describe FSMs, and uses a precompiler to turn it
      into C++ code;
  <li>Ptolemy (UC Berkeley) uses a similar method.
</ul>

<p>OMNeT++'s FSM<!--FSM--> support is described in the next section.

<p>

<p><H3><A NAME="sec175"/>4.4.2 activity()</H3>

<p><p class="subheading">Process-style description</p>

<p>With <tt>activity()</tt>, you can code the simple
module much like you would code an operating system process or a
thread. You can wait for an incoming message (event) at any point of
the code, you can suspend the execution for some time (model time!),
etc. When the <tt>activity()</tt> function exits, the module is
terminated.  (The simulation can continue if there are other modules
which can run.)

<p>
The most important functions you can use in <tt>activity()</tt> are
(they will be discussed in detail later):
<ul>
<li><tt>receive()</tt> -- to receive messages (events)
<li><tt>wait()</tt> -- to suspend execution<!--suspend execution-->
    for some time (model time)
<li><tt>send()</tt> family of functions -- to send messages to other
    modules
<li><tt>scheduleAt()</tt> -- to schedule an event (the module ``sends
    a message to itself'')
<li><tt>cancelEvent()</tt> -- to delete an event scheduled with
    scheduleAt()
<li><tt>end()</tt> -- to finish execution of this module (same as
    exiting the <tt>activity()</tt> function)
</ul>

<p>The <tt>activity()</tt> function normally contains an infinite loop,
with at least a <tt>wait()</tt> or <tt>receive()</tt> call in its body.

<p>

<p><p class="subheading">Application area</p>

<p>Generally you should prefer <tt>handleMessage()</tt> to <tt>activity()</tt>.
The main problem with <tt>activity()</tt> is that it doesn't scale because
every module needs a separate coroutine stack. It has also been observed
that <tt>activity()</tt> does not encourage a good programming style.

<p>There is one scenario where <tt>activity()</tt>'s process-style
description is convenient: when the process has many
states but transitions are very limited, ie. from any state the
process can only go to one or two other states.  For example, this is
the case when programming a network application, which uses a single
network connection.  The pseudocode of the application which talks to
a transport layer protocol might look like this:

<p><pre>
<i>activity()</i>
{
    while(true)
    {
        open connection by sending OPEN command to transport layer
        receive reply from transport layer
        if (open not successful)
        {
            wait(some time)
            continue // loop back to while()
        }

        while(there's more to do)
        {
            send data on network connection
            if (connection broken)
            {
                continue outer loop // loop back to outer while()
            }
            wait(some time)
            receive data on network connection
            if (connection broken)
            {
                continue outer loop // loop back to outer while()
            }
            wait(some time)
        }
        close connection by sending CLOSE command to transport layer
        if (close not successful)
        {
            // handle error
        }
        wait(some time)
    }
}
</pre>

<p>If you have to handle several connections simultaneously, you may
dynamically create them as instances of the simple module above.
Dynamic module creation will be discussed later.

<p>There are situations when you certainly <i>do not want</i> to use <tt>activity()</tt>.
If your <tt>activity()</tt> function contains no <tt>wait()</tt> and it has
only one <tt>receive()</tt> call at the top of an infinite loop,
there's no point in using <tt>activity()</tt> and the code should be written
with <tt>handleMessage()</tt>.
The body of the infinite loop would then become the body to <tt>handleMessage()</tt>,
state variables inside <tt>activity()</tt> would become data members in
the module class, and you'd initialize them in <tt>initialize()</tt>.

<p>Example:

<pre>
void Sink::activity()
{
    while(true)
    {
        msg = receive();
        delete msg;
    }
}
</pre>
<p>
should rather be programmed as:

<pre>
void Sink::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    delete msg;
}
</pre>
<p>

<p>
<p class="subheading">Activity() is run as a coroutine</p>

<p>
<tt>activity()</tt> is run in a coroutine<!--coroutine-->.
Coroutines are a sort of threads which are scheduled
non-preemptively (this is also called cooperative
multitasking<!--multitasking!cooperative-->). From one coroutine you
can switch to another coroutine by a
<tt>transferTo(otherCoroutine)</tt> call. Then this
coroutine is suspended and <i>otherCoroutine</i> will run. Later,
when <i>otherCoroutine</i> does a
<tt>transferTo(firstCoroutine)</tt> call, execution of
the first coroutine will resume from the point of the
<tt>transferTo(otherCoroutine)</tt> call.  The full state
of the coroutine, including local variables are preserved while the
thread of execution is in other coroutines.  This implies that each
coroutine must have its own processor stack<!--stack-->, and
<tt>transferTo()</tt> involves a switch from one processor stack to
another.

<p>
Coroutines<!--coroutine--> are at the heart of OMNeT++, and the
simulation programmer doesn't ever need to call <tt>transferTo()</tt>
or other functions in the coroutine library, nor does he need to care
about the coroutine library implementation. It is important to
understand, however, how the event loop found in discrete event simulators
works with coroutines.

<p>
When using coroutines, the event loop<!--event loop--> looks like
this (simplified):

<p>
<pre>
<i>while (FES not empty and simulation not yet complete)</i>
{
    retrieve first event from FES
    t:= timestamp of this event
    <b>transferTo(module containing the event)</b>
}
</pre>

<p>

<p>That is, when the module has an event<!--event-->, the simulation
kernel transfers the control to the module's coroutine. It is expected
that when the module ``decides it has finished the processing of the
event'', it will transfer the control back to the simulation kernel by
a <tt>transferTo(main)</tt> call. Initially,
simple<!--module!simple--> modules using <tt>activity()</tt> are
``booted'' by events (<i>''starter messages''</i><!--starter messages-->)
inserted into the FES<!--FES--> by the simulation kernel before the
start of the simulation.

<p>
How does the coroutine know it has ``finished processing the event''?
The answer: <i>when it requests another event</i>.  The functions
which request events from the simulation kernel are the
<tt>receive()</tt> and <tt>wait()</tt>, so their
implementations contain a <tt>transferTo(main)</tt> call
somewhere.

<p>
Their pseudocode, as implemented in OMNeT++:

<p>
<pre>
receive()
{
    transferTo(main)
    retrieve current event
    return the event // remember: events = messages
}

wait()
{
    create event e
    schedule it at (current sim. time + wait interval)
    transferTo(main)
    retrieve current event
    if (current event is not e) {
        error
    }
    delete e  // note: actual impl. reuses events
    return
}
</pre>

<p>

<p>Thus, the <tt>receive()</tt> and <tt>wait()</tt> calls are
special points in the <tt>activity()</tt> function, because
they are where

<p><ul>
  <li>simulation time elapses in the module, and
  <li>other modules get a chance to execute.
</ul>

<p>
<p class="subheading">Starter messages</p>

<p>
Modules written with <tt>activity()</tt> need starter
messages<!--starter messages--> to ``boot''.  These starter messages
are inserted into the FES<!--FES--> automatically by OMNeT++ at the
beginning of the simulation, even before the <tt>initialize()</tt>
functions are called.

<p>
<p class="subheading">Coroutine stack size</p>

<p>
The simulation programmer needs to define the processor stack size<!--coroutine!stack size-->
for coroutines. This cannot be automated.

<p>16 or 32 kbytes is usually a good choice, but you may need more if the
module uses recursive functions or has local variables, which occupy a
lot of stack space. OMNeT++ has a built-in mechanism that will usually
detect if the module stack is too small and overflows<!--stack!overflow-->.
OMNeT++ can also tell you how much stack space a module actually uses<!--stack!usage-->,
so you can find out if you overestimated the stack needs.

<p>
<p class="subheading">initialize() and finish() with activity()</p>

<p>
Because local variables of <tt>activity()</tt> are preserved across
events, you can store everything (state information, packet buffers,
etc.) in them. Local variables can be initialized at the top of the
<tt>activity()</tt> function, so there isn't much need to use
<tt>initialize()</tt>.

<p>
You do need <tt>finish()</tt>, however, if you want to write statistics at
the end of the simulation. Because <tt>finish()</tt> cannot access
the local variables of <tt>activity()</tt>, you have to put the variables
and objects containing the statistics into the module class.
You still don't need <tt>initialize()</tt> because class members can also
be initialized at the top of <tt>activity()</tt>.

<p>
Thus, a typical setup looks like this in pseudocode:

<p>
<pre>
<i>class MySimpleModule...</i>
{
    ...
    variables for statistics collection
    activity();
    finish();
};

MySimpleModule::activity()
{
    declare local vars and initialize them
    initialize statistics collection variables

    while(true)
    {
        ...
    }
}

MySimpleModule::finish()
{
    record statistics into file
}
</pre>

<p>
<p class="subheading">Pros and Cons of using <tt>activity()</tt></p>

<p>
Pros:
<ul>
   <li><tt>initialize()</tt> not needed, state can be stored in local
       variables of <tt>activity()</tt>
   <li>process-style description is a natural programming model in some cases
</ul>

<p>Cons:
<ul>
   <li>limited scalability: coroutine stacks can unacceptably increase the
       memory requirements of the simulation program if you have several
       thousands or ten thousands of simple modules;
   <li>run-time overhead: switching between coroutines is somewhat slower
       than a simple function call
   <li>does not enforce a good programming style: using <tt>activity()</tt>
       tends to lead to unreliable, spaghetti code
</ul>

<p>In most cases, cons outweigh pros and it is a better idea to use
<tt>handleMessage()</tt> instead.

<p>
<p class="subheading">Other simulators</p>

<p>
Coroutines are used by a number of other simulation packages:
<ul>
<li>All simulation software which inherits from SIMULA (e.g. C++SIM)
    is based on coroutines, although all in all the programming
    model is quite different.
<li>The simulation/parallel programming language Maisie and its successor
    PARSEC (from UCLA) also use coroutines (although implemented
    with ``normal'' preemptive threads). The philosophy
    is quite similar to OMNeT++. PARSEC, being ``just''
    a programming language, it has a more elegant syntax but far fewer
    features than OMNeT++.
<li>Many Java-based simulation libraries are based on Java
    threads.
</ul>

<p>

<p>
<H3><A NAME="sec176"/>4.4.3 initialize() and finish()</H3>

<p><p class="subheading">Purpose</p>

<p>
<tt>initialize()</tt> -- to provide place for any user setup code

<p><tt>finish()</tt> -- to provide place where the user can record statistics
after the simulation has completed

<p>
<p class="subheading">When and how they are called</p>

<p>
The <tt>initialize()</tt> functions of the modules are invoked
<i>before</i> the first event is processed, but <i>after</i> the
initial events (starter messages<!--starter messages-->) have been
placed into the FES<!--FES--> by the simulation kernel.

<p>
Both simple and compound modules have <tt>initialize()</tt> functions.
A compound module's <tt>initialize()</tt> function runs
<i>before</i> that of its submodules.

<p>
The <tt>finish()</tt> functions are called when the event
loop<!--event loop--> has terminated, and only if it terminated
normally (i.e. not with a runtime error).  The calling order is the
reverse of the order of <tt>initialize()</tt>: first submodules, then the
encompassing compound module. (The bottom line is that at the moment
there is no ``official'' possibility to redefine <tt>initialize()</tt>
and <tt>finish()</tt> for compound modules; the unofficial way is to
write into the nedtool-generated C++ code. Future versions of OMNeT++ will
support adding these functions to compound modules.)

<p>This is summarized in the following pseudocode:

<p>
<pre>
<i>perform simulation run:</i>
    build network
      (i.e. the system module and its submodules recursively)
    insert starter messages for all submodules using activity()
    do callInitialize() on system module
        <i>enter event loop // (described earlier)</i>
    if (event loop terminated normally) // i.e. no errors
        do callFinish() on system module
    clean up

callInitialize()
{
    call to user-defined initialize() function
    if (module is compound)
        for (each submodule)
            do callInitialize() on submodule
}

callFinish()
{
    if (module is compound)
        for (each submodule)
            do callFinish() on submodule
    call to user-defined finish() function
}
</pre>

<p>

<p><p class="subheading">initialize() vs. constructor</p>

<p>
Usually you should not put simulation-related code into the
simple module constructor<!--module!constructor-->. This is because
modules often need to investigate their surroundings (maybe
the whole network) at the beginning of the simulation and save the
collected info into internal tables.  Code like that cannot be placed
into the constructor since the network is still being set up when the
constructor is called.

<p>
<p class="subheading">finish() vs. destructor</p>

<p>
Keep in mind that <tt>finish()</tt> is not always called, so it isn't a
good place for cleanup code which should run every time the module is
deleted. <tt>finish()</tt> is only a good place for writing statistics,
result post-processing and other operations  which are supposed to run only on
successful completion. Cleanup code should go into the
destructor<!--module!destructor-->.

<p>
<p class="subheading">Multi-stage initialization</p>

<p>
In simulation models, when one-stage
initialization<!--initialization--> provided by <tt>initialize()</tt>
is not sufficient, one can use multi-stage
initialization<!--initialization!multi-stage-->.  Modules have two
functions which can be redefined by the user:

<pre>
void initialize(int stage);
int numInitStages() const;
</pre>
<p>
At the beginning of the simulation, <tt>initialize(0)</tt>
is called for <i>all</i> modules, then <tt>initialize(1)</tt>,
<tt>initialize(2)</tt>, etc. You can think of it like
initialization takes place in several ``waves''. For each module,
<tt>numInitStages()</tt> must be redefined to return the number of init
stages required, e.g. for a two-stage init, <tt>numInitStages()</tt>
should return 2, and <tt>initialize(int stage)</tt> must be implemented to
handle the <i>stage=0</i> and <i>stage=1</i> cases.
  <br><ul><font size=-1>[Note <tt>const</tt> in the <tt>numInitStages()</tt> declaration.
  If you forget it, by C++ rules you create a <i>different</i> function
  instead of redefining the existing one in the base class, thus the
  existing one will remain in effect and return 1.]</font></ul>

<p>The <tt>callInitialize()</tt> function performs the full multi-stage initialization
for that module and all its submodules.

<p>If you do not redefine the multi-stage initialization functions, the
default behavior is single-stage initialization: the default
<tt>numInitStages()</tt> returns 1, and the default <tt>initialize(int stage)</tt>
simply calls <tt>initialize()</tt>.

<p>
<p class="subheading">``End-of-Simulation'' event</p>

<p>
The task of <tt>finish()</tt> is solved in several simulators
by introducing a special <i>end-of-simulation</i><!--end-of-simulation--> event.
This is not a very good practice because the simulation programmer has to
code the models (often represented as FSMs) so that they can <i>always</i>
properly respond to end-of-simulation events, in whichever state they are. This
often makes program code unnecessarily complicated.

<p>This can also be witnessed in the design of the PARSEC<!--PARSEC-->
simulation language (UCLA). Its predecessor Maisie used
end-of-simulation events, but -- as documented in the PARSEC manual --
this has led to awkward programming in many cases, so for PARSEC
end-of-simulation events were dropped in favour of <tt>finish()</tt>
(called <tt>finalize()</tt> in PARSEC).

<p>
<H3><A NAME="sec177"/>4.4.4 handleParameterChange()<sup><b>[New!]</b></sup></H3>

<p>The <tt>handleParameterChange()</tt> method was added in OMNeT++ 3.2,
and it gets called by the simulation kernel when a module parameter changes.
The method signature is the following:

<pre>
void handleParameterChange(const char *parname);
</pre>
<p>
The user can redefine this method to let the module react to runtime parameter
changes. A typical use is to re-read the changed parameter, and update
the module state if needed. For example, if a timeout value changes,
one can restart or modify running timers.

<p>The primary motivation for this functionality was to facilitate
the implementation of <i>scenario manager</i> modules which
can be programmed to change parameters at certain simulation times.
Such modules can be very convenient in studies involving transient behaviour.

<p>The following example shows a queue module, which supports
runtime change of its <tt>serviceTime</tt> parameter:

<pre>
void Queue::handleParameterChange(const char *parname)
{
    if (strcmp(parname, "serviceTime")==0)
    {
        // queue service time parameter changed, re-read it
        serviceTime = par("serviceTime");

        // if there any job being serviced, modify its service time
        if (endServiceMsg-&gt;isScheduled())
        {
            cancelEvent(endServiceMsg);
            scheduleAt(simTime()+serviceTime, endServiceMsg);
        }
    }
}
</pre>
<p>

<p>

<p><H3><A NAME="sec178"/>4.4.5 Reusing module code via subclassing</H3>

<p>It is often needed to have several variants of a simple module.
A good design strategy is to create a simple module class with
the common functionality, then subclass from it to create the
specific simple module types.

<p>
An example:

<pre>
class ModifiedTransportProtocol : public TransportProtocol
{
  protected:
    virtual void recalculateTimeout();
};

Define_Module(ModifiedTransportProtocol);

void ModifiedTransportProtocol::recalculateTimeout()
{
    //...
}
</pre>
<p>

<p><H2><A NAME="sec179"/>4.5 Finite State Machines in OMNeT++</H2>

<p><p class="subheading">Overview</p>

<p>
Finite State Machines<!--finite state machine--> (FSMs)<!--FSM-->
can make life with <tt>handleMessage()</tt> easier. OMNeT++ provides a
class and a set of macros to build FSMs. OMNeT++'s FSMs work very much
like OPNET's or SDL's.

<p>
The key points are:
<ul>
<li>There are two kinds of states:
    <i>transient</i><!--transient states--> and
    <i>steady</i><!--steady states-->. At each event (that is, at
    each call to <tt>handleMessage()</tt>), the FSM transitions out of
    the current (<i>steady</i>) state, undergoes a series of state
    changes (runs through a number of <i>transient</i> states), and
    finally arrives at another <i>steady</i> state. Thus between two
    events, the system is always in one of the steady states.
    Transient states are therefore not really a must -- they exist
    only to group actions to be taken during a transition in a
    convenient way.
<li>You can assign program code to handle entering and leaving a state
    (known as entry/exit code)<!--entry code--><!--exit code-->.
    Staying in the same state is handled as leaving and re-entering
    the state.
<li>Entry code should not modify the state (this is verified by
    OMNeT++).  State changes (transitions) must be put into the exit
    code.
</ul>

<p>OMNeT++'s FSMs <i>can</i> be nested<!--FSM!nested-->. This means
that any state (or rather, its entry or exit code) may contain a
further full-fledged <tt>FSM_Switch()</tt> (see below). This allows you
to introduce sub-states and thereby bring some structure into the
state space if it would become too large.

<p>
<p class="subheading">The FSM API</p>

<p>
FSM state is stored in an object of type <tt><a href="../api/classcFSM.html">cFSM</a></tt>. The possible states
are defined by an enum; the enum is also a place to define, which
state is transient and which is steady. In the following example, SLEEP
and ACTIVE are steady states and SEND is transient (the numbers
in parentheses must be unique within the state type and they are used
for constructing the numeric IDs for the states):

<pre>
enum {
  INIT = 0,
  SLEEP = FSM_Steady(1),
  ACTIVE = FSM_Steady(2),
  SEND = FSM_Transient(1),
};
</pre>
<p>

<p>
The actual FSM is embedded in a switch-like statement,
<tt>FSM_Switch()</tt>, where you have cases for entering and leaving
each state:

<p>
<pre>
FSM_Switch(fsm)
{
  case FSM_Exit(<i>state1</i>):
    //...
    break;
  case FSM_Enter(<i>state1</i>):
    //...
    break;
  case FSM_Exit(<i>state2</i>):
    //...
    break;
  case FSM_Enter(<i>state2</i>):
    //...
    break;
  //...
};
</pre>

<p>
State transitions<!--state transition--> are done via calls to
<tt>FSM_Goto()</tt>, which simply stores the new state in the
<tt><a href="../api/classcFSM.html">cFSM</a></tt> object:

<p><pre>
FSM_Goto(fsm,<i>newState</i>);
</pre>

<p>The FSM starts from the state with the numeric code 0; this state
is conventionally named INIT.

<p>
<p class="subheading">Debugging FSMs</p>

<p>FSMs can log their state transitions <tt>ev</tt><!--ev-->,
with the output looking like this:

<pre>
...
FSM GenState: leaving state SLEEP
FSM GenState: entering state ACTIVE
...
FSM GenState: leaving state ACTIVE
FSM GenState: entering state SEND
FSM GenState: leaving state SEND
FSM GenState: entering state ACTIVE
...
FSM GenState: leaving state ACTIVE
FSM GenState: entering state SLEEP
...
</pre>
<p>
To enable the above output, you have to <tt>#define FSM_DEBUG</tt><!--FSM_DEBUG-->
before including <tt>omnetpp.h</tt>.

<p><pre>
#define FSM_DEBUG    // enables debug output from FSMs
#include &lt;omnetpp.h&gt;
</pre>

<p>The actual logging is done via the <tt>FSM_Print()</tt> macro.
It is currently defined as follows, but you can change the
output format by undefining <tt>FSM_Print()</tt> after including
<tt>omnetpp.ini</tt> and providing a new definition instead.

<pre>
#define FSM_Print(fsm,exiting)
  (ev &lt;&lt; "FSM " &lt;&lt; (fsm).name()
      &lt;&lt; ((exiting) ? ": leaving state " : ": entering state ")
      &lt;&lt; (fsm).stateName() &lt;&lt; endl)
</pre>
<p>

<p><p class="subheading">Implementation</p>

<p>
The <tt>FSM_Switch()</tt> is a macro. It expands to a <tt>switch()</tt>
statement embedded in a <tt>for()</tt> loop which repeats until the
FSM<!--FSM--> reaches a steady state. (The actual code is rather
scary, but if you're dying to see it, it is in <tt>cfsm.h</tt>.)

<p>Infinite loops are avoided by counting state transitions: if
an FSM goes through 64 transitions without reaching a steady
state, the simulation will terminate with an error message.

<p>
<p class="subheading">An example</p>

<p>
Let us write another bursty generator. It will have two
states, SLEEP and ACTIVE. In the SLEEP state, the module does
nothing. In the ACTIVE state, it sends messages with a given
inter-arrival time. The code was taken from the Fifo2 sample
simulation.

<p>
<pre>
#define FSM_DEBUG
#include &lt;omnetpp.h&gt;

class BurstyGenerator : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    // parameters
    double sleepTimeMean;
    double burstTimeMean;
    double sendIATime;
    <a href="../api/classcPar.html">cPar</a> *msgLength;

    // FSM and its states
    <a href="../api/classcFSM.html">cFSM</a> fsm;
    enum {
      INIT = 0,
      SLEEP = FSM_Steady(1),
      ACTIVE = FSM_Steady(2),
      SEND = FSM_Transient(1),
    };

    // variables used
    int i;
    <a href="../api/classcMessage.html">cMessage</a> *startStopBurst;
    <a href="../api/classcMessage.html">cMessage</a> *sendMessage;

    // the virtual functions
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
};

Define_Module(BurstyGenerator);

void BurstyGenerator::initialize()
{
    fsm.setName("fsm");
    sleepTimeMean = par("sleepTimeMean");
    burstTimeMean = par("burstTimeMean");
    sendIATime = par("sendIATime");
    msgLength = &par("msgLength");
    i = 0;
    WATCH(i); // always put watches in initialize()
    startStopBurst = new <a href="../api/classcMessage.html">cMessage</a>("startStopBurst");
    sendMessage = new <a href="../api/classcMessage.html">cMessage</a>("sendMessage");
    scheduleAt(0.0,startStopBurst);
}

void BurstyGenerator::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
  FSM_Switch(fsm)
 {
    case FSM_Exit(INIT):
      // transition to SLEEP state
      FSM_Goto(fsm,SLEEP);
      break;
    case FSM_Enter(SLEEP):
      // schedule end of sleep period (start of next burst)
      scheduleAt(simTime()+exponential(sleepTimeMean),
                 startStopBurst);
    break;
    case FSM_Exit(SLEEP):
      // schedule end of this burst
      scheduleAt(simTime()+exponential(burstTimeMean),
                 startStopBurst);
      // transition to ACTIVE state:
      if (msg!=startStopBurst) {
        error("invalid event in state ACTIVE");
      }
      FSM_Goto(fsm,ACTIVE);
      break;
    case FSM_Enter(ACTIVE):
      // schedule next sending
      scheduleAt(simTime()+exponential(sendIATime), sendMessage);
    break;
    case FSM_Exit(ACTIVE):
      // transition to either SEND or SLEEP
      if (msg==sendMessage) {
        FSM_Goto(fsm,SEND);
      } else if (msg==startStopBurst) {
        cancelEvent(sendMessage);
        FSM_Goto(fsm,SLEEP);
      } else {
        error("invalid event in state ACTIVE");
      }
      break;
    case FSM_Exit(SEND):
    {
      // generate and send out job
      char msgname[32];
      sprintf( msgname, "job-%d", ++i);
      ev &lt;&lt; "Generating " &lt;&lt; msgname &lt;&lt; endl;
      <a href="../api/classcMessage.html">cMessage</a> *job = new <a href="../api/classcMessage.html">cMessage</a>(msgname);
      job-&gt;setLength( (long) *msgLength );
      job-&gt;setTimestamp();
      send( job, "out" );
      // return to ACTIVE
      FSM_Goto(fsm,ACTIVE);
      break;
    }
  }
}
</pre>

<p>

<p>

<p><H2><A NAME="sec180"/>4.6 Sending and receiving messages</H2>
<a name="ch:simple-modules:sending-and-receiving"></a>

<p>On an abstract level, an OMNeT++ simulation model is a set of
simple modules that communicate with each other via message passing.
The essence of simple modules is that they create, send, receive,
store, modify, schedule and destroy messages -- everything else
is supposed to facilitate this task, and collect statistics
about what was going on.

<p>Messages in OMNeT++ are instances of the <tt><a href="../api/classcMessage.html">cMessage</a></tt> class or
one of its subclasses. Message objects are created using the C++
<tt>new</tt> operator and destroyed using the <tt>delete</tt> operator
when they are no longer needed. During their lifetimes,
messages travel between modules via gates and connections
(or are sent directly, bypassing the connections), or
they are scheduled by and delivered to modules,
representing internal events of that module.

<p>Messages are described in detail in chapter <a href="#sec206">[5]</a>.
At this point, all we need to know about them is that they are
referred to as <tt><a href="../api/classcMessage.html">cMessage</a> *</tt> pointers. Message objects
can be given descriptive names (a <tt>const char *</tt> string)
that often helps in debugging the simulation. The message
name string can be specified in the constructor, so it
should not surprise you if you see something like
<tt>new <a href="../api/classcMessage.html">cMessage</a>("token")</tt> in the examples below.

<p>

<p><H3><A NAME="sec181"/>4.6.1 Sending messages</H3>

<p>Once created, a message object can be sent through an
output gate<!--output!gate--> using one of the following functions:

<pre>
send(<a href="../api/classcMessage.html">cMessage</a> *msg, const char *gateName, int index=0);
send(<a href="../api/classcMessage.html">cMessage</a> *msg, int gateId);
send(<a href="../api/classcMessage.html">cMessage</a> *msg, <a href="../api/classcGate.html">cGate</a> *gate);
</pre>
<p>
In the first function, the argument <tt>gateName</tt> is the name of
the gate the message has to be sent through. If this gate is
a vector gate, <tt>index</tt> determines though which particular output
gate this has to be done; otherwise, the <tt>index</tt> argument is not
needed.

<p>The second and third functions use the gate Id and the pointer to the gate
object. They are faster than the first one because they don't have to
search through the gate array.

<p>Examples:

<pre>
send(msg, "outGate");
send(msg, "outGates", i); // send via outGates[i]
</pre>
<p>
The following code example creates and sends messages
every 5 simulated seconds:

<pre>
int outGateId = findGate("outGate");
while(true)
{
  send(new <a href="../api/classcMessage.html">cMessage</a>("packet"), outGateId);
  wait(5);
}
</pre>
<p>

<p><p class="subheading">Modeling packet transmissions</p>

<p>If you're sending messages over a link that has (nonzero) data rate,
it is modeled as described earlier in this manual, in
section <a href="#sec162">[4.2]</a>.

<p>If you want to have full control over the transmission process,
you'll probably need the <tt>isBusy()</tt> and <tt>transmissionFinishes()</tt>
member functions of <tt><a href="../api/classcGate.html">cGate</a></tt>. They are described in section
<a href="#sec194">[4.8.3]</a>.

<p>

<p><H3><A NAME="sec182"/>4.6.2 Broadcasts and retransmissions</H3>

<p>When you implement broadcasts or retransmissions, two frequently
occurring tasks in protocol simulation, you might feel tempted
to use the same message in multiple <tt>send()</tt> operations.
Do not do it -- you cannot send the same message object multiple times.
The solution in such cases is duplicating the message.

<p><p class="subheading">Broadcasting messages</p>

<p>In your model, you may need to broadcast a message to several destinations.
Broadcast can be implemented in a simple module by sending out copies
of the same message, for example on every gate of a gate vector.
As described above, you cannot use the same message pointer for
in all <tt>send()</tt> calls -- what you have to do instead is
create copies (duplicates) of the message object and send them.

<p>Example:

<pre>
for (int i=0; i&lt;n; i++)
{
    <a href="../api/classcMessage.html">cMessage</a> *copy = (<a href="../api/classcMessage.html">cMessage</a> *) msg-&gt;dup();
    send(copy, "out", i);
}
delete msg;
</pre>
<p>
You might have noticed that copying the message for the last gate is
redundant (we could send out the original message),
so it can be optimized out like this:

<pre>
for (int i=0; i&lt;n-1; i++)   // note n-1 instead of n
{
    <a href="../api/classcMessage.html">cMessage</a> *copy = (<a href="../api/classcMessage.html">cMessage</a> *) msg-&gt;dup();
    send(copy, "out", i);
}
send(msg, "out", n-1);  // send original on last gate
</pre>
<p>

<p><p class="subheading">Retransmissions</p>

<p>Many communication protocols involve retransmissions of packets (frames).
When implementing retransmissions, you cannot just hold a pointer
to the same message object and send it again and again -- you'd get
the <i>not owner of message</i> error on the first resend.

<p>Instead, whenever it comes to (re)transmission, you should create and
send copies of the message, and retain the original.
When you are sure there will not be any more retransmission,
you can delete the original message.

<p>Creating and sending a copy:

<pre>
// (re)transmit packet:
<a href="../api/classcMessage.html">cMessage</a> *copy = (<a href="../api/classcMessage.html">cMessage</a> *) packet-&gt;dup();
send(copy, "out");
</pre>
<p>
and finally (when no more retransmissions will occur):

<pre>
delete packet;
</pre>
<p>

<p><p class="subheading">Why?</p>

<p>A message is like any real world object -- it cannot be at two places
at the same time. Once you've sent it, the message object
no longer belongs to the module: it is taken over by the simulation kernel,
and will eventually be delivered to the destination module.
The sender module should not even refer to its pointer any more.
Once the message arrived in the destination module, that module
will have full authority over it -- it can send it on,
destroy it immediately, or store it for further handling.
The same applies to messages that have been scheduled -- they
belong to the simulation kernel until they are delivered back to
the module.

<p>To enforce the rules above, all message sending functions
check that you actually own the message you are about to send.
If the message is with another module, it is currently scheduled or
in a queue etc., you'll get a runtime error: <i>not owner of message</i>.
  <br><ul><font size=-1>[The feature does not increase runtime overhead significantly, because
  it uses the object ownership<!--ownership--> management (described in
  Section <a href="#sec274">[6.12]</a>);
  it merely checks that the owner of the message is the module that
  wants to send it.]</font></ul>

<p>

<p><H3><A NAME="sec183"/>4.6.3 Delayed sending</H3>

<p>It is often needed to model a delay (processing time, etc.) immediately
followed by message sending. In OMNeT++, it is possible to implement
it like this:

<pre>
wait( someDelay );
send( msg, "outgate" );
</pre>
<p>

<p>If the module needs to react to messages that arrive during the delay,
<tt>wait()</tt> cannot be used and the timer mechanism described in
Section <a href="#sec187">[4.6.7]</a>, ``Self-messages'', would
need to be employed.

<p>
There is also a more straightforward method than those mentioned above:
delayed sending<!--delayed sending-->. Delayed sending can be achieved
by using one of these functions:

<pre>
sendDelayed(<a href="../api/classcMessage.html">cMessage</a> *msg, double delay, const char *gateName, int index);
sendDelayed(<a href="../api/classcMessage.html">cMessage</a> *msg, double delay, int gateId);
sendDelayed(<a href="../api/classcMessage.html">cMessage</a> *msg, double delay, <a href="../api/classcGate.html">cGate</a> *gate);
</pre>
<p>
The arguments are the same as for <tt>send()</tt>, except for the extra <i>delay</i>
parameter. The effect of the function is the same as if the module
had kept the message for the delay interval and sent it afterwards.
That is, the sending time of the message will be the current
simulation time (time at the <tt>sendDelayed()</tt> call) plus the delay.
The delay value must be non-negative.

<p>Example:

<pre>
sendDelayed(msg, 0.005, "outGate");
</pre>
<p>

<p>
<H3><A NAME="sec184"/>4.6.4 Direct message sending</H3>

<p>Sometimes it is necessary or convenient to ignore gates/connections
and send a message directly to a remote destination module. The <tt>sendDirect()</tt>
function does that:

<pre>
sendDirect(<a href="../api/classcMessage.html">cMessage</a> *msg, double delay, <a href="../api/classcModule.html">cModule</a> *mod, int gateId)
sendDirect(<a href="../api/classcMessage.html">cMessage</a> *msg, double delay, <a href="../api/classcModule.html">cModule</a> *mod, const char *gateName, int index=-1)
sendDirect(<a href="../api/classcMessage.html">cMessage</a> *msg, double delay, <a href="../api/classcGate.html">cGate</a> *gate)
</pre>
<p>
In addition to the message and a delay, it also takes the destination module
and gate. The gate should be an <i>input</i> gate and should not be connected.
In other words, the module needs dedicated gates for receiving via <tt>sendDirect()</tt>.
(Note: For leaving a gate unconnected in a compound module, you'll need to specify
<tt>connections nocheck:</tt> instead of plain <tt>connections:</tt> in the NED file.)

<p>An example:

<pre>
<a href="../api/classcModule.html">cModule</a> *destinationModule = parentModule()-&gt;submodule("node2");
double delay = truncnormal(0.005, 0.0001);
sendDirect(new <a href="../api/classcMessage.html">cMessage</a>("packet"), delay, destinationModule, "inputGate");
</pre>
<p>
At the destination module, there is no difference between messages received
directly and those received over connections.

<p>

<p><H3><A NAME="sec185"/>4.6.5 Receiving messages</H3>

<p><b>With activity() only!</b> The message receiving functions can
only be used in the <tt>activity()</tt> function,
<tt>handleMessage()</tt> gets received messages in its argument list.

<p>Messages are received using the <tt>receive()</tt> function.
<tt>receive()</tt> is a member of <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>.

<pre>
<a href="../api/classcMessage.html">cMessage</a> *msg = receive();
</pre>
<p>
The <tt>receive()</tt> function accepts an optional <i>timeout</i>
parameter<!--receive!timeout-->. (This is a <i>delta</i>, not an
absolute simulation time.) If an appropriate message doesn't arrive
within the timeout period, the function returns a NULL pointer.
    <br><ul><font size=-1>[Putaside-queue and the functions <tt>receiveOn()</tt>,
    <tt>receiveNew()</tt>, and <tt>receiveNewOn()</tt> were deprecated
    in OMNeT++ 2.3 and removed in OMNeT++ 3.0.]</font></ul>

<pre>
simtime_t timeout = 3.0;
<a href="../api/classcMessage.html">cMessage</a> *msg = receive( timeout );

if (msg==NULL)
{
    ...   // handle timeout
}
else
{
    ...  // process message
}
</pre>
<p>

<p>
<H3><A NAME="sec186"/>4.6.6 The wait() function</H3>

<p><b>With activity() only!</b> The <tt>wait()</tt> function's implementation
contains a <tt>receive()</tt> call which cannot be used in <tt>handleMessage()</tt>.

<p>The <tt>wait()</tt> function suspends the execution of the module for
a given amount of simulation time (a <i>delta</i>).

<pre>
wait( delay );
</pre>
<p>
In other simulation software, <tt>wait()</tt> is often called <i>hold</i>.
Internally, the <tt>wait()</tt> function is implemented by a
<tt>scheduleAt()</tt> followed by a <tt>receive()</tt>.
The <tt>wait()</tt> function is very convenient in modules that do not need
to be prepared for arriving messages, for example message generators.
An example:

<pre>
for(;;)
{
  // wait for a (potentially random amount of) time, specified
  // in the interArrivalTime module parameter
  wait( par("interArrivalTime") );

  // generate and send message
  ...
}
</pre>
<p>
It is a runtime error if a message arrives during the wait interval.
If you expect messages to arrive during the wait period, you can
use the <tt>waitAndEnqueue()</tt> function. It takes a pointer to a queue object
(of class <tt><a href="../api/classcQueue.html">cQueue</a></tt>, described in chapter <a href="#sec223">[6]</a>)
in addition to the wait interval. Messages that arrive during the
wait interval will be accumulated in the queue, so you can
process them after the <tt>waitAndEnqueue()</tt> call returned.

<pre>
<a href="../api/classcQueue.html">cQueue</a> queue("queue");
...
waitAndEnqueue(waitTime, &queue);
if (!queue.empty())
{
  // process messages arrived during wait interval
  ...
}
</pre>
<p>

<p><H3><A NAME="sec187"/>4.6.7 Modeling events using self-messages</H3>
<a name="sec:ch-simple-modules:self-messages"></a>

<p>In most simulation models it is necessary to implement timers,
or schedule events that occur at some point in the future.
For example, when a packet is sent by a communications protocol model,
it has to schedule an event that would occur when a timeout expires,
because it will have to resent the packet then.
As another example, suppose you want to write a model of a server which
processes jobs from a queue. Whenever it begins processing
a job, the server model will want to schedule an event to occur
when the job finishes processing, so that it can begin processing
the next job.

<p>In OMNeT++ you solve such tasks by letting the simple module
send a message to itself; the message would be delivered
to the simple module at a later point of time. Messages used
this way are called self-messages<!--self-message-->.
Self-messages are used to model events which occur within the module.

<p><p class="subheading">Scheduling an event</p>

<p>The module can send a message to itself using the <tt>scheduleAt()</tt> function.
<tt>scheduleAt()</tt> accepts an <i>absolute</i> simulation time,
usually calculated as <tt>simTime()</tt>+<i>delta</i>:

<pre>
scheduleAt(absoluteTime, msg);
scheduleAt(simtime()+delta, msg);
</pre>
<p>
Self-messages are delivered to the module in the same way as other
messages (via the usual receive calls or <tt>handleMessage()</tt>);
the module may call the <tt>isSelfMessage()</tt> member of any received
message to determine if it is a self-message.

<p>As an example, here's how you could implement your own <tt>wait()</tt>
function in an <tt>activity()</tt> simple module, if the simulation kernel
didn't provide it already:


<pre>
<a href="../api/classcMessage.html">cMessage</a> *msg = new <a href="../api/classcMessage.html">cMessage</a>();
scheduleAt(simtime()+waitTime, msg);
<a href="../api/classcMessage.html">cMessage</a> *recvd = receive();
if (recvd!=msg)
   // hmm, some other event occurred meanwhile: error!
...
</pre>
<p>
You can determine if a message is currently in the FES<!--FES-->
by calling its <tt>isScheduled()</tt> member:

<pre>
if (msg-&gt;isScheduled())
  // currently scheduled
else
  // not scheduled
</pre>
<p>

<p><p class="subheading">Re-scheduling an event</p>

<p>If you want to reschedule an event which is currently scheduled to a different
simulation time, first you have to cancel it using <tt>cancelEvent()</tt>.

<p>
<p class="subheading">Cancelling an event</p>

<p>Scheduled self-messages can be cancelled<!--self-message!cancelling-->
<!--message!cancelling--> (removed from the FES<!--FES-->).
This is particularly useful because self-messages are often used
to model timers.

<pre>
cancelEvent( msg );
</pre>
<p>
The <tt>cancelEvent()</tt> function takes a pointer to the message to
be cancelled, and also returns the same pointer. After having it
cancelled, you may delete the message or reuse it in the next
<tt>scheduleAt()</tt> calls. <tt>cancelEvent()</tt> gives an error if
the message is not in the FES<!--FES-->.

<p>
<p class="subheading">Implementing timers</p>

<p>The following example shows how to implement timers:

<pre>
<a href="../api/classcMessage.html">cMessage</a> *timeoutEvent = new <a href="../api/classcMessage.html">cMessage</a>("timeout");

scheduleAt(simTime()+10.0, timeoutEvent);
//...

<a href="../api/classcMessage.html">cMessage</a> *msg = receive();
if (msg == timeoutEvent)
{
  // timeout expired
}
else
{
  // other message has arrived, timer can be cancelled now:
  delete cancelEvent(timeoutEvent);
}
</pre>
<p>

<p>

<p>
<H3><A NAME="sec188"/>4.6.8 Stopping the simulation</H3>

<p><p class="subheading">Normal termination</p>

<p>
You can finish the simulation with the <tt>endSimulation()</tt> function:

<p>
<tt>endSimulation()</tt>;

<p>
Typically you don't need <tt>endSimulation()</tt> because you
can specify simulation time and CPU time limits<!--simulation time
  limits--> in the ini file (see later).

<p>
<p class="subheading">Stopping on errors</p>

<p>
If you want your simulation to stop if it detects an error condition,
you can call the <tt>error()</tt> member function of <tt><a href="../api/classcModule.html">cModule</a></tt>.
It is used like <tt>printf()</tt>:

<pre>
if (windowSize&lt;1)
  error("Invalid window size %d; must be &gt;=1", windowSize);
</pre>
<p>

<p>Do not include a newline (``\n'') or punctuation (period
or exclamation mark) in the error text, as it will be added by OMNeT++.

<p>

<p>

<p><H2><A NAME="sec189"/>4.7 Accessing module parameters</H2>
<a name="ch:simple-modules:parameters"></a>

<p>Module parameters can be accessed<!--module!accessing parameters-->
by calling the <tt>par()</tt> member function of <tt><a href="../api/classcModule.html">cModule</a></tt>:

<pre>
<a href="../api/classcPar.html">cPar</a>& delayPar = par("delay");
</pre>
<p>
The <tt><a href="../api/classcPar.html">cPar</a></tt> class is a general value-storing object. It supports
type casts to numeric types, so parameter values can be read
like this:

<pre>
int numTasks = par("numTasks");
double processingDelay = par("processingDelay");
</pre>
<p>
If the parameter is a random variable or its value can change
during execution, it is best to store a reference to it and re-read
the value each time it is needed:

<pre>
<a href="../api/classcPar.html">cPar</a>& waitTime = par("waitTime");
for(;;)
{
  //...
  wait( (simtime_t)waitTime );
}
</pre>
<p>
If the <tt>wait_time</tt> parameter was given a random value (e.g. <tt>exponential(1.0)</tt>)
in the NED source or the ini file, the above code results in
a different delay each time.

<p>Parameter values can also be changed from the program, during
execution. If the parameter was taken by reference
<!--module!parameters!by reference--> (with a
<tt>ref</tt> modifier in the NED file), other modules
will also see the change.  Thus, parameters taken by reference can be
used as a means of module communication<!--module!communication-->.

<p>An example:

<pre>
par("waitTime") = 0.12;
</pre>
<p>
Or:

<pre>
<a href="../api/classcPar.html">cPar</a>& waitTime = par("waitTime");
waitTime = 0.12;
</pre>
<p>
The <tt><a href="../api/classcPar.html">cPar</a></tt> class is discussed in more detail in section
<a href="#sec244">[6.6]</a>.

<p>
<H3><A NAME="sec190"/>4.7.1 Emulating parameter arrays</H3>

<p>As of version 3.2, OMNeT++ does not support parameter arrays,
but in practice they can be emulated using string parameters.
One can assign the parameter a string which contains all values
in a textual form (for example, <tt>"0 1.234 3.95 5.467"</tt>), then
parse this string in the simple module.

<p>The <tt><a href="../api/classcStringTokenizer.html">cStringTokenizer</a></tt> class can be quite helpful for this
purpose. The constructor accepts a string, which it regards as
a sequence of tokens (words) separated by delimiter characters
(by default, spaces). Then, calling the <tt>nextToken()</tt> method
several times will return the tokens one by one. After the
last token, it returns <tt>NULL</tt>.

<p>For example, you can parse a string containing a sequence of integers
into a vector using the following code:

<pre>
const char *str = "34 42 13 46 72 41"; // input
std::vector&lt;int&gt; numbers;  // array to hold the result

<a href="../api/classcStringTokenizer.html">cStringTokenizer</a> tokenizer(str);
const char *token;
while ((token = tokenizer.nextToken())!=NULL)
    numbers.push_back(atoi(token));   // convert and store
</pre>
<p>
The class also has a <tt>hasMoreTokens()</tt> method, so the above
code can also be written as

<pre>
...
<a href="../api/classcStringTokenizer.html">cStringTokenizer</a> tokenizer(str);
while (tokenizer.hasMoreTokens())
    numbers.push_back(atoi(tokenizer.nextToken()));
</pre>
<p>
For converting <tt>long</tt>s and <tt>double</tt>s, replace <tt>atoi()</tt>
with <tt>atol()</tt> and <tt>atof()</tt>, respectively.

<p>For storing the tokens in a string vector, the <tt><a href="../api/classcStringTokenizer.html">cStringTokenizer</a></tt>
class has a convenience function named <tt>asVector()</tt>, so conversion
can be done in just one line of code:

<pre>
const char *str = "34 42 13 46 72 41";
std::vector&lt;std::string&gt; strVec = <a href="../api/classcStringTokenizer.html">cStringTokenizer</a>(str).asVector();
</pre>
<p>

<p>
<H2><A NAME="sec191"/>4.8 Accessing gates and connections</H2>
<a name="ch:simple-modules:gates"></a>

<p><H3><A NAME="sec192"/>4.8.1 Gate objects</H3>

<p>
Module gates<!--gate--> are <tt><a href="../api/classcGate.html">cGate</a></tt> objects. Gate objects
know whether, and to which gate they are connected. They can also be
queried on the parameters of the link (delay, data rate, etc.)

<p>The <tt>gate()</tt> member function of <tt><a href="../api/classcModule.html">cModule</a></tt> returns a
pointer to a <tt><a href="../api/classcGate.html">cGate</a></tt> object, and an overloaded form of the
function lets you access elements of a vector gate:

<pre>
<a href="../api/classcGate.html">cGate</a> *outgate = gate("out");
<a href="../api/classcGate.html">cGate</a> *outvec5gate = gate("outvec",5);
</pre>
<p>
For gate vectors<!--gate!vector-->, the first form returns the first gate in the
vector (at index 0).

<p>The <tt>isVector()</tt> member function can be used to determine if a
gate belongs to a gate vector or not.

<p>Given a gate pointer, you can use the <tt>size()</tt> and
<tt>index()</tt> member functions of <tt><a href="../api/classcGate.html">cGate</a></tt> to determine the
size of the gate vector<!--gate!vector size--> and the
index<!--gate!vector index--> of the gate within the vector:

<pre>
int size2 = outvec5gate-&gt;size(); // --&gt; size of outvec[]
int index = outvec5gate-&gt;index(); // --&gt; 5 (it is gate 5 in the vector)
</pre>
<p>
Instead of <tt>gate-&gt;size()</tt>, you can also call the <tt>gateSize()</tt>
method of <tt><a href="../api/classcModule.html">cModule</a></tt>, which does the same:

<pre>
int size2 = gateSize("out");
</pre>
<p>
For non-vector gates, <tt>size()</tt> returns 1 and <tt>index()</tt> returns 0.

<p>Zero-size gate vectors are represented with a placeholder gate whose
<tt>size()</tt> method returns zero and cannot be connected.

<p>The <tt>type()</tt> member function returns a character, 'I' for input
gates and 'O' for output gates:

<pre>
char type = outgate-&gt;type() // --&gt; 'O'
</pre>
<p>

<p><p class="subheading">Gate IDs</p>

<p>Module gates (input and output, single and vector) are stored in an
array within their modules. The gate's position in the array is called
the <i>gate ID</i>. The gate ID<!--gate!id--> is returned by the <tt>id()</tt>
member function:

<pre>
int id = outgate-&gt;id();
</pre>
<p>
For a module with input gates <tt>fromApp</tt> and <tt>in[3]</tt> and output gates
of <tt>toApp</tt> and <tt>status</tt>, the array may look like this:

<p><table border>
<TR> <TD align=center>

<b>ID</b> </TD> <TD align=center> <b>dir</b> </TD> <TD align=center> <b>name[index]</b></TD></TR>
<TR> <TD align=center> 0 </TD> <TD align=center> <i>input</i> </TD> <TD align=center> <tt>fromApp</tt> </TD></TR>
<TR> <TD align=center> 1 </TD> <TD align=center> <i>output</i> </TD> <TD align=center> <tt>toApp</tt> </TD></TR>
<TR> <TD align=center> 2 </TD> <TD align=center colspan=2><i>empty</i></TD></TR>
<TR> <TD align=center> 3 </TD> <TD align=center> <i>input</i> </TD> <TD align=center> <tt>in[0]</tt></TD></TR>
<TR> <TD align=center> 4 </TD> <TD align=center> <i>input</i> </TD> <TD align=center> <tt>in[1]</tt></TD></TR>
<TR> <TD align=center> 5 </TD> <TD align=center> <i>input</i> </TD> <TD align=center> <tt>in[2]</tt></TD></TR>
<TR> <TD align=center> 6 </TD> <TD align=center> <i>output</i> </TD> <TD align=center> <tt>status</tt></TD></TR>
</table>

<p>The array may have empty slots. Gate vectors are guaranteed to
occupy contiguous IDs, thus it is legal to calculate the
ID of <i>gate[k]</i> as <tt>gate("gate",0).id()+k</tt>.

<p>Message sending and receiving functions accept both gate names
and gate IDs; the functions using gate IDs are a bit faster.
Gate IDs do not change during execution, so it is often worth
retrieving them in advance and using them instead of gate names.

<p>You can also obtain gate IDs with the <tt>findGate()</tt>
member of <tt><a href="../api/classcModule.html">cModule</a></tt>:

<pre>
int id1 = findGate("out");
int id2 = findGate("outvect",5);
</pre>
<p>

<p>
<H3><A NAME="sec193"/>4.8.2 Connection parameters</H3>

<p>Connection attributes (propagation delay, transmission data rate,
bit error rate) are represented by the channel object, which
is available via the source gate of the connection.

<pre>
<a href="../api/classcChannel.html">cChannel</a> *chan = outgate-&gt;channel();
</pre>
<p>
<tt><a href="../api/classcChannel.html">cChannel</a></tt> is a small base class. All interesting attributes are
part of its subclass <tt><a href="../api/classcBasicChannel.html">cBasicChannel</a></tt>, so you have to cast the pointer
before getting to the delay, error and data rate values.

<pre>
<a href="../api/classcBasicChannel.html">cBasicChannel</a> *chan = check_and_cast&lt;<a href="../api/classcBasicChannel.html">cBasicChannel</a> *&gt;(outgate-&gt;channel());
double d = chan-&gt;delay();
double e = chan-&gt;error();
double r = chan-&gt;datarate();
</pre>
<p>
You can also change the channel attributes with the corresponding
<tt>setXXX()</tt> functions. Note, however, that (as it was explained in
section <a href="#sec162">[4.2]</a>)
changes will not affect messages already sent, even if they have not
begun transmission yet.

<p>

<p><H3><A NAME="sec194"/>4.8.3 Transmission state</H3>
<a name="ch:simple-modules:cgate-transmission-state"></a>

<p>The <tt>isBusy()</tt> member function returns whether the gate
is currently transmitting, and if so, the
<tt>transmissionFinishes()</tt> member function
returns the simulation time when the gate is going to finish
transmitting. (If the gate in not currently transmitting,
<tt>transmissionFinishes()</tt> returns the simulation time
when it finished its last transmission.)

<p>The semantics have been described in section
<a href="#sec162">[4.2]</a>.

<p>An example:

<pre>
<a href="../api/classcMessage.html">cMessage</a> *packet = new <a href="../api/classcMessage.html">cMessage</a>("DATA");
packet-&gt;setByteLength(1024);  // 1K

if (gate("TxGate")-&gt;isBusy()) // if gate is busy, wait until it
{                             // becomes free
  wait( gate("TxGate")-&gt;transmissionFinishes() - simTime());
}
send( packet, "TxGate");
</pre>
<p>
If the connection with a data rate is not directly connected
to the simple module's output gate but is the second
one in the route, you have to check the second gate's busy
condition<!--gate!busy condition-->. You could use the following
code:

<pre>
if (gate("mygate")-&gt;toGate()-&gt;isBusy())
  //...
</pre>
<p>
Note that if data rates change<!--data rate change--> during the
simulation, the changes will affect only the messages that are
<i>sent</i> after the change.

<p>

<p><H3><A NAME="sec195"/>4.8.4 Connectivity</H3>

<p>The <tt>isConnected()</tt> member function returns whether
the gate is connected. If the gate is an output gate, the gate to
which it is connected is obtained by the <tt>toGate()</tt>
member function. For input gates, the function is
<tt>fromGate()</tt>.


<pre>
<a href="../api/classcGate.html">cGate</a> *gate = gate("somegate");
if (gate-&gt;isConnected())
{
  <a href="../api/classcGate.html">cGate</a> *othergate = (gate-&gt;type()=='O') ?
                     gate-&gt;toGate() : gate-&gt;fromGate();

  ev &lt;&lt; "gate is connected to: " &lt;&lt; othergate-&gt;fullPath() &lt;&lt; endl;
}
else
{
  ev &lt;&lt; "gate not connected" &lt;&lt; endl;
}
</pre>
<p>

<p>An alternative to <tt>isConnected()</tt> is to check the return value
of <tt>toGate()</tt> or <tt>fromGate()</tt>. The following code is fully equivalent
to the one above:

<pre>
<a href="../api/classcGate.html">cGate</a> *gate = gate("somegate");
<a href="../api/classcGate.html">cGate</a> *othergate = (gate-&gt;type()=='O') ?
                   gate-&gt;toGate() : gate-&gt;fromGate();
if (othergate)
  ev &lt;&lt; "gate is connected to: " &lt;&lt; othergate-&gt;fullPath() &lt;&lt; endl;
else
  ev &lt;&lt; "gate not connected" &lt;&lt; endl;
</pre>
<p>
To find out to which simple module a given output
gate leads finally<!--gate!destination-->, you would have to walk
along the path like this (the <tt>ownerModule()</tt> member function
returns the module to which the gate belongs):

<pre>
<a href="../api/classcGate.html">cGate</a> *gate = gate("out");
while (gate-&gt;toGate()!=NULL)
{
  gate = gate-&gt;toGate();
}

<a href="../api/classcModule.html">cModule</a> *destmod = gate-&gt;ownerModule();
</pre>
<p>

<p>but luckily, there are two convenience functions which do that:
<tt>sourceGate()</tt> and
<tt>destinationGate()</tt>.

<p>

<p>

<p><H2><A NAME="sec196"/>4.9 Walking the module hierarchy</H2>
<a name="ch:simple-modules:walking-module-hieararchy"></a>

<p><p class="subheading">Module vectors</p>

<p>
If a module is part of a module vector<!--module!vector-->, the
<tt>index()</tt> and <tt>size()</tt> member functions can be used to
query its index and the vector size:

<pre>
ev &lt;&lt; "This is module [" &lt;&lt; module-&gt;index() &lt;&lt;
      "] in a vector of size [" &lt;&lt; module-&gt;size() &lt;&lt; "].\n";
</pre>
<p>

<p><p class="subheading">Module IDs</p>

<p>
Each module in the network has a unique ID that is returned by the
<tt>id()</tt> member function. The module ID<!--module!id--> is used
internally by the simulation kernel to identify modules.

<pre>
int myModuleId = id();
</pre>
<p>
If you know the module ID, you can ask the simulation object
(a global variable) to get back the module pointer:

<pre>
int id = 100;
<a href="../api/classcModule.html">cModule</a> *mod = simulation.module( id );
</pre>
<p>

<p>Module IDs are guaranteed to be unique, even when modules are
created and destroyed dynamically. That is, an ID which once
belonged to a module which was deleted is never issued to another
module later.

<p>
<p class="subheading">Walking up and down the module hierarchy</p>

<p>
The surrounding compound module can be accessed by the
<tt>parentModule()</tt> member function:

<pre>
<a href="../api/classcModule.html">cModule</a> *parent = parentModule();
</pre>
<p>
For example, the parameters of the parent module are accessed
like this:

<pre>
double timeout = parentModule()-&gt;par( "timeout" );
</pre>
<p>

<p><tt><a href="../api/classcModule.html">cModule</a></tt>'s <tt>findSubmodule()</tt> and <tt>submodule()</tt>
member functions make it possible to look up the module's submodules
by name<!--module!submodule!lookup--> (or name+index if the submodule
is in a module vector). The first one returns the numeric module ID of
the submodule, and the latter returns the module pointer.  If the
submodule is not found, they return -1 or NULL, respectively.

<pre>
int submodID = compoundmod-&gt;findSubmodule("child",5);
<a href="../api/classcModule.html">cModule</a> *submod = compoundmod-&gt;submodule("child",5);
</pre>
<p>

<p>The <tt>moduleByRelativePath()</tt> member function can be used to find
a submodule nested deeper than one level below. For example,

<pre>
compoundmod-&gt;moduleByRelativePath("child[5].grandchild");
</pre>
<p>
would give the same results as

<pre>
compoundmod-&gt;submodule("child",5)-&gt;submodule("grandchild");
</pre>
<p>
(Provided that <tt>child[5]</tt> does exist, because otherwise the second
version would crash with an access violation because of the NULL
pointer dereference.)

<p>
The <tt><a href="../api/classcSimulation.html">cSimulation</a></tt>::<tt>moduleByPath()</tt> function is similar
to <tt><a href="../api/classcModule.html">cModule</a></tt>'s <tt>moduleByRelativePath()</tt> function, and it
starts the search at the top-level module.

<p>
<p class="subheading">Iterating over submodules</p>

<p>
To access all modules within a compound module,
use <tt><a href="../api/classcSubModIterator.html">cSubModIterator</a></tt>.

<p>For example:

<pre>
for (<a href="../api/classcSubModIterator.html">cSubModIterator</a> iter(*parentModule()); !iter.end(); iter++)
{
  ev &lt;&lt; iter()-&gt;fullName();
}
</pre>
<p>
(<tt>iter()</tt> is pointer to the current module the iterator is at.)

<p>
The above method can also be used to iterate along a module
vector<!--module!vector!iteration-->, since the <tt>name()</tt>
function returns the same for all modules:

<pre>
for (<a href="../api/classcSubModIterator.html">cSubModIterator</a> iter(*parentModule()); !iter.end(); iter++)
{
  if (iter()-&gt;isName(name())) // if iter() is in the same
                              // vector as this module
  {
    int itsIndex = iter()-&gt;index();
    // do something to it
  }
}
</pre>
<p>

<p><p class="subheading">Walking along links</p>

<p>
To determine the module at the other end of a connection, use
<tt><a href="../api/classcGate.html">cGate</a></tt>'s <tt>fromGate()</tt>, <tt>toGate()</tt> and
<tt>ownerModule()</tt> functions. For example:

<pre>
<a href="../api/classcModule.html">cModule</a> *neighbour = gate( "outputgate" )-&gt;toGate()-&gt;ownerModule();
</pre>
<p>

<p>For input gates, you would use <tt>fromGate()</tt> instead of <tt>toGate()</tt>.

<p>
<H2><A NAME="sec197"/>4.10 Direct method calls between modules</H2>
<a name="ch:simple-modules:direct-method-calls"></a>
<!--method calls!between modules-->

<p>In some simulation models, there might be modules which are too
tightly coupled for message-based communication to be efficient.
In such cases, the solution might be calling one simple module's public
C++ methods from another module.

<p>Simple modules are C++ classes, so normal C++ method calls will
work. Two issues need to be mentioned, however:

<p><ul>
  <li> how to get a pointer to the object representing the module;
  <li> how to let the simulation kernel know that a method call across modules
     is taking place.
</ul>

<p>Typically, the called module is in the same compound module as the caller,
so the <tt>parentModule()</tt> and <tt>submodule()</tt> methods of
<tt><a href="../api/classcModule.html">cModule</a></tt> can be used to get a <tt><a href="../api/classcModule.html">cModule</a>*</tt> pointer to the
called module. (Further ways to obtain the pointer are described
in the section <a href="#sec196">[4.9]</a>.)
The <tt><a href="../api/classcModule.html">cModule</a>*</tt> pointer then has to be cast to the actual C++ class
of the module, so that its methods become visible.

<p>This makes the following code:

<pre>
<a href="../api/classcModule.html">cModule</a> *calleeModule = parentModule()-&gt;submodule("callee");
Callee *callee = check_and_cast&lt;Callee *&gt;(calleeModule);
callee-&gt;doSomething();
</pre>
<p>
The <tt>check_and_cast&lt;&gt;()</tt> template function on the second line
is part of OMNeT++. It does a standard C++ <tt>dynamic_cast</tt>,
and checks the result: if it is NULL, <tt>check_and_cast</tt> raises an OMNeT++ error.
Using <tt>check_and_cast</tt> saves you from writing error checking
code: if <tt>calleeModule</tt> from the first line is NULL because
the submodule named <tt>"callee"</tt> was not found, or if that
module is actually not of type <tt>Callee</tt>, an error gets thrown
from <tt>check_and_cast</tt>.

<p>The second issue is how to let the simulation kernel know that
a method call across modules is taking place. Why is this necessary
in the first place? First, the simulation kernel always has to know which
module's code is currently executing, in order to several internal
mechanisms to work correctly. (One such mechanism is ownership handling.)
Second, the Tkenv simulation GUI can animate method calls,
but to be able to do that, it has to know about them.

<p>The solution is to add the <tt>Enter_Method()</tt> or <tt>Enter_Method_Silent()</tt>
macro at the top of the methods that may be invoked from other
modules. These calls perform context switching, and, in case of
<tt>Enter_Method()</tt>, notify the simulation GUI so that animation
of the method call can take place. <tt>Enter_Method_Silent()</tt>
does not animate the call. <tt>Enter_Method()</tt> expects a
<tt>printf()</tt>-like argument list -- the resulting string will
be displayed during animation.

<pre>
void Callee::doSomething()
{
    Enter_Method("doSomething()");
    ...
}
</pre>
<p>

<p>
<H2><A NAME="sec198"/>4.11 Dynamic module creation</H2>
<a name="ch:simple-modules:dynamic-module-creation"></a>
<!--module!dynamic creation-->

<p><H3><A NAME="sec199"/>4.11.1 When do you need dynamic module creation</H3>

<p>In some situations you need to dynamically create and maybe destroy
modules. For example, when simulating a mobile network,
you may create a new module whenever a new user enters
the simulated area, and dispose of them when they leave the area.

<p>As another example, when implementing a server or a transport
protocol, it might be convenient to dymically create modules
to serve new connections, and dispose of them when the connection
is closed. (You would write a manager module that receives connection
requests and creates a module for each connection.
The Dyna example simulation does something like this.)

<p>Both simple and compound modules can be created dynamically.
If you create a compound module, all its submodules will be created
recursively.

<p>It is often convenient to use direct message sending with dynamically
created modules.

<p>Once created and started, dynamic modules aren't any different from
``static'' modules; for example, one could also delete static modules
during simulation (though it is rarely useful.)

<p>
<H3><A NAME="sec200"/>4.11.2 Overview</H3>

<p>
To understand how dynamic module creation works, you have to know a
bit about how normally OMNeT++ instantiates modules. Each module type
(class) has a corresponding factory object of the class
<tt><a href="../api/classcModuleType.html">cModuleType</a></tt>. This object is created under the hood by the
<tt>Define_Module()</tt> macro, and it has a factory
function<!--factory function--> which can instantiate the module
class (this function basically only consists of a <tt>return new
<i>module-class</i>(...)</tt> statement).

<p>The <tt><a href="../api/classcModuleType.html">cModuleType</a></tt> object can be looked up by its name
string (which is the same as the module class name). Once you have its
pointer, it is possible to call its factory method and create an
instance of the corresponding module class -- without having to
include the C++ header file containing module's class declaration
into your source file.

<p>The <tt><a href="../api/classcModuleType.html">cModuleType</a></tt> object also knows what gates and
parameters the given module type has to have. (This info comes from
compiled NED code.)

<p>Simple modules can be created in one step. For a compound module, the
situation is more complicated, because its internal structure
(submodules, connections) may depend on parameter values and gate
vector sizes. Thus, for compound modules it is generally required to
first create the module itself, second, set parameter values and gate
vector sizes, and then call the method that creates its submodules and
internal connections.

<p>As you know already, simple modules with <tt>activity()</tt> need a
starter message<!--starter messages-->. For statically created
modules, this message is created automatically by OMNeT++, but for
dynamically created modules, you have to do this explicitly by calling
the appropriate functions.

<p>Calling <tt>initialize()</tt> has to take place after insertion of the
starter messages, because the initializing code may insert new messages
into the FES<!--FES-->, and these messages should be processed
<i>after</i> the starter message.



<p><H3><A NAME="sec201"/>4.11.3 Creating modules</H3>

<p>The first step, finding the factory object:

<pre>
<a href="../api/classcModuleType.html">cModuleType</a> *moduleType = findModuleType("WirelessNode");
</pre>
<p>

<p><p class="subheading">Simplified form</p>

<p><tt><a href="../api/classcModuleType.html">cModuleType</a></tt> has a
<tt>createScheduleInit(const char *name, <a href="../api/classcModule.html">cModule</a> *parentmod)</tt>
convenience function to get a module up and running in one step.

<pre>
mod = modtype-&gt;createScheduleInit("node",this);
</pre>
<p>
It does <tt>create()</tt> + <tt>buildInside()</tt> +
<tt>scheduleStart(now)</tt> + <tt>callInitialize()</tt>.

<p>This method can be used for both simple and compound modules.
Its applicability is somewhat limited, however:
because it does everything in one step, you do not have the chance to
set parameters or gate sizes, and to connect gates before
<tt>initialize()</tt> is called.
(<tt>initialize()</tt> expects all parameters and gates to
be in place and the network fully built when it is called.)
Because of the above limitation, this function is mainly useful
for creating basic simple modules.


<p class="subheading">Expanded form</p>

<p>
If the previous simple form cannot be used. There are 5 steps:
<ol>
  <li>find factory object
  <li>create module
  <li>set up parameters and gate sizes (if needed)
  <li>call function that builds out submodules and finalizes the
    module
  <li>call function that creates activation message(s) for the new
    simple module(s)
</ol>
Each step (except for Step 3.) can be done with one line of code.

<p>

<p>See the following example, where Step 3 is omitted:

<pre>
// find factory object
<a href="../api/classcModuleType.html">cModuleType</a> *moduleType = findModuleType("WirelessNode");

// create (possibly compound) module and build its submodules (if any)
<a href="../api/classcModule.html">cModule</a> *module = moduleType-&gt;create("node", this);
module-&gt;buildInside();

// create activation message
module-&gt;scheduleStart( simTime() );
</pre>
<p>
If you want to set up parameter values or gate vector sizes (Step 3.),
the code goes between the <tt>create()</tt> and
<tt>buildInside()</tt> calls:

<pre>
// create
<a href="../api/classcModuleType.html">cModuleType</a> *moduleType = findModuleType("WirelessNode");
<a href="../api/classcModule.html">cModule</a> *module = moduleType-&gt;create("node", this);

// set up parameters and gate sizes before we set up its submodules
module-&gt;par("address") = ++lastAddress;
module-&gt;setGateSize("in", 3);
module-&gt;setGateSize("out", 3);

// create internals, and schedule it
module-&gt;buildInside();
module-&gt;scheduleStart(simTime());
</pre>
<p>

<p><H3><A NAME="sec202"/>4.11.4 Deleting modules</H3>

<p>
To delete a module dynamically<!--module!dynamic deletion-->:

<pre>
module-&gt;deleteModule();
</pre>
<p>
If the module was a compound module, this involves recursively
destroying all its submodules. A simple module can also delete itself;
in this case, the <tt>deleteModule()</tt> call does not return to the
caller.

<p>Currently, you cannot safely delete a
compound<!--module!compound!deletion--> module from a simple module
in it; you must delegate the job to a module outside the compound
module.

<p>
<H3><A NAME="sec203"/>4.11.5 Module deletion and finish()</H3>

<p>When you delete a module <i>during simulation</i>, its <tt>finish()</tt>
function is not called automatically (<tt>deleteModule()</tt> doesn't do it.)
How the module was created doesn't play any role here:
<tt>finish()</tt> gets called for <i>all</i> modules -- at the end of the
simulation. If a module doesn't live that long, <tt>finish()</tt> is not
invoked, but you can still manually invoke it.

<p>You can use the <tt>callFinish()</tt> function to arrange <tt>finish()</tt>
to be called. It is usually not a good idea to invoke <tt>finish()</tt>
directly. If you're deleting a compound module, <tt>callFinish()</tt> will
recursively invoke <tt>finish()</tt> for all submodules, and if you're deleting
a simple module from another module, <tt>callFinish()</tt> will do the context
switch for the duration of the call.
  <br><ul><font size=-1>[The <tt>finish()</tt> function is even made <tt>protected</tt>
  in <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>, in order to discourage its invocation from
  other modules.]</font></ul>

<p>Example:

<pre>
mod-&gt;callFinish();
mod-&gt;deleteModule();
</pre>
<p>

<p><H3><A NAME="sec204"/>4.11.6 Creating connections</H3>
<!--connection!creating-->

<p>Connections can be created using <tt><a href="../api/classcGate.html">cGate</a></tt>'s <tt>connectTo()</tt>
method.
  <br><ul><font size=-1>[The earlier <tt>connect()</tt> global functions that
  accepted two gates have been deprecated, and may be removed
  from further OMNeT++ releases.]</font></ul>
<tt>connectTo()</tt> should be invoked on the source gate
of the connection, and expects the destination gate pointer as
an argument:

<pre>
srcGate-&gt;connectTo(destGate);
</pre>
<p>
The <i>source</i> and <i>destination</i> words correspond
to the direction of the arrow in NED files.

<p>As an example, we create two modules and connect them in both directions:

<pre>
<a href="../api/classcModuleType.html">cModuleType</a> *moduleType = findModuleType("TicToc");
<a href="../api/classcModule.html">cModule</a> *a = modtype-&gt;createScheduleInit("a",this);
<a href="../api/classcModule.html">cModule</a> *b = modtype-&gt;createScheduleInit("b",this);

a-&gt;gate("out")-&gt;connectTo(b-&gt;gate("in"));
b-&gt;gate("out")-&gt;connectTo(a-&gt;gate("in"));
</pre>
<p>
<tt>connectTo()</tt> also accepts a channel object as an
additional, optional argument. Channels are subclassed from
<tt><a href="../api/classcChannel.html">cChannel</a></tt>. Almost always you'll want use an instance of
<tt><a href="../api/classcBasicChannel.html">cBasicChannel</a></tt> as channel -- this is the one that supports
delay<!--channel!delay-->, bit error rate <!--channel!error-->
and data rate<!--channel!datarate-->. The channel object will
be owned by the source gate of the connection, and you cannot
reuse the same channel object with several connections.

<p><tt><a href="../api/classcBasicChannel.html">cBasicChannel</a></tt> has <tt>setDelay()</tt>, <tt>setError()</tt>
and <tt>setDatarate()</tt> methods to set up the channel attributes.

<p>An example that sets up a channel with a delay:

<pre>
<a href="../api/classcBasicChannel.html">cBasicChannel</a> *channel = new <a href="../api/classcBasicChannel.html">cBasicChannel</a>("channel");
channel-&gt;setDelay(0.001);

a-&gt;gate("out")-&gt;connectTo(b-&gt;gate("in"), channel); // a,b are modules
</pre>
<p>

<p><H3><A NAME="sec205"/>4.11.7 Removing connections</H3>
<!--connection!removing-->

<p>The <tt>disconnect()</tt> method of <tt><a href="../api/classcGate.html">cGate</a></tt> can be
used to remove connections. This method has to be invoked
on the <i>source</i> side of the connection. It also destroys
the channel object associated with the connection, if one has been set.

<pre>
srcGate-&gt;disconnect();
</pre>
<p>

</BODY>
</HTML>
<hr><hr><H1><A NAME="sec206"/>5 Messages</H1>
<a name="cha:messages"></a>

<p><H2><A NAME="sec207"/>5.1 Messages and packets</H2>

<p><H3><A NAME="sec208"/>5.1.1 The <a href="../api/classcMessage.html">cMessage</a> class</H3>

<p><tt><a href="../api/classcMessage.html">cMessage</a></tt> is a central class in OMNeT++. Objects of <tt><a href="../api/classcMessage.html">cMessage</a></tt> and
subclasses may model a number of things: events<!--events-->;
messages<!--message-->; packets<!--packets-->,
frames<!--frames-->, cells<!--cells-->, bits or signals travelling
in a network; entities travelling in a system and so on.

<p>
<p class="subheading">Attributes</p>

<p>
A <tt><a href="../api/classcMessage.html">cMessage</a></tt> object has number of attributes. Some are used by
the simulation kernel, others are provided just for the convenience
of the simulation programmer. A more-or-less complete list:

<p><ul>
  <li>The <i>name</i> attribute is a string (<tt>const char *</tt>),
    which can be freely used by the simulation programmer. The message
    name appears in many places in Tkenv (for example, in animations),
    and it is generally very useful to choose a descriptive name.
    This attribute is inherited from <tt><a href="../api/classcObject.html">cObject</a></tt> (see section
    <a href="#sec225">[6.1.1]</a>).
  <li>The <i>message kind</i> attribute is supposed to carry some message
    type information. Zero and positive values can be freely used
    for any purpose. Negative values are reserved for use by the
    OMNeT++ simulation library.
  <li>The <i>length</i> attribute (understood in bits) is used to compute
    transmission delay when the message travels through a connection
    that has an assigned data rate.
  <li>The <i>bit error flag</i> attribute is set to true by the simulation
    kernel with a probability of <i>1-(1-<i>ber</i>)<sup><i>length</sup></i></i> when the
    message is sent through a connection that has an assigned bit
    error rate (<i>ber</i>).
  <li>The <i>priority</i> attribute is used by the simulation kernel to
    order messages in the message queue (FES<!--FES-->) that have the same
    arrival time values.
  <li>The <i>time stamp</i> attribute is not used by the simulation kernel;
    you can use it for purposes such as noting the time when the
    message was enqueued or re-sent.
  <li>Other attributes and data members make simulation programming
    easier, they will be discussed later: <i>parameter list</i>, <i>encapsulated
      message</i>, <i>control info</i> and <i>context pointer</i>.
  <li>A number of read-only attributes store information about the
    message's (last) sending/scheduling: <i>source/destination module
      and gate</i>, <i>sending (scheduling) and arrival time</i>. They are
    mostly used by the simulation kernel while the message is in
    the FES<!--FES-->, but the information is still in the message object when
    a module receives the message.
</ul>

<p>
<p class="subheading">Basic usage</p>

<p>
The <tt><a href="../api/classcMessage.html">cMessage</a></tt> constructor accepts several arguments.
Most commonly, you would create a message using an <i>object name</i>
(a <tt>const char *</tt> string) and a <i>message kind</i> (<tt>int</tt>):

<pre>
<a href="../api/classcMessage.html">cMessage</a> *msg = new <a href="../api/classcMessage.html">cMessage</a>("MessageName", msgKind);
</pre>
<p>
Both arguments are optional and initialize to the null string (<tt>""</tt>)
and 0, so the following statements are also valid:

<pre>
<a href="../api/classcMessage.html">cMessage</a> *msg = new <a href="../api/classcMessage.html">cMessage</a>();
<a href="../api/classcMessage.html">cMessage</a> *msg = new <a href="../api/classcMessage.html">cMessage</a>("MessageName");
</pre>
<p>
It is a good idea to <i>always</i> use message names -- they can be
extremely useful when debugging or demonstrating your simulation.

<p>Message kind is usually initialized with a symbolic constant
(e.g. an <i>enum</i> value) which signals what the message object
represents in the simulation (i.e. a data packet, a jam signal, a job, etc.)
Please use <i>positive values or zero</i> only as message kind --
negative values are reserved for use by the simulation kernel.

<p>
The <tt><a href="../api/classcMessage.html">cMessage</a></tt> constructor accepts further arguments too
(<i>length</i>, <i>priority</i>, <i>bit error flag</i>),
but for readability of the code it is best to set them explicitly
via the <tt>set...()</tt> methods described below.
Length and priority are integers, and the bit error flag is boolean.

<p><!--message!data members-->

<p>Once a message has been created, its data members can be changed by the following functions:

<pre>
msg-&gt;setKind( kind );
msg-&gt;setLength( length );
msg-&gt;setByteLength( lengthInBytes );
msg-&gt;setPriority( priority );
msg-&gt;setBitError( err );
msg-&gt;setTimestamp();
msg-&gt;setTimestamp( simtime );
</pre>
<p>
With these functions the user can set the message
kind<!--message!kind-->, the message length<!--message@length-->,
the priority<!--message!priority-->, the error
flag<!--message!error flag--> and the time stamp<!--message!time
  stamp-->. The <tt>setTimeStamp()</tt> function without any argument
sets the time stamp to the current simulation time.
<tt>setByteLength()</tt> sets the same length field as <tt>setLength()</tt>,
only the parameters gets internally multiplied by 8.

<p>The values can be obtained by the following functions:

<pre>
int k       = msg-&gt;kind();
int p       = msg-&gt;priority();
int l       = msg-&gt;length();
int lb      = msg-&gt;byteLength();
bool b      = msg-&gt;hasBitError();
simtime_t t = msg-&gt;timestamp();
</pre>
<p>
<tt>byteLength()</tt> also reads the length field as <tt>length()</tt>,
but the result gets divided by 8 and rounded up.

<p>
<p class="subheading">Duplicating messages</p>
<!--message!duplication-->

<p>It is often necessary to duplicate a message (for example, sending
one and keeping a copy). This can be done in the same way as
for any other OMNeT++ object:

<pre>
<a href="../api/classcMessage.html">cMessage</a> *copy = (<a href="../api/classcMessage.html">cMessage</a> *) msg-&gt;dup();
</pre>
<p>
or

<pre>
<a href="../api/classcMessage.html">cMessage</a> *copy = new <a href="../api/classcMessage.html">cMessage</a>( *msg );
</pre>
<p>

<p>The two are equivalent. The resulting message is an exact copy
of the original, including message parameters (<tt><a href="../api/classcPar.html">cPar</a></tt> or other
object types) and encapsulated messages.

<p>
<H3><A NAME="sec209"/>5.1.2 Self-messages</H3>

<p><p class="subheading">Using a message as self-message</p>

<p>Messages are often used to represent events internal to a module,
such as a periodically firing timer on expiry of a timeout.
A message is termed <i>self-message</i> when it is used
in such a scenario -- otherwise self-messages are normal messages,
of class <tt><a href="../api/classcMessage.html">cMessage</a></tt> or a class derived from it.

<p>When a message is delivered to a module by the simulation kernel,
you can call the <tt>isSelfMessage()</tt> method to determine if it is
a self-message; it other words, if it was scheduled with
<tt>scheduleAt()</tt> or was sent with one of the
<tt>send...()</tt> methods. The <tt>isScheduled()</tt> method
returns true if the message is currently scheduled. A scheduled
message can also be cancelled (<tt>cancelEvent()</tt>).

<p><pre>
bool <tt>isSelfMessage()</tt>;
bool <tt>isScheduled()</tt>;
</pre>

<p>The following methods return the time of creating and scheduling the message
as well as its arrival time. While the message is scheduled, arrival
time is the time it will be delivered to the module.

<p><pre>
simtime_t <tt>creationTime()</tt>
simtime_t <tt>sendingTime()</tt>;
simtime_t <tt>arrivalTime()</tt>;
</pre>

<p><p class="subheading">Context pointer</p>

<p><tt><a href="../api/classcMessage.html">cMessage</a></tt> contains a <tt>void*</tt> pointer which is
set/returned by the <tt>setContextPointer()</tt> and
<tt>contextPointer()</tt> functions:

<pre>
void *context =...;
msg-&gt;setContextPointer( context );
void *context2 = msg-&gt;contextPointer();
</pre>
<p>

<p>It can be used for any purpose by the simulation programmer.
It is not used by the simulation kernel, and it is treated as
a mere pointer (no memory management is done on it).

<p>Intended purpose: a module which schedules several self-messages
(timers) will need to identify a self-message when it arrives back to
the module, ie. the module will have to determine which timer went off
and what to do then. The context pointer<!--context pointer--> can be
made to point at a data structure kept by the module which can carry
enough ``context'' information about the event.

<p>

<p><H3><A NAME="sec210"/>5.1.3 Modelling packets</H3>

<p><p class="subheading">Arrival gate and time</p>

<p>The following methods can tell where the message came from and
where it arrived (or will arrive if it is currently scheduled or under way.)

<p><pre>
int <tt>senderModuleId()</tt>;
int <tt>senderGateId()</tt>;
int <tt>arrivalModuleId()</tt>;
int <tt>arrivalGateId()</tt>;
</pre>

<p>The following methods are just convenience functions which build
on the ones above.

<p><pre>
<a href="../api/classcModule.html">cModule</a> *<tt>senderModule()</tt>;
<a href="../api/classcGate.html">cGate</a> *<tt>senderGate()</tt>;
<a href="../api/classcGate.html">cGate</a> *<tt>arrivalGate()</tt>;
</pre>

<p>And there are further convenience functions to tell whether
the message arrived on a specific gate given with id or
name+index.

<p><pre>
bool <tt>arrivedOn</tt>(int id);
bool <tt>arrivedOn</tt>(const char *gname, int gindex=0);
</pre>

<p>The following methods return message creation time and the last sending
and arrival times.

<p><pre>
simtime_t <tt>creationTime()</tt>
simtime_t <tt>sendingTime()</tt>;
simtime_t <tt>arrivalTime()</tt>;
</pre>

<p><p class="subheading">Control info</p>

<p>One of the main application areas of OMNeT++ is the simulation of
telecommunication networks. Here, protocol layers are usually
implemented as modules which exchange packets. Packets themselves
are represented by messages subclassed from <tt><a href="../api/classcMessage.html">cMessage</a></tt>.

<p>However, communication between protocol layers requires sending
additional information to be attached to packets. For example,
a TCP implementation sending down a TCP packet to IP will want
to specify the destination IP address and possibly
other parameters. When IP passes up a packet to TCP after
decapsulation from the IP header, it'll want to let TCP know
at least the source IP address.

<p>This additional information is represented by <i>control info</i>
objects in OMNeT++. Control info objects have to be subclassed from
<tt><a href="../api/classcPolymorphic.html">cPolymorphic</a></tt> (a small footprint base class with
no data members), and attached to the messages representing
packets. <tt><a href="../api/classcMessage.html">cMessage</a></tt> has the following methods for this
purpose:

<p><pre>
void <tt>setControlInfo(<a href="../api/classcPolymorphic.html">cPolymorphic</a> *controlInfo)</tt>;
<a href="../api/classcPolymorphic.html">cPolymorphic</a> *<tt>controlInfo()</tt>;
<a href="../api/classcPolymorphic.html">cPolymorphic</a> *<tt>removeControlInfo()</tt>;
</pre>

<p>When a "command" is associated with the message sending (such as
TCP OPEN, SEND, CLOSE, etc), the message kind field (<tt>kind()</tt>,
<tt>setKind()</tt> methods of <tt><a href="../api/classcMessage.html">cMessage</a></tt>) should carry the command code.
When the command doesn't involve a data packet (e.g.
TCP CLOSE command), a dummy packet (empty <tt><a href="../api/classcMessage.html">cMessage</a></tt>) can be sent.

<p>

<p><p class="subheading">Identifying the protocol</p>

<p>In OMNeT++ protocol models, the protocol type is usually represented
in the message subclass. For example, instances of class
<tt>IPv6Datagram</tt> represent IPv6 datagrams and <tt>EthernetFrame</tt>
represents Ethernet frames) and/or in the message kind value.
The PDU type is usually represented as a field inside the message class.

<p>The C++ <tt>dynamic_cast</tt> operator can be used to determine
if a message object is of a specific protocol.

<pre>
<a href="../api/classcMessage.html">cMessage</a> *msg = receive();
if (dynamic_cast&lt;IPv6Datagram *&gt;(msg) != NULL)
{
    IPv6Datagram *datagram = (IPv6Datagram *)msg;
    ...
}
</pre>
<p>

<p><H3><A NAME="sec211"/>5.1.4 Encapsulation</H3>

<p><p class="subheading">Encapsulating packets</p>

<p>It is often necessary to encapsulate a
message<!--message!encapsulation--> into another when you're modeling
layered protocols of computer networks. Although you can encapsulate
messages by adding them to the parameter list, there's a better way.

<p>
The <tt>encapsulate()</tt> function encapsulates a message
into another one. The length of the message will grow by the length of
the encapsulated message. An exception: when the encapsulating (outer)
message has zero length, OMNeT++ assumes it is not a real packet but
some out-of-band signal, so its length is left at zero.

<pre>
<a href="../api/classcMessage.html">cMessage</a> *userdata = new <a href="../api/classcMessage.html">cMessage</a>("userdata");

userdata-&gt;setByteLength(2048);  // 2K
<a href="../api/classcMessage.html">cMessage</a> *tcpseg = new <a href="../api/classcMessage.html">cMessage</a>("tcp");
tcpseg-&gt;setByteLength(24);
tcpseg-&gt;encapsulate(userdata);
ev &lt;&lt; tcpseg-&gt;byteLength() &lt;&lt; endl; // --&gt; 2048+24 = 2072
</pre>
<p>
A message can only hold one encapsulated message at a time. The
second <tt>encapsulate()</tt> call will result in an error. It is also
an error if the message to be encapsulated isn't owned by the
module.

<p>You can get back the encapsulated message by <tt>decapsulate()</tt>:

<pre>
<a href="../api/classcMessage.html">cMessage</a> *userdata = tcpseg-&gt;decapsulate();
</pre>
<p>
<tt>decapsulate()</tt> will decrease the length of the message accordingly,
except if it was zero. If the length would become negative, an
error occurs.

<p>The <tt>encapsulatedMsg()</tt> function returns a pointer to the encapsulated
message, or <tt>NULL</tt> if no message was encapsulated.

<p><p class="subheading">Reference counting<sup><b>[New!]</b></sup></p>

<p>Since the 3.2 release, OMNeT++ implements reference counting of
encapsulated messages, meaning that if you <tt>dup()</tt> a message
that contains an encapsulated message, then the encapsulated message will
not be duplicated, only a reference count incremented. Duplication of
the encapsulated message is deferred until <tt>decapsulate()</tt>
actually gets called. If the outer message gets deleted without its
<tt>decapsulate()</tt> method ever being called, then the reference
count of the encapsulated message simply gets decremented. The
encapsulated message is deleted when its reference count reaches
zero.

<p>Reference counting can significantly improve performance, especially
in LAN and wireless scenarios. For example, in the simulation of a
broadcast LAN or WLAN, the IP, TCP and higher layer packets won't
get duplicated (and then discarded without being used) if the
MAC address doesn't match in the first place.

<p>The reference counting mechanism works transparently. However, there
is one implication: <b>one must not change anything in a message
that is encapsulated into another!</b> That is,
<tt>encapsulatedMsg()</tt> should be viewed as if it returned a
pointer to a read-only object (it returns a <tt>const</tt> pointer
indeed), for quite obvious reasons: the encapsulated message may be
shared between several messages, and any change would affect those
other messages as well.

<p>
<p class="subheading">Encapsulating several messages</p>

<p>The <tt><a href="../api/classcMessage.html">cMessage</a></tt> class doesn't directly support adding more than one
messages to a message object, but you can subclass <tt><a href="../api/classcMessage.html">cMessage</a></tt>
and add the necessary functionality. (It is recommended that you
use the message definition syntax <a href="#sec213">[5.2]</a>
and customized messages <a href="#sec219">[5.2.6]</a>
to be described later on in this chapter -- it can spare you some work.)

<p>You can store the messages in a fixed-size or a dynamically allocated
array, or you can use STL classes like <tt>std::vector</tt> or <tt>std::list</tt>.
There is one additional ``trick'' that you might not expect: your message
class has to <b>take ownership</b> of the inserted messages, and
<b>release</b> them when they are removed from the message. These are
done via the <tt>take()</tt> and <tt>drop()</tt> methods. Let us see
an example which assumes you have added to the class an <tt>std::list</tt> member
called <tt>messages</tt> that stores message pointers:

<pre>
void MessageBundleMessage::insertMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    take(msg);  // take ownership
    messages.push_back(msg);  // store pointer
}

void MessageBundleMessage::removeMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    messages.remove(msg);  // remove pointer
    drop(msg);  // release ownership
}
</pre>
<p>
You will also have to provide an <tt>operator=()</tt> method to
make sure your message objects can be copied and duplicated
properly -- this is something often needed in simulations
(think of broadcasts and retransmissions!). Section
<a href="#sec269">[6.11]</a> contains more info
about the things you need to take care of when deriving new classes.

<p>

<p><H3><A NAME="sec212"/>5.1.5 Attaching parameters and objects</H3>

<p>If you want to add parameters or objects to a message, the preferred
way to do that is via message definitions, described in chapter
<a href="#sec213">[5.2]</a>.

<p>
<p class="subheading">Attaching objects</p>

<p>The <tt><a href="../api/classcMessage.html">cMessage</a></tt> class has an internal <tt><a href="../api/classcArray.html">cArray</a></tt> object which can
carry objects<!--message!attaching objects-->. Only objects
that are derived from <tt><a href="../api/classcObject.html">cObject</a></tt> (most OMNeT++ classes are so) can be attached.
The <tt>addObject()</tt>, <tt>getObject()</tt>, <tt>hasObject()</tt>,
<tt>removeObject()</tt> methods use the object name
as the key to the array. An example:

<pre>
<a href="../api/classcLongHistogram.html">cLongHistogram</a> *pklenDistr = new <a href="../api/classcLongHistogram.html">cLongHistogram</a>("pklenDistr");
msg-&gt;addObject( pklenDistr );
...
if (msg-&gt;hasObject("pklenDistr"))
{
   <a href="../api/classcLongHistogram.html">cLongHistogram</a> *pklenDistr =
       (<a href="../api/classcLongHistogram.html">cLongHistogram</a> *) msg-&gt;getObject("pklenDistr");
   ...
}
</pre>
<p>
You should take care that names of the attached objects do not
clash with each other or with <tt><a href="../api/classcPar.html">cPar</a></tt> parameter names
(see next section).
If you do not attach anything to the message and do not call the
<tt>parList()</tt> function, the internal <tt><a href="../api/classcArray.html">cArray</a></tt> object
will not be created.
This saves both storage and execution time.

<p>You can attach non-object types (or non-<tt><a href="../api/classcObject.html">cObject</a></tt> objects) to
the message<!--message!attaching non-object types--> by using
<tt><a href="../api/classcPar.html">cPar</a></tt>'s <tt>void*</tt> pointer 'P') type (see later in the description
of <tt><a href="../api/classcPar.html">cPar</a></tt>). An example:

<pre>
struct conn_t *conn = new conn_t; // conn_t is a C struct
msg-&gt;addPar("conn") = (void *) conn;
msg-&gt;par("conn").configPointer(NULL,NULL,sizeof(struct conn_t));
</pre>
<p>

<p>

<p><p class="subheading">Attaching parameters</p>

<p>The preferred way of extending messages with new data fields is to use
message definitions (see section <a href="#sec213">[5.2]</a>).

<p>The old, deprecated way of adding new fields to messages is via
attaching <tt><a href="../api/classcPar.html">cPar</a></tt> objects.
There are several downsides of this approach, the worst being
large memory and execution time overhead. <tt><a href="../api/classcPar.html">cPar</a></tt>'s are
heavy-weight and fairly complex objects themselves.
It has been reported that using <tt><a href="../api/classcPar.html">cPar</a></tt> message parameters
might account for a large part of execution time, sometimes as much as 80%.
Using <tt><a href="../api/classcPar.html">cPar</a></tt>s is also error-prone because <tt><a href="../api/classcPar.html">cPar</a></tt> objects
have to be added dynamically and individually to each message object.
In contrast, subclassing benefits from static type checking:
if you mistype the name of a field in the C++ code, already the compiler
can detect the mistake.

<p>
However, if you still need to use cPars, here's a short summary
how you can do it. You add a new parameter to the message with the
<tt>addPar()</tt> member function, and get back a reference
to the parameter object with the <tt>par()</tt> member function.
<tt>hasPar()</tt> tells you if the message has a
given parameter or not.
Message parameters can be accessed also by index in the parameter
array. The <tt>findPar()</tt> function returns the index of a parameter
or -1 if the parameter cannot be found. The parameter can then be
accessed using an overloaded <tt>par()</tt> function.

<p>Example:

<pre>
msg-&gt;addPar("destAddr");
msg-&gt;par("destAddr") = 168;
...
long destAddr = msg-&gt;par("destAddr");
</pre>
<p>


<p><H2><A NAME="sec213"/>5.2 Message definitions</H2>
<a name="ch:messages:message-definitions"></a>

<p><H3><A NAME="sec214"/>5.2.1 Introduction</H3>

<p>In practice, you'll need to add various fields to <tt><a href="../api/classcMessage.html">cMessage</a></tt> to
make it useful. For example, if you're modelling packets in communication
networks, you need to have a way to store protocol header fields in message
objects. Since the simulation library is written in C++, the natural way
of extending <tt><a href="../api/classcMessage.html">cMessage</a></tt> is via subclassing it.
However, because for each field you need to write at least
three things (a private data member, a getter and a setter method),
and the resulting class has to integrate with the simulation framework,
writing the necessary C++ code can be a tedious and time-consuming task.

<p>OMNeT++ offers a more convenient way called <i>message definitions</i>.
Message definitions provide a very compact syntax to describe
message contents. C++ code is automatically generated from message
definitions, saving you a lot of typing.

<p>A common source of complaint about code generators in general is
lost flexibility: if you have a different idea how the generated
code should look like, there's little you can do about it.
In OMNeT++, however, there's nothing to worry about: you can
customize the generated class to any extent you like.
Even if you decide to heavily customize the generated class,
message definitions still save you a great deal of manual work.

<p>The message subclassing feature in OMNeT++ is still somewhat experimental,
meaning that:

<p><ul>
  <li> The message description syntax and features may slightly change
    in the future, based on feedback from the community;
  <li> The compiler that translates message descriptions into C++ is
    a perl script <tt>opp_msgc</tt>. This is a temporary solution until
    the C++-based <tt>nedtool</tt> is finished.
</ul>

<p>The subclassing approach for adding message parameters was originally
suggested by Nimrod Mesika.

<p>
<p class="subheading">The first message class</p>

<p>Let us begin with a simple example. Suppose that you need message objects to
carry source and destination addresses as well as a hop count. You could write
a <tt>mypacket.msg</tt> file with the following contents:

<p><pre>
<b>message</b> MyPacket
{
    <b>fields</b>:
       <b>int</b> srcAddress;
       <b>int</b> destAddress;
       <b>int</b> hops = 32;
};
</pre>

<p>The task of the <i>message subclassing compiler</i> is to generate C++ classes
you can use from your models as well as ``reflection'' classes that allow
Tkenv to inspect these data stuctures.

<p>If you process <tt>mypacket.msg</tt> with the message subclassing compiler, it will
create the following files for you: <tt>mypacket_m.h</tt> and <tt>mypacket_m.cc</tt>.
<tt>mypacket_m.h</tt> contains the declaration of the <tt>MyPacket</tt> C++ class, and
it should be included into your C++ sources where you need to handle
<tt>MyPacket</tt> objects.

<p>The generated <tt>mypacket_m.h</tt> will contain the following class declaration:

<pre>
class MyPacket : public <a href="../api/classcMessage.html">cMessage</a> {
    ...
    virtual int getSrcAddress() const;
    virtual void setSrcAddress(int srcAddress);
    ...
};
</pre>
<p>
So in your C++ file, you could use the <tt>MyPacket</tt> class like this:

<pre>
#include "mypacket_m.h"

...
MyPacket *pkt = new MyPacket("pkt");
pkt-&gt;setSrcAddress( localAddr );
...
</pre>
<p>
The <tt>mypacket_m.cc</tt> file contains implementation of the generated <tt>MyPacket</tt>
class, as well as ``reflection'' code that allows you to inspect these data
stuctures in the Tkenv GUI. The <tt>mypacket_m.cc</tt> file should be compiled and
linked into your simulation. (If you use the <tt>opp_makemake</tt> tool
to generate your makefiles, the latter will be automatically taken care of.)

<p>
<p class="subheading">What is message subclassing <i>not?</i></p>

<p>There might be some confusion around the purpose and
concept of message definitions, so it seems to be a good idea
to deal with them right here.

<p>It is <i><b>not:</b></i>

<p><ul>
  <li><i>... an attempt to reproduce the functionality of C++ with another
     syntax.</i> Do not look for complex C++ types, templates, conditional compilation, etc.
     Also, it defines <i>data</i> only (or rather: an interface to access
     data) -- not any kind of active behaviour.
  <li><i>... a generic class generator.</i> This is meant for defining message
     contents, and data structure you put in messages.
     Defining methods is not supported on purpose.
     Also, while you can probably (ab)use the syntax to
     generate classes and structs used internally in simple modules,
     this is probably not a good idea.
</ul>

<p>The goal is to define the <i>interface</i> (getter/setter methods) of messages
rather than their implementations in C++. A simple and straightforward
implementation of fields is provided -- if you'd like a different internal
representation for some field, you can have it by customizing the class.

<p>There are questions you might ask:

<p><ul>
  <li><i>Why doesn't it support <tt>std::vector</tt> and other STL classes?</i>
     Well, it does. Message definitions focus on the interface
     (getter/setter methods) of the classes, optionally leaving the implementation
     to you -- so you can implement fields (dynamic array fields)
     using <tt>std::vector</tt>.
     (This aligns with the idea behind STL -- it was designed to be
     <i>nuts and bolts</i> for C++ programs).
  <li><i>Why does it support C++ data types and not octets,
     bytes, bits, etc..?</i>
     That would restrict the scope of message definitions to networking,
     and OMNeT++ wants to support other application areas as well.
     Furthermore, the set of necessary concepts to be supported is
     probably not bounded, there would always be new data types to
     be adopted.
  <li><i>Why no embedded classes?</i> Good question. As it does not
     conflict with the above principles, it might be added someday.
</ul>

<p>

<p>The following sections describe the message syntax and features in detail.

<p>
<H3><A NAME="sec215"/>5.2.2 Declaring enums</H3>

<p>An <tt>enum {..}</tt> generates a normal C++ enum, plus creates an object
which stores text representations of the constants. The latter makes it possible
to display symbolic names in Tkenv.
An example:

<p><pre>
<b>enum</b> ProtocolTypes
{
   IP = 1;
   TCP = 2;
};
</pre>

<p>Enum values need to be unique.

<p>

<H3><A NAME="sec216"/>5.2.3 Message declarations</H3>

<p><p class="subheading">Basic use</p>

<p>You can describe messages with the following syntax:

<p><pre>
<b>message</b> FooPacket
{
    <b>fields</b>:
        <b>int</b> sourceAddress;
        <b>int</b> destAddress;
        <b>bool</b> hasPayload;
};
</pre>

<p>Processing this description with the message compiler will produce
a C++ header file with a generated class, <tt>FooPacket</tt>.
<tt>FooPacket</tt> will be a subclass of <tt><a href="../api/classcMessage.html">cMessage</a></tt>.

<p>For each field in the above description, the generated class will have
a protected data member, a getter and a setter method. The names of the
methods will begin with <tt>get</tt> and <tt>set</tt>,
followed by the field name with its first letter converted to uppercase.
Thus, <tt>FooPacket</tt> will contain the following methods:

<pre>
virtual int getSourceAddress() const;
virtual void setSourceAddress(int sourceAddress);

virtual int getDestAddress() const;
virtual void setDestAddress(int destAddress);

virtual bool getHasPayload() const;
virtual void setHasPayload(bool hasPayload);
</pre>
<p>
Note that the methods are all declared <tt>virtual</tt> to give you the possibility
of overriding them in subclasses.

<p>Two constructors will be generated: one that optionally accepts object name and
(for <tt><a href="../api/classcMessage.html">cMessage</a></tt> subclasses) message kind, and a copy constructor:

<pre>
FooPacket(const char *name=NULL, int kind=0);
FooPacket(const FooPacket& other);
</pre>
<p>
Appropriate assignment operator (<tt>operator=()</tt>) and <tt>dup()</tt> methods will
also be generated.

<p>Data types for fields are not limited to <tt>int</tt> and <tt>bool</tt>. You can use the
following primitive types (i.e. primitive types as defined in the C++ language):

<p><ul>
   <li> <tt>bool</tt>
   <li> <tt>char</tt>, <tt>unsigned char</tt>
   <li> <tt>short</tt>, <tt>unsigned short</tt>
   <li> <tt>int</tt>, <tt>unsigned int</tt>
   <li> <tt>long</tt>, <tt>unsigned long</tt>
   <li> <tt>double</tt>
</ul>

<p>Field values are initialized to zero.

<p>
<p class="subheading">Initial values</p>

<p>You can initialize field values with the following syntax:

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
        <b>int</b> sourceAddress = 0;
        <b>int</b> destAddress = 0;
        <b>bool</b> hasPayload = false;
};
</pre>

<p>Initialization code will be placed in the constructor of the generated class.

<p>
<p class="subheading">Enum declarations</p>

<p>You can declare that an <tt>int</tt> (or other integral type) field
takes values from an enum. The message compiler can than generate code
that allows Tkenv display the symbolic value of the field.

<p>Example:

<p><pre>
<b>message</b> FooPacket
{
  <b>fields</b>:
      <b>int</b> payloadType <b>enum</b>(PayloadTypes);
};
</pre>

<p>The enum has to be declared separately in the message file.

<p>
<p class="subheading">Fixed-size arrays</p>

<p>You can specify fixed size arrays:

<p><pre>
<b>message</b> FooPacket
{
    <b>fields</b>:
        <b>long</b> route[4];
};
</pre>

<p>The generated getter and setter methods will have an extra <tt>k</tt> argument,
the array index:

<pre>
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
</pre>
<p>
If you call the methods with an index that is out of bounds, an exception
will be thrown.

<p>
<p class="subheading">Dynamic arrays</p>

<p>If the array size is not known in advance, you can declare the field
to be a dynamic array:

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
       <b>long</b> route[];
};
</pre>

<p>In this case, the generated class will have two extra methods in addition
to the getter and setter methods: one for setting the array size, and another
one for returning the current array size.

<pre>
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
virtual unsigned getRouteArraySize() const;
virtual void setRouteArraySize(unsigned n);
</pre>
<p>
The <tt>set...ArraySize()</tt> method internally allocates a new array. Existing
values in the array will be preserved (copied over to the new array.)

<p>The default array size is zero. This means that you need to call the
<tt>set...ArraySize()</tt> before you can start filling array elements.

<p>
<p class="subheading">String members</p>

<p>You can declare string-valued fields with the following syntax:

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
       <b>string</b> hostName;
};
</pre>

<p>The generated getter and setter methods will return and accept <tt>const char*</tt>
pointers:

<pre>
virtual const char *getHostName() const;
virtual void setHostName(const char *hostName);
</pre>
<p>
The generated object will have its own copy of the string.

<p>NOTE: a string member is different from a character array,
which is treated as an array of any other type. For example,

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
       <b>char</b> chars[10];
};
</pre>

<p>will generate the following methods:

<pre>
virtual char getChars(unsigned k);
virtual void setChars(unsigned k, char a);
</pre>
<p>

<p><H3><A NAME="sec217"/>5.2.4 Inheritance, composition</H3>

<p>So far we have discussed how to add fields of primitive types
(<tt>int</tt>, <tt>double</tt>, <tt>char</tt>, ...) to <tt><a href="../api/classcMessage.html">cMessage</a></tt>.
This might be sufficient for simple models, but if you have
more complex models, you'll probably need to:

<p><ul>
  <li> set up a hierarchy of message (packet) classes, that is,
    not only subclass from <tt><a href="../api/classcMessage.html">cMessage</a></tt> but also from your
    own message classes;
  <li> use not only primitive types as fields, but also structs,
    classes or typedefs. Sometimes you'll want to use a C++ type
    present in an already existing header file, another time you'll
    want a struct or class to be generated by the message
    compiler so that you can benefit from Tkenv inspectors.
</ul>

<p>The following section describes how to do this.

<p>
<p class="subheading">Inheritance among message classes</p>

<p>By default, messages are subclassed from <tt><a href="../api/classcMessage.html">cMessage</a></tt>. However, you can
explicitly specify the base class using the <tt>extends</tt> keyword:

<p><pre>
<b>message</b> FooPacket <b>extends</b> FooBase
{
    <b>fields</b>:
        ...
};
</pre>

<p>For the example above, the generated C++ code will look like:

<pre>
class FooPacket : public FooBase { ... };
</pre>
<p>
Inheritance also works for structs and classes (see next sections
for details).

<p>

<p><p class="subheading">Defining classes</p>

<p>Until now we have used the <tt>message</tt> keyword to define classes, which
implies that the base class is <tt><a href="../api/classcMessage.html">cMessage</a></tt>, either directly or indirectly.

<p>But as part of complex messages, you'll need structs and other classes
(rooted or not rooted in <tt><a href="../api/classcObject.html">cObject</a></tt>) as building blocks.
Classes can be created with the <tt>class</tt> class keyword;
structs we'll cover in the next section.

<p>The syntax for defining classes is almost the same as defining messages,
only the <tt>class</tt> keyword is used instead of <tt>message</tt>.

<p>Slightly different code is generated for classes that are rooted in
<tt><a href="../api/classcObject.html">cObject</a></tt> than for those which are not.
If there is no <tt>extends</tt>, the generated class will not be
derived from <tt><a href="../api/classcObject.html">cObject</a></tt>, thus it will not have <tt>name()</tt>,
<tt>className()</tt>, etc. methods.
To create a class with those methods, you have to explicitly write
<tt>extends <a href="../api/classcObject.html">cObject</a></tt>.

<p><pre>
<b>class</b> MyClass <b>extends</b> <a href="../api/classcObject.html">cObject</a>
{
    <b>fields</b>:
        ...
};
</pre>

<p>

<p><p class="subheading">Defining plain C structs</p>

<p>You can define C-style structs to be used as fields in message classes,
``C-style'' meaning ``containing only data and no methods''.
(Actually, in the C++ a struct can have methods,
and in general it can do anything a class can.)

<p>The syntax is similar to that of defining messages:

<p><pre>
<b>struct</b> MyStruct
{
    <b>fields</b>:
        <b>char</b> array[10];
        <b>short</b> version;
};
</pre>

<p>However, the generated code is different. The generated struct has
no getter or setter methods, instead the fields are represented
by public data members. For the definition above, the
following code is generated:

<pre>
// generated C++
struct MyStruct
{
    char array[10];
    short version;
};
</pre>
<p>
A struct can have primitive types or other structs as fields. It cannot
have string or class as field.

<p>Inheritance is supported for structs:

<p><pre>
<b>struct</b> Base
{
    ...
};

<b>struct</b> MyStruct extends Base
{
    ...
};
</pre>

<p>But because a struct has no member functions, there are limitations:

<p><ul>
   <li> dynamic arrays are not supported (no place for the array allocation code)
   <li> ``generation gap'' or abstract fields (see later) cannot be used,
      because they would build upon virtual functions.
</ul>

<p>
<p class="subheading">Using structs and classes as fields</p>

<p>In addition to primitive types, you can also use other structs or objects
as a field. For example, if you have a struct named <tt>IPAddress</tt>,
you can write the following:

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
       IPAddress src;
};
</pre>

<p>The <tt>IPAddress</tt> structure must be known in advance to the message compiler;
that is, it must either be a struct or class defined earlier in the message
description file, or it must be a C++ type with its header file
included via <tt>cplusplus {{...}}</tt> and its type announced
(see Announcing C++ types).

<p>The generated class will contain an <tt>IPAddress</tt> data member
(that is, <b>not</b> a pointer to an <tt>IPAddress</tt>).
The following getter and setter methods will be generated:

<pre>
virtual const IPAddress& getSrc() const;
virtual void setSrc(const IPAddress& src);
</pre>
<p>

<p><p class="subheading">Pointers</p>

<p>Not supported yet.

<p>

<p><H3><A NAME="sec218"/>5.2.5 Using existing C++ types</H3>

<p>
<p class="subheading">Announcing C++ types</p>

<p>If you want to use one of your own types (a class, struct or typedef,
declared in a C++ header) in a message definition, you have to
announce those types to the message compiler. You also have to make sure
that your header file gets included into the generated <tt>_m.h</tt> file
so that the C++ compiler can compile it.

<p>Suppose you have an <tt>IPAddress</tt> structure, defined in an <tt>ipaddress.h</tt>
file:

<pre>
// ipaddress.h
struct IPAddress {
    int byte0, byte1, byte2, byte3;
};
</pre>
<p>
To be able to use <tt>IPAddress</tt> in a message definition, the message
file (say <tt>foopacket.msg</tt>) should contain the following lines:

<p><pre>
<b>cplusplus</b> {{
#include "ipaddress.h"
}};

<b>struct</b> IPAddress;
</pre>

<p>The effect of the first three lines is simply that the <tt>#include</tt>
statement will be copied into the generated <tt>foopacket_m.h</tt>
file to let the C++ compiler know about the <tt>IPAddress</tt> class.
The message compiler itself will not try to make sense of the
text in the body of the <tt>cplusplus {{ ... }}</tt> directive.

<p>The next line, <tt>struct IPAddress</tt>, tells the message compiler that
<tt>IPAddress</tt> is a C++ struct. This information will (among others)
affect the generated code.

<p>Classes can be announced using the <tt>class</tt> keyword:

<p><pre>
<b>class</b> cSubQueue;
</pre>

<p>The above syntax assumes that the class is derived from <tt><a href="../api/classcObject.html">cObject</a></tt>
either directly or indirectly. If it is not, the <tt>noncobject</tt>
keyword should be used:

<p><pre>
<b>class</b> <b>noncobject</b> IPAddress;
</pre>

<p>The distinction between classes derived and not derived from <tt><a href="../api/classcObject.html">cObject</a></tt>
is important because the generated code differs at places.
The generated code is set up so that if you incidentally
forget the <tt>noncobject</tt> keyword (and thereby mislead the
message compiler into thinking that your class is rooted in
<tt><a href="../api/classcObject.html">cObject</a></tt> when in fact it is not), you'll get a C++ compiler
error in the generated header file.

<p>
<H3><A NAME="sec219"/>5.2.6 Customizing the generated class</H3>
<a name="sec:ch-messages:customizing-generated-class"></a>

<p>
<p class="subheading">The Generation Gap pattern</p>

<p>Sometimes you need the generated code to do something
more or do something differently than the version generated
by the message compiler.
For example, when setting a integer field named <tt>payloadLength</tt>,
you might also need to adjust the packet length. That is,
the following default (generated) version of the
<tt>setPayloadLength()</tt> method is not suitable:

<pre>
void FooPacket::setPayloadLength(int payloadLength)
{
    this-&gt;payloadLength = payloadLength;
}
</pre>
<p>
Instead, it should look something like this:

<pre>
void FooPacket::setPayloadLength(int payloadLength)
{
    int diff = payloadLength - this-&gt;payloadLength;
    this-&gt;payloadLength = payloadLength;
    setLength(length() + diff);
}
</pre>
<p>
According to common belief, the largest drawback of generated code
is that it is difficult or impossible to fulfill such wishes.
Hand-editing of the generated files is worthless, because
they will be overwritten and changes will be lost
in the code generation cycle.

<p>However, object oriented programming offers a solution.
A generated class can simply be customized by subclassing
from it and redefining whichever methods need to be
different from their generated versions. This practice
is known as the <i>Generation Gap</i> design pattern.
It is enabled with the following syntax:

<p><pre>
<b>message</b> FooPacket
{
   <b>properties</b>:
       customize = true;
   <b>fields</b>:
       <b>int</b> payloadLength;
};
</pre>

<p>The <tt>properties</tt> section within the message declaration contains
meta-info that affects how generated code will look like.
The customize property enables the use of the Generation Gap
pattern.

<p>If you process the above code with the message compiler,
the generated code will contain a <tt>FooPacket_Base</tt> class
instead of <tt>FooPacket</tt>. The idea is that you have
to subclass from <tt>FooPacket_Base</tt> to produce
<tt>FooPacket</tt>, while doing your customizations
by redefining the necessary methods.

<pre>
class FooPacket_Base : public <a href="../api/classcMessage.html">cMessage</a>
{
  protected:
    int src;
    // make constructors protected to avoid instantiation
    FooPacket_Base(const char *name=NULL);
    FooPacket_Base(const FooPacket_Base& other);
  public:
    ...
    virtual int getSrc() const;
    virtual void setSrc(int src);
};
</pre>
<p>
There is a minimum amount of code you have to write
for <tt>FooPacket</tt>, because not everything can be
pre-generated as part of <tt>FooPacket_Base</tt>, e.g.
constructors cannot be inherited. This minimum
code is the following (you'll find it the generated C++ header
too, as a comment):

<pre>
class FooPacket : public FooPacket_Base
{
  public:
    FooPacket(const char *name=NULL) : FooPacket_Base(name) {}
    FooPacket(const FooPacket& other) : FooPacket_Base(other) {}
    FooPacket& operator=(const FooPacket& other)
        {FooPacket_Base::operator=(other); return *this;}
    virtual <a href="../api/classcPolymorphic.html">cPolymorphic</a> *dup() {return new FooPacket(*this);}
};

Register_Class(FooPacket);
</pre>
<p>
Note that it is important that you redefine <tt>dup()</tt> and
provide an assignment operator (<tt>operator=()</tt>).

<p>So, returning to our original example about payload length
affecting packet length, the code you'd write is the following:

<pre>
class FooPacket : public FooPacket_Base
{
    // here come the mandatory methods: constructor,
    // copy contructor, operator=(), dup()
    // ...

    virtual void setPayloadLength(int newlength);
}

void FooPacket::setPayloadLength(int newlength)
{
    // adjust message length
    setLength(length()-getPayloadLength()+newlength);

    // set the new length
    FooPacket_Base::setPayloadLength(newlength);
}
</pre>
<p>

<p>
<p class="subheading">Abstract fields</p>

<p>The purpose of abstract fields is to let you to override
the way the value is stored inside the class,
and still benefit from inspectability in Tkenv.

<p>For example, this is the situation when you want to store a bitfield
in a single <tt>int</tt> or <tt>short</tt>, and still you want
to present bits as individual packet fields.
It is also useful for implementing computed fields.

<p>You can declare any field to be abstract with the following syntax:

<p><pre>
<b>message</b> FooPacket
{
   <b>properties</b>:
       customize = true;
   <b>fields</b>:
       <b>abstract</b> <b>bool</b> urgentBit;
};
</pre>

<p>For an <tt>abstract</tt> field, the message compiler generates
no data member, and generated getter/setter methods will be pure
virtual:

<pre>
virtual bool getUrgentBit() const = 0;
virtual void setUrgentBit(bool urgentBit) = 0;
</pre>
<p>

<p>Usually you'll want to use abstract fields together with
the Generation Gap pattern, so that you can immediately
redefine the abstract (pure virtual) methods and
supply your implementation.

<p>

<p><H3><A NAME="sec220"/>5.2.7 Using STL in message classes</H3>

<p>You may want to use STL <tt>vector</tt> or <tt>stack</tt> classes in your message classes.
This is possible using abstract fields. After all, <tt>vector</tt> and <tt>stack</tt>
are representations of a <i>sequence</i> -- same abstraction as dynamic-size vectors.
That is, you can declare the field as <tt>abstract T fld[]</tt>, and provide
an underlying implementation using <tt>vector&lt;T&gt;</tt>. You can also add methods
to the message class that invoke <tt>push_back()</tt>, <tt>push()</tt>, <tt>pop()</tt>, etc.
on the underlying STL object.

<p>See the following message declaration:

<p><pre>
<b>struct</b> Item
{
    <b>fields</b>:
        <b>int</b> a;
        <b>double</b> b;
}

<b>message</b> STLMessage
{
   <b>properties</b>:
       customize=true;
   <b>fields</b>:
       <b>abstract</b> Item foo[]; // will use vector&lt;Item&gt;
       <b>abstract</b> Item bar[]; // will use stack&lt;Item&gt;
}
</pre>

<p>If you compile the above, in the generated code you'll only find a couple of
abstract methods for <tt>foo</tt> and <tt>bar</tt>, no data members or anything concrete.
You can implement everything as you like. You can write the following C++ file
then to implement <tt>foo</tt> and <tt>bar</tt> with <tt>std::vector</tt> and <tt>std::stack</tt>:

<pre>
#include &lt;vector&gt;
#include &lt;stack&gt;
#include "stlmessage_m.h"


class STLMessage : public STLMessage_Base
{
  protected:
    std::vector&lt;Item&gt; foo;
    std::stack&lt;Item&gt; bar;

  public:
    STLMessage(const char *name=NULL, int kind=0) : STLMessage_Base(name,kind) {}
    STLMessage(const STLMessage& other) : STLMessage_Base(other.name()) {operator=(other);}
    STLMessage& operator=(const STLMessage& other) {
        if (&other==this) return *this;
        STLMessage_Base::operator=(other);
        foo = other.foo;
        bar = other.bar;
        return *this;
    }
    virtual <a href="../api/classcPolymorphic.html">cPolymorphic</a> *dup() {return new STLMessage(*this);}

    // foo methods
    virtual void setFooArraySize(unsigned int size) {}
    virtual unsigned int getFooArraySize() const {return foo.size();}
    virtual Item& getFoo(unsigned int k) {return foo[k];}
    virtual void setFoo(unsigned int k, const Item& afoo) {foo[k]=afoo;}
    virtual void addToFoo(const Item& afoo) {foo.push_back(afoo);}

    // bar methods
    virtual void setBarArraySize(unsigned int size) {}
    virtual unsigned int getBarArraySize() const {return bar.size();}
    virtual Item& getBar(unsigned int k) {throw new cRuntimeException("sorry");}
    virtual void setBar(unsigned int k, const Item& bar) {throw new cRuntimeException("sorry");}
    virtual void barPush(const Item& abar) {bar.push(abar);}
    virtual void barPop() {bar.pop();}
    virtual Item& barTop() {return bar.top();}
};

Register_Class(STLMessage);
</pre>
<p>
Some additional notes:

<p><ol>
  <li><tt>setFooArraySize()</tt>, <tt>setBarArraySize()</tt> are redundant.
  <li><tt>getBar(int k)</tt> cannot be implemented in a straightforward way
     (<tt>std::stack</tt> does not support accessing elements by index).
     It could still be implemented in a less efficient way using STL iterators,
     and efficiency does not seem to be major problem because only Tkenv
     is going to invoke this function.
  <li><tt>setBar(int k, const Item&amp;)</tt> could not be implemented, but this
     is not particularly a problem. The exception will materialize in a
     Tkenv error dialog when you try to change the field value.
</ol>

<p>You may regret that the STL <tt>vector</tt>/<tt>stack</tt> are not directly exposed.
Well you could expose them (by adding a <tt>vector&lt;Item&gt;&amp; getFoo() {return foo;}</tt>
method to the class) but this is probably not a good idea.
STL itself was purposefully designed with a low-level approach, to provide
``nuts and bolts'' for C++ programming, and STL is better used in other classes
for internal representation of data.

<p>

<p><H3><A NAME="sec221"/>5.2.8 Summary</H3>

<p>This section attempts to summarize the possibilities.

<p>You can generate:

<p><ul>
  <li>  classes rooted in <tt><a href="../api/classcObject.html">cObject</a></tt>
  <li>  messages (default base class is <tt><a href="../api/classcMessage.html">cMessage</a></tt>)
  <li>  classes not rooted in <tt><a href="../api/classcObject.html">cObject</a></tt>
  <li>  plain C structs
</ul>

<p>The following data types are supported for fields:

<p><ul>
  <li>  primitive types: <tt>bool</tt>, <tt>char</tt>, <tt>short</tt>,
    <tt>int</tt>, <tt>long</tt>, <tt>unsigned short</tt>, <tt>unsigned int</tt>,
    <tt>unsigned long</tt>, <tt>double</tt>
  <li>  <tt>string</tt>, a dynamically allocated string, presented as <tt>const char *</tt>
  <li>  fixed-size arrays of the above types
  <li>  structs, classes (both rooted and not rooted in <tt><a href="../api/classcObject.html">cObject</a></tt>),
    declared with the message syntax or externally in C++ code
  <li>  variable-sized arrays of the above types (stored as a dynamically
    allocated array plus an integer for the array size)
</ul>

<p>Further features:

<p><ul>
  <li>  fields initialize to zero (except struct members)
  <li>  fields initializers can be specified (except struct members)
  <li>  assigning <tt>enum</tt>s to variables of integral types.
  <li>  inheritance
  <li>  customizing the generated class via subclassing (<i>Generation Gap</i> pattern)
  <li>  abstract fields (for nonstandard storage and calculated fields)
</ul>

<p>Generated code (all generated methods are <tt>virtual</tt>, although
this is not written out in the following table):

<p><table border>
<TR> <TD align=left>

<p>
<b>Field declaration</b>
    </TD> <TD align=left>
<b>Generated code</b>
</TD></TR>
<TR> <TD align=left> 
primitive types
<pre>
double field;
</pre>
     </TD> <TD align=left>
<pre>
double getField();
void setField(double d);
</pre>
</TD></TR>
<TR> <TD align=left> 
string type
<pre>
string field;
</pre>
     </TD> <TD align=left>
<pre>
const char *getField();
void setField(const char *);
</pre>
</TD></TR>
<TR> <TD align=left> 
fixed-size arrays
<pre>
double field[4];
</pre>
     </TD> <TD align=left>
<pre>
double getField(unsigned k);
void setField(unsigned k, double d);
unsigned getFieldArraySize();
</pre>

<p></TD></TR>
<TR> <TD align=left> 
dynamic arrays
<pre>
double field[];
</pre>
     </TD> <TD align=left>
<pre>
void setFieldArraySize(unsigned n);
unsigned getFieldArraySize();
double getField(unsigned k);
void setField(unsigned k, double d);
</pre>
</TD></TR>
<TR> <TD align=left> 
customized class
<pre>
class Foo {
  properties:
    customize=true;
</pre>
     </TD> <TD align=left>
<pre>
class Foo_Base { ... };
</pre>
and you have to write:
<pre>
class Foo : public Foo_Base {
   ...
};
</pre>
</TD></TR>
<TR> <TD align=left> 
abstract fields
<pre>
abstract double field;
</pre>
     </TD> <TD align=left>
<pre>
double getField() = 0;
void setField(double d) = 0;
</pre>
</TD></TR>
<TR> <TD align=left> 
</table>

<p>
<p class="subheading">Example simulations</p>

<p>Several of the example simulations (Token Ring, Dyna, Hypercube)
use message definitions. For example, in Dyna you'll find this:

<p><ul>
 <li> <tt>dynapacket.msg</tt> defines <tt>DynaPacket</tt> and <tt>DynaDataPacket</tt>;
 <li> <tt>dynapacket_m.h</tt> and <tt>dynapacket_m.cc</tt> are produced
   by the message subclassing compiler from it, and they contain
   the generated <tt>DynaPacket</tt> and <tt>DynaDataPacke</tt>t
   C++ classes (plus code for Tkenv inspectors);
 <li> other model files (<tt>client.cc</tt>, <tt>server.cc</tt>, ...)
   use the generated message classes
</ul>

<p>

<p><H3><A NAME="sec222"/>5.2.9 What else is there in the generated code?</H3>

<p>In addition to the message class and its implementation,
the message compiler also generates reflection code which makes it
possible to inspect message contents in Tkenv.
To illustrate why this is necessary, suppose you manually subclass
<tt><a href="../api/classcMessage.html">cMessage</a></tt> to get a new message class. You could write the following:
  <br><ul><font size=-1>[Note that the code is only for illustration.
  In real code, <tt>freq</tt> and <tt>power</tt> should be private members,
  and getter/setter methods should exist to access them.
  Also, the above class definition misses several member functions
  (constructor, assignment operator, etc.) that should be written.]</font></ul>

<pre>
class RadioMsg : public <a href="../api/classcMessage.html">cMessage</a>
{
  public:
    int freq;
    double power;
    ...
};
</pre>
<p>
Now it is possible to use <tt>RadioMsg</tt> in your simple modules:

<pre>
RadioMsg *msg = new RadioMsg();
msg-&gt;freq = 1;
msg-&gt;power = 10.0;
...
</pre>
<p>
You'd notice one drawback of this solution when you try to use
Tkenv for debugging. While <tt><a href="../api/classcPar.html">cPar</a></tt>-based message parameters can be viewed in
message inspector windows, fields added via subclassing do not appear
there. The reason is that Tkenv, being just another C++ library in your
simulation program, doesn't know about your C++ instance variables.
The problem cannot be solved entirely within Tkenv, because C++ does not
support ``reflection'' (extracting class information at runtime)
like for example Java does.

<p>There is a solution however: one can supply Tkenv with missing ``reflection''
information about the new class. Reflection info might take the form of
a separate C++ class whose methods return information about the
<tt>RadioMsg</tt> fields. This descriptor class might look like this:

<pre>
class RadioMsgDescriptor : public Descriptor
{
  public:
    virtual int getFieldCount() {return 2;}

    virtual const char *getFieldName(int k) {
        const char *fieldname[] = {"freq", "power";}
        if (k&lt;0 || k&gt;=2) return NULL;
        return fieldname[k];
    }

    virtual double getFieldAsDouble(RadioMsg *msg, int k) {
        if (k==0) return msg-&gt;freq;
        if (k==1) return msg-&gt;power;
        return 0.0; // not found
    }
    //...
};
</pre>
<p>
Then you have to inform Tkenv that a <tt>RadioMsgDescriptor</tt> exists and that it
should be used whenever Tkenv finds messages of type <tt>RadioMsg</tt> (as it is
currently implemented, whenever the object's <tt>className()</tt> method returns
<tt>"RadioMsg"</tt>). So when you inspect a <tt>RadioMsg</tt> in your simulation, Tkenv
can use <tt>RadioMsgDescriptor</tt> to extract and display the values of
the <tt>freq</tt> and <tt>power</tt> variables.

<p>The actual implementation is somewhat more complicated than this, but not
much.

</BODY>
</HTML>
<hr><hr><H1><A NAME="sec223"/>6 The Simulation Library</H1>
<a name="cha:the-simulation-library"></a>

<p>OMNeT++ has an extensive C++ class library which you can use when implementing
simple modules. Parts of the class library have already been covered in the
previous chapters:

<p><ul>
  <li>the message class <tt><a href="../api/classcMessage.html">cMessage</a></tt> (chapter <a href="#sec206">[5]</a>)
  <li>sending and receiving messages, scheduling and canceling
    events, terminating the module or the simulation
    (section <a href="#sec180">[4.6]</a>)
  <li>access to module gates and parameters via <tt><a href="../api/classcModule.html">cModule</a></tt> member functions
    (sections <a href="#sec189">[4.7]</a> and <a href="#sec191">[4.8]</a>)
  <li>accessing other modules in the network (section <a href="#sec196">[4.9]</a>)
  <li>dynamic module creation (section <a href="#sec198">[4.11]</a>)
</ul>

<p>This chapter discusses the rest of the simulation library:

<p><ul>
  <li>random number generation: <tt>normal()</tt>,
    <tt>exponential()</tt>, etc.
  <li>module parameters: <tt><a href="../api/classcPar.html">cPar</a></tt> class
  <li>storing data in containers: the <tt><a href="../api/classcArray.html">cArray</a></tt> and <tt><a href="../api/classcQueue.html">cQueue</a></tt> classes
  <li>routing support and discovery of network topology: <tt><a href="../api/classcTopology.html">cTopology</a></tt> class
  <li>recording statistics into files: <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> class
  <li>collecting simple statistics: <tt><a href="../api/classcStdDev.html">cStdDev</a></tt> and <tt>cWeightedStddev</tt> classes
  <li>distribution estimation: <tt><a href="../api/classcLongHistogram.html">cLongHistogram</a></tt>,
    <tt><a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a></tt>, <tt><a href="../api/classcVarHistogram.html">cVarHistogram</a></tt>, <tt><a href="../api/classcPSquare.html">cPSquare</a></tt>,
    <tt><a href="../api/classcKSplit.html">cKSplit</a></tt> classes
  <li>making variables inspectable in the graphical user interface (Tkenv):
        the <tt>WATCH()</tt> macros
  <li>sending debug output to and prompting for user input in the graphical
    user interface (Tkenv<!--Tkenv-->): the <tt>ev</tt><!--ev--> object (<tt><a href="../api/classcEnvir.html">cEnvir</a></tt> class)
</ul>

<p>

<p>

<p><H2><A NAME="sec224"/>6.1 Class library conventions</H2>

<p><H3><A NAME="sec225"/>6.1.1 Base class</H3>
<a name="sec:ch-sim-lib:cobject"></a>

<p>
Classes in the OMNeT++ simulation library are derived from <tt><a href="../api/classcObject.html">cObject</a></tt>.
Functionality and conventions that come from <tt><a href="../api/classcObject.html">cObject</a></tt>:
<ul>
  <li>name attribute
  <li><tt>className()</tt> member and other member functions giving textual
    information about the object
  <li>conventions for assignment, copying, duplicating the object
  <li>ownership<!--ownership--> control for containers derived from <tt><a href="../api/classcObject.html">cObject</a></tt>
  <li>support for traversing the object tree
  <li>support for inspecting the object in graphical user interfaces (Tkenv)
</ul>

<p>
Classes inherit and redefine several <tt><a href="../api/classcObject.html">cObject</a></tt> member functions;
in the following we'll discuss some of the practically important
ones.

<p>
<H3><A NAME="sec226"/>6.1.2 Setting and getting attributes</H3>

<p>
Member functions that set and query object attributes follow
consistent naming. The setter member function has the form <tt>setFoo(...)</tt>
and its getter counterpart is named <tt>foo()</tt>. (The <i>get</i> verb found in Java
and some other libraries is omitted for brevity.)
For example, the <i>length</i> attribute of the <tt><a href="../api/classcMessage.html">cMessage</a></tt> class can
be set and read like this:

<pre>
msg-&gt;setLength(1024);
length = msg-&gt;length();
</pre>
<p>

<p><H3><A NAME="sec227"/>6.1.3 className()</H3>
<a name="sec:sim-lib:classname"></a>

<p>
For each class, the <tt>className()</tt> member function returns the class
name as a string:

<pre>
const char *classname = msg-&gt;className(); // returns "<a href="../api/classcMessage.html">cMessage</a>"
</pre>
<p>

<p><H3><A NAME="sec228"/>6.1.4 Name attribute</H3>
<a name="sec:sim-lib:name"></a>

<p>An object can be assigned a <i>name</i> (a character string). The name
string is the first argument to the constructor of every class,
and it defaults to <tt>NULL</tt> (no name string). An example:

<pre>
<a href="../api/classcMessage.html">cMessage</a> *timeoutMsg = new <a href="../api/classcMessage.html">cMessage</a>("timeout");
</pre>
<p>
You can also set the name after the object has been created:

<pre>
timeoutMsg-&gt;setName("timeout");
</pre>
<p>
You can get a pointer to the internally stored copy of the name
string like this:

<pre>
const char *name = timeoutMsg-&gt;name(); // --&gt; "timeout"
</pre>
<p>
For convenience and efficiency reasons, the empty string <tt>""</tt>
and <tt>NULL</tt> are treated as equivalent by library objects.
That is, <tt>""</tt> is stored as <tt>NULL</tt> but returned as <tt>""</tt>.
If you create a message object with either <tt>NULL</tt>
or <tt>""</tt> as name string, it will be stored as <tt>NULL</tt>
and <tt>name()</tt> will return a pointer to a static <tt>""</tt>.

<pre>
<a href="../api/classcMessage.html">cMessage</a> *msg = new <a href="../api/classcMessage.html">cMessage</a>(NULL, &lt;additional args&gt;);
const char *str = msg-&gt;name(); // --&gt; returns ""
</pre>
<p>

<p><H3><A NAME="sec229"/>6.1.5 fullName() and fullPath()</H3>
<a name="sec:sim-lib:fullname-and-fullpath"></a>

<p>
Objects have two more member functions which return strings
based on object names: <tt>fullName()</tt> and <tt>fullPath()</tt>.
For gates and modules which are part of gate or module vectors,
<tt>fullName()</tt> returns the name with the index in brackets.
That is, for a module <tt>node[3]</tt> in the submodule vector <tt>node[10]</tt>
<tt>name()</tt> returns <tt>"node"</tt>, and <tt>fullName()</tt> returns <tt>"node[3]"</tt>.
For other objects, <tt>fullName()</tt> is the same as <tt>name()</tt>.

<p><tt>fullPath()</tt> returns <tt>fullName()</tt>, prepended with the
parent or owner object's <tt>fullPath()</tt> and separated by a dot.
That is, if the <tt>node[3]</tt> module above is in the compound module
<tt>"net.subnet1"</tt>, its <tt>fullPath()</tt> method will return
<tt>"net.subnet1.node[3]"</tt>.

<pre>
ev &lt;&lt; this-&gt;name();     // --&gt; "node"
ev &lt;&lt; this-&gt;fullName(); // --&gt; "node[3]"
ev &lt;&lt; this-&gt;fullPath(); // --&gt; "net.subnet1.node[3]"
</pre>
<p>
<tt>className()</tt>, <tt>fullName()</tt> and <tt>fullPath()</tt>
are extensively used on the graphical runtime environment Tkenv,
and also appear in error messages.

<p><tt>name()</tt> and <tt>fullName()</tt> return <tt>const char *</tt> pointers,
and <tt>fullPath()</tt> returns <tt>std::string</tt>. This makes no difference
with <tt>ev&lt;&lt;</tt>, but when <tt>fullPath()</tt> is used as a <tt>"%s"</tt> argument
to <tt>sprintf()</tt> you have to write <tt>fullPath().c_str()</tt>.

<pre>
char buf[100];
sprintf("msg is '%80s'", msg-&gt;fullPath().c_str()); // note c_str()
</pre>
<p>

<p><H3><A NAME="sec230"/>6.1.6 Copying and duplicating objects</H3>

<p>
The <tt>dup()</tt> member function creates an exact copy of the
object<!--object!copy-->, duplicating<!--object!duplication-->
contained objects also if necessary. This is especially useful in the
case of message objects. <tt>dup()</tt> returns a pointer of type
<tt><a href="../api/classcObject.html">cObject</a>*</tt>, so it needs to be cast to the proper type:

<pre>
<a href="../api/classcMessage.html">cMessage</a> *copyMsg = (<a href="../api/classcMessage.html">cMessage</a> *) msg-&gt;dup();
</pre>
<p>

<p><tt>dup()</tt> works by calling the copy constructor, which in
turn relies on the assignment operator between objects.
<tt>operator=()</tt> can be used to copy contents of an object into
another object of the same type. This is a deep copy: object
contained in the object will also be duplicated if necessary.
<tt>operator=()</tt> does not copy the name string -- this task is done
by the copy constructor<!--copy constructor-->.

<p>
<H3><A NAME="sec231"/>6.1.7 Iterators</H3>

<p>
There are several container classes in the library (<tt><a href="../api/classcQueue.html">cQueue</a></tt>,
<tt><a href="../api/classcArray.html">cArray</a></tt> etc.) For many of them, there is a corresponding
iterator class that you can use to loop through the objects stored in
the container.

<p>For example:

<pre>
<a href="../api/classcQueue.html">cQueue</a> queue;

//..
for (<a href="../api/classcQueue.html">cQueue</a>::Iterator queueIter(queue); !queueIter.end(); queueIter++)
{
    <a href="../api/classcObject.html">cObject</a> *containedObject = queueIter();
}
</pre>
<p>

<p>
<H3><A NAME="sec232"/>6.1.8 Error handling</H3>

<p>
When library objects detect an error condition, they throw a C++ exception.
This exception is then caught by the simulation environment which pops up
an error dialog or displays the error message.

<p>At times it can be useful to be able stop the simulation at the place of the error
(just before the exception is thrown) and use a C++ debugger to look
at the stack trace and examine variables. Enabling the <tt>debug-on-errors</tt>
ini file entry lets you do that -- check it in section
<a href="#sec296">[8.2.6]</a>  .

<p>If you detect an error condition in your code, you can stop the
simulation with an error message using the <tt>opp_error()</tt> function.
<tt>opp_error()</tt>'s argument list works like <tt>printf()</tt>: the
first argument is a format string which can contain <tt>"%s"</tt>, <tt>"%d"</tt> etc,
filled in using subsequent arguments.

<p>An example:

<pre>
if (msg-&gt;controlInfo()==NULL)
    opp_error("message (%s)%s has no control info attached",
              msg-&gt;className(), msg-&gt;name());
</pre>
<p>

<p>
<H2><A NAME="sec233"/>6.2 Logging from modules</H2>

<p>The logging feature will be used extensively in the code examples,
we introduce it here.

<p>The <tt>ev</tt><!--ev--> object represents the user interface of the
simulation.  You can send debugging output to <tt>ev</tt> with the C++-style
output operators:

<pre>
ev &lt;&lt; "packet received, sequence number is " &lt;&lt; seqNum &lt;&lt; endl;
ev &lt;&lt; "queue full, discarding packet\n";
</pre>
<p>
An alternative solution is <tt>ev.printf()</tt>:

<pre>
ev.printf("packet received, sequence number is %d\n", seqNum);
</pre>
<p>
The exact way messages are displayed to the user depends on the user
interface. In the command-line user interface (Cmdenv<!--Cmdenv-->),
it is simply dumped to the standard output. (This output can also be
disabled from <tt>omnetpp.ini</tt> so that it doesn't slow down simulation
when it is not needed.) In Tkenv, the runtime GUI, you can open
a text output window for every module.
It is not recommended that you use <tt>printf()</tt> or <tt>cout</tt>
to print messages -- <tt>ev</tt> output can be controlled much better
from <tt>omnetpp.ini</tt> and it is more convenient to view, using Tkenv.

<p>One can save CPU cycles by making logging statements conditional
on whether the output actually gets displayed or recorded anywhere.
The <tt>ev.disabled()</tt> call returns true when <tt>ev&lt;&lt;</tt> output is disabled,
such as in Tkenv or Cmdenv ``express'' mode. Thus, one can write code like
this:

<pre>
if (!ev.disabled())
    ev &lt;&lt; "Packet " &lt;&lt; msg-&gt;name() &lt;&lt; " received\n";
</pre>
<p>
A more sophisticated implementation of the same idea is to define
an <tt>EV</tt> macro which can be used in logging statements instead of
<tt>ev</tt>. The definition:

<pre>
#define EV  ev.disabled()?std::cout:ev
</pre>
<p>
And after that, one would simply write <tt>EV&lt;&lt;</tt> instead of <tt>ev&lt;&lt;</tt>.

<pre>
EV &lt;&lt; "Packet " &lt;&lt; msg-&gt;name() &lt;&lt; " received\n";
</pre>
<p>
The slightly tricky definition of <tt>EV</tt> makes use of the fact
that the <tt>&lt;&lt;</tt> operator binds looser than <tt>?:</tt>.

<p>

<p><H2><A NAME="sec234"/>6.3 Simulation time conversion</H2>

<p>Simulation time is represented by the type <tt>simtime_t</tt>
which is a typedef to <tt>double</tt>.
OMNeT++ provides utility functions, which convert <tt>simtime_t</tt>
to a printable string (<tt>"3s 130ms 230us"</tt>) and vica versa.

<p>The <tt>simtimeToStr()</tt> function converts a <tt>simtime_t</tt>
(passed in the first argument) to textual form. The result is placed into
the <tt>char</tt> array pointed to by the second argument. If the second argument is omitted
or it is <tt>NULL</tt>, <tt>simtimeToStr()</tt> will place the result into a
static buffer which is overwritten with each call. An example:

<pre>
char buf[32];
ev.printf("t1=%s, t2=%s\n", simtimeToStr(t1), simTimeToStr(t2,buf));
</pre>
<p>
The <tt>simtimeToStrShort()</tt> is similar to <tt>simtimeToStr()</tt>,
but its output is more concise.

<p>The <tt>strToSimtime()</tt> function parses a time specification passed
in a string, and returns a <tt>simtime_t</tt>. If the string cannot
be entirely interpreted, -1 is returned.

<pre>
simtime_t t = strToSimtime("30s 152ms");
</pre>
<p>
Another variant, <tt>strToSimtime0()</tt> can be used if the time
string is a substring in a larger string. Instead of taking a <tt>char*</tt>,
it takes a reference to <tt>char*</tt> (<tt>char*&amp;</tt>) as the first argument.  The
function sets the pointer to the first character that could not be
interpreted as part of the time string, and returns the value. It
never returns -1; if nothing at the beginning of the string looked
like simulation time, it returns 0.

<pre>
const char *s = "30s 152ms and something extra";

simtime_t t = strToSimtime0(s); // now s points to "and something extra"
</pre>
<p>

<p><H2><A NAME="sec235"/>6.4 Generating random numbers</H2>
<a name="cha:sim-lib:generating-random-numbers"></a>

<p>Random numbers in simulation are never random. Rather, they are
produced using deteministic algorithms. Algorithms take a <i>seed</i> value
and perform some deterministic calculations on them to produce
a ``random'' number and the next seed. Such algorithms and their
implementations are called <i>random number generators</i> or RNGs,
or sometimes pseudo random number generators or PRNGs to highlight
their deterministic nature.
  <br><ul><font size=-1>[There are real random numbers as well, see e.g.
  http://www.random.org/, http://www.comscire.com, or the Linux
  <i>/dev/random</i> device. For non-random numbers, try www.noentropy.net.]</font></ul>

<p>Starting from the same seed, RNGs always produce the same sequence
of random numbers. This is a useful property and of great importance,
because it makes simulation runs repeatable.

<p>RNGs produce uniformly distributed integers in some range,
usually between 0 or 1 and <i>2<sup>32</sup></i> or so. Mathematical transformations
are used to produce random variates from them that correspond to
specific distributions.

<p><H3><A NAME="sec236"/>6.4.1 Random number generators</H3>
<a name="sec:sim-lib:rngs"></a>
<!--random number generator-->

<p><p class="subheading">Mersenne Twister</p>

<p>By default, OMNeT++ uses the Mersenne Twister RNG (MT) by M. Matsumoto and
T. Nishimura [<a href="#bib-Matsumoto98">Matsumoto98</a>]. MT has a period of <i>2<sup>19937</sup>-1</i>,
and 623-dimensional equidistribution property is assured. MT is
also very fast: as fast or faster than ANSI C's <tt>rand()</tt>.

<p><p class="subheading">The "minimal standard" RNG</p>

<p>OMNeT++ releases prior to 3.0 used a linear congruential generator
(LCG) with a cycle length of <i>2<sup>31</sup>-2</i>, described in
[<a href="#bib-Jain91">Jain91</a>], pp. 441-444,455. This RNG is still available
and can be selected from <tt>omnetpp.ini</tt> (Chapter <a href="#sec288">[8]</a>).
This RNG is only suitable for small-scale simulation studies.
As shown by Karl Entacher et al. in [<a href="#bib-Entacher02">Entacher02</a>],
the cycle length of about <i>2<sup>31</sup></i> is too small (on todays
fast computers it is easy to exhaust all random numbers), and
the structure of the generated ``random'' points is too regular.
The [<a href="#bib-Hellekalek98">Hellekalek98</a>] paper provides a broader overview of issues
associated with RNGs used for simulation, and it is well worth reading.
It also contains useful links and references on the topic.

<p><p class="subheading">The Akaroa RNG</p>

<p>When you execute simulations under Akaroa control (see section
<a href="#sec323">[8.10]</a>), you can also select Akaroa's
RNG as the RNG underlying for the OMNeT++ random number functions.
The Akaroa RNG also has to be selected from <tt>omnetpp.ini</tt>
(section <a href="#sec303">[8.6]</a>).

<p><p class="subheading">Other RNGs</p>

<p>OMNeT++ allows plugging in your own RNGs as well. This mechanism,
based on the <tt><a href="../api/classcRNG.html">cRNG</a></tt> interface, is described in section
<a href="#sec397">[13.5.3]</a>.
For example, one candidate to include could be L'Ecuyer's CMRG [<a href="#bib-LEcuyer02">LEcuyer02</a>]
which has a period of about <i>2<sup>191</sup></i> and can provide a large
number of <i>guaranteed</i> independent streams.

<p>
<H3><A NAME="sec237"/>6.4.2 Random number streams, RNG mapping</H3>

<p>Simulation programs may consume random numbers from several streams,
that is, from several independent RNG instances. For example, if a
network simulation uses random numbers for generating packets and
for simulating bit errors in the transmission, it might be a good
idea to use different random streams for both. Since the seeds
for each stream can be configured independently, this arrangement
would allow you to perform several simulation runs with the same traffic
but with bit errors occurring in different places.
A simulation technique called <i>variance reduction</i> is
also related to the use of different random number streams.

<p>It is also important that different streams and also different
simulation runs use non-overlapping series of random numbers.
Overlap in the generated random number sequences can introduce
unwanted correlation in your results.

<p>The number of random number streams as well as seeds for the individual
streams can be configured in <tt>omnetpp.ini</tt>
(section <a href="#sec303">[8.6]</a>).
For the "minimal standard RNG", the <tt>seedtool</tt> program can be
used for selecting good seeds (section <a href="#sec309">[8.6.6]</a>).

<p>In OMNeT++, streams are identified with RNG numbers. The RNG numbers
used in simple modules may be <i>arbitrarily mapped</i> to the actual
random number streams (actual RNG instances) from <tt>omnetpp.ini</tt>
(section <a href="#sec303">[8.6]</a>). The mapping allows
for great flexibility in RNG usage and random number streams
configuration -- even for simulation models which were not written
with RNG awareness.

<p>
<H3><A NAME="sec238"/>6.4.3 Accessing the RNGs</H3>

<p>The <tt>intrand(n)</tt> function generates random integers in the range <i>[0, n-1]</i>, and
<tt>dblrand()</tt> generates a random double on <i>[0,1)</i>. These functions
simply wrap the underlying RNG objects. Examples:

<pre>
int dice = 1 + intrand(6); // result of intrand(6) is in the range 0..5
double p = dblrand();      // dblrand() produces numbers in [0,1)
</pre>
<p>
They also have a counterparts that use generator <i>k</i>:

<pre>
int dice = 1 + genk_intrand(k,6); // uses generator k
double prob = genk_dblrand(k);    // ""
</pre>
<p>
The underlying RNG objects are subclassed from <tt><a href="../api/classcRNG.html">cRNG</a></tt>,
and they can be accessed via <tt><a href="../api/classcModule.html">cModule</a></tt>'s <tt>rng()</tt> method.
The argument to <tt>rng()</tt> is a local RNG number which will undergo
RNG mapping.

<pre>
<a href="../api/classcRNG.html">cRNG</a> *rng1 = rng(1);
</pre>
<p>
<tt><a href="../api/classcRNG.html">cRNG</a></tt> contains the methods implementing the above <tt>intrand()</tt>
and <tt>dblrand()</tt> functions. The <tt><a href="../api/classcRNG.html">cRNG</a></tt> interface also allows
you to access the ``raw'' 32-bit random numbers generated by the RNG
and to learn their ranges (<tt>intRand()</tt>, <tt>intRandMax()</tt>) as well as
to query the number of random numbers generated (<tt>numbersDrawn()</tt>).

<p>
<H3><A NAME="sec239"/>6.4.4 Random variates</H3>

<p>The following functions are based on <tt>dblrand()</tt> and return
random variables of different distributions<!--distribution!random variables--><!--random!numbers from distributions-->:

<p>Random variate functions use one of the random number generators (RNGs)
provided by OMNeT++. By default this is generator 0, but you can specify
which one to be used.

<p>OMNeT++ has the following predefined distributions<!--distribution!predefined-->:

<p><table border>
<TR> <TD align=left>
<b>Function</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=center colspan=2><b>Continuous distributions</b></TD></TR>
<TR> <TD align=left> <tt>uniform(a, b, <i>rng=0</tt>)</i> </TD> <TD align=left> uniform distribution in the range [a,b) </TD></TR>
<TR> <TD align=left> <tt>exponential(mean, <i>rng=0</tt>)</i> </TD> <TD align=left> exponential distribution with the given mean </TD></TR>
<TR> <TD align=left> <tt>normal(mean, stddev, <i>rng=0</tt>)</i> </TD> <TD align=left> normal distribution with the given mean and standard deviation </TD></TR>
<TR> <TD align=left> <tt>truncnormal(mean, stddev, <i>rng=0</tt>)</i> </TD> <TD align=left> normal distribution truncated to nonnegative values </TD></TR>
<TR> <TD align=left> <tt>gamma_d(alpha, beta, <i>rng=0</tt>)</i> </TD> <TD align=left> gamma distribution with parameters alpha&gt;0, beta&gt;0 </TD></TR>
<TR> <TD align=left> <tt>beta(alpha1, alpha2, <i>rng=0</tt>)</i> </TD> <TD align=left> beta distribution with parameters alpha1&gt;0, alpha2&gt;0 </TD></TR>
<TR> <TD align=left> <tt>erlang_k(k, mean, <i>rng=0</tt>)</i> </TD> <TD align=left> Erlang distribution with k&gt;0 phases and the given mean </TD></TR>
<TR> <TD align=left> <tt>chi_square(k, <i>rng=0</tt>)</i> </TD> <TD align=left> chi-square distribution with k&gt;0 degrees of freedom </TD></TR>
<TR> <TD align=left> <tt>student_t(i, <i>rng=0</tt>)</i> </TD> <TD align=left> student-t distribution with i&gt;0 degrees of freedom </TD></TR>
<TR> <TD align=left> <tt>cauchy(a, b, <i>rng=0</tt>)</i> </TD> <TD align=left> Cauchy distribution with parameters a,b where b&gt;0 </TD></TR>
<TR> <TD align=left> <tt>triang(a, b, c, <i>rng=0</tt>)</i> </TD> <TD align=left> triangular distribution with parameters a&lt;=b&lt;=c, a!=c </TD></TR>
<TR> <TD align=left> <tt>lognormal(m, s, rng=0)</tt> </TD> <TD align=left> lognormal distribution with mean m and variance s&gt;0 </TD></TR>
<TR> <TD align=left> <tt>weibull(a, b, <i>rng=0</tt>)</i> </TD> <TD align=left> Weibull distribution with parameters a&gt;0, b&gt;0 </TD></TR>
<TR> <TD align=left> <tt>pareto_shifted(a, b, c, <i>rng=0</tt>)</i> </TD> <TD align=left> generalized Pareto distribution with parameters a, b and shift c </TD></TR>
<TR> <TD align=center colspan=2><b>Discrete distributions</b> </TD></TR>
<TR> <TD align=left> <tt>intuniform(a, b, <i>rng=0</tt>)</i> </TD> <TD align=left> uniform integer from a..b </TD></TR>
<TR> <TD align=left> <tt>bernoulli(p, <i>rng=0</tt>)</i> </TD> <TD align=left> result of a Bernoulli trial with probability 0&lt;=p&lt;=1 (1 with probability p and 0 with probability (1-p)) </TD></TR>
<TR> <TD align=left> <tt>binomial(n, p, <i>rng=0</tt>)</i> </TD> <TD align=left> binomial distribution with parameters n&gt;=0 and 0&lt;=p&lt;=1 </TD></TR>
<TR> <TD align=left> <tt>geometric(p, <i>rng=0</tt>)</i> </TD> <TD align=left> geometric distribution with parameter 0&lt;=p&lt;=1 </TD></TR>
<TR> <TD align=left> <tt>negbinomial(n, p, <i>rng=0</tt>)</i> </TD> <TD align=left> binomial distribution with parameters n&gt;0 and 0&lt;=p&lt;=1</TD></TR>
<TR> <TD align=left> <tt>poisson(lambda, <i>rng=0</tt>)</i> </TD> <TD align=left> Poisson distribution with parameter lambda </TD></TR>
<TR> <TD align=left> 
</table>

<p>
They are the same functions that can be used in NED files.
<tt>intuniform()</tt> generates integers including both the lower and
upper limit, so for example the outcome of tossing a coin could be
written as intuniform(1,2).  <tt>truncnormal()</tt> is the normal
distribution truncated to nonnegative values; its implementation
generates a number with normal distribution and if the result is
negative, it keeps generating other numbers until the outcome is
nonnegative.

<p>If the above distributions do not suffice, you can write your own
functions<!--distribution!custom-->. If you register your functions
with the <tt>Register_Function()</tt> macro, you can use them in NED
files and ini files too.

<p>
<H3><A NAME="sec240"/>6.4.5 Random numbers from histograms</H3>

<p>You can also specify your distribution as a
histogram<!--distribution!as histogram-->. The
<tt><a href="../api/classcLongHistogram.html">cLongHistogram</a></tt>, <tt><a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a></tt>,
<tt><a href="../api/classcVarHistogram.html">cVarHistogram</a></tt>, <tt><a href="../api/classcKSplit.html">cKSplit</a></tt> or <tt><a href="../api/classcPSquare.html">cPSquare</a></tt> classes
are there to generate random numbers from equidistant-cell or
equiprobable-cell histograms.  This feature is documented later, with
the statistical classes.

<p>

<p>

<p><H2><A NAME="sec241"/>6.5 Container classes</H2>

<p><H3><A NAME="sec242"/>6.5.1 Queue class: <a href="../api/classcQueue.html">cQueue</a></H3>

<p><p class="subheading">Basic usage</p>

<p>
<tt><a href="../api/classcQueue.html">cQueue</a></tt> is a container class that acts as a queue.
<tt><a href="../api/classcQueue.html">cQueue</a></tt> can hold objects of type derived from <tt><a href="../api/classcObject.html">cObject</a></tt>
(almost all classes from the OMNeT++ library), such as
<tt><a href="../api/classcMessage.html">cMessage</a></tt>, <tt><a href="../api/classcPar.html">cPar</a></tt>, etc. Internally, <tt><a href="../api/classcQueue.html">cQueue</a></tt>
uses a double-linked list to store the elements.

<p>A queue object has a head and a tail. Normally, new elements
are inserted at its head and elements are removed at its tail.

<p>

<p>  <div align=center>
    <img src="usmanFig10.gif">
    <center><i>Figure: <a href="../api/classcQueue.html">cQueue</a>: insertion and removal</i></center>
    <a name="fig:ch-sim-lib:cqueue"></a>
  </div>

<p>
The basic <tt><a href="../api/classcQueue.html">cQueue</a></tt> member functions dealing with insertion and removal
are <tt>insert()</tt> and <tt>pop()</tt>. They are used
like this:

<pre>
<a href="../api/classcQueue.html">cQueue</a> queue("my-queue");
<a href="../api/classcMessage.html">cMessage</a> *msg;

// insert messages
for (int i=0; i&lt;10; i++)
{
  msg = new <a href="../api/classcMessage.html">cMessage</a>;
  queue.insert( msg );
}

// remove messages
while( ! queue.empty() )
{
  msg = (<a href="../api/classcMessage.html">cMessage</a> *)queue.pop();
  delete msg;
}
</pre>
<p>

<p>The <tt>length()</tt> member function returns the number of items in the
queue, and <tt>empty()</tt> tells whether there's anything in the queue.

<p>There are other functions dealing with insertion and removal.  The
<tt>insertBefore()</tt> and <tt>insertAfter()</tt> functions insert a
new item exactly before and after a specified one, regardless of the
ordering function.

<p>The <tt>tail()</tt> and <tt>head()</tt> functions return pointers to the objects
at the tail and head of the queue, without affecting queue contents.

<p>The <tt>pop()</tt> function can be used to remove items from the
tail of the queue, and the <tt>remove()</tt> function can be
used to remove any item known by its pointer from the queue:

<pre>
queue.remove( msg );
</pre>
<p>

<p>
<p class="subheading">Priority queue</p>

<p>
By default, <tt><a href="../api/classcQueue.html">cQueue</a></tt> implements a FIFO, but it can also act as
a priority queue, that is, it can keep the inserted objects
ordered<!--queue!order-->.  If you want to use this feature, you have
to provide a function that takes two <tt><a href="../api/classcObject.html">cObject</a></tt> pointers,
compares the two objects and returns -1, 0 or 1 as the result (see the
reference for details).  An example of setting up an ordered
<tt><a href="../api/classcQueue.html">cQueue</a></tt>:

<pre>
<a href="../api/classcQueue.html">cQueue</a> sortedqueue("sortedqueue", <a href="../api/classcObject.html">cObject</a>::cmpbyname, true );
                        // sorted by object name, ascending
</pre>
<p>

<p>If the queue object is set up as an ordered queue, the <tt>insert()</tt>
function uses the ordering function: it searches the queue contents
from the head until it reaches the position where the new item
needs to be inserted, and inserts it there.

<p>
<p class="subheading">Iterators</p>

<p>
Normally, you can only access the objects at the head or tail of the
queue. However, if you use an iterator class, <tt><a href="../api/classcQueue.html">cQueue</a>::Iterator</tt>,
you can examine each object in the queue<!--queue!iteration-->.

<p>The <tt><a href="../api/classcQueue.html">cQueue</a>::Iterator</tt> constructor takes two arguments, the first
is the queue object and the second one specifies the initial position
of the iterator: 0=tail, 1=head. Otherwise it acts as any other
OMNeT++ iterator class: you can use the ++ and -- operators to advance
it, the () operator to get a pointer to the current item, and the
<tt>end()</tt> member function to examine if you're at the end (or the
beginning) of the queue.

<p>
An example:

<pre>
for( <a href="../api/classcQueue.html">cQueue</a>::Iterator iter(queue,1); !iter.end(), iter++)
{
  <a href="../api/classcMessage.html">cMessage</a> *msg = (<a href="../api/classcMessage.html">cMessage</a> *) iter();
  //...
}
</pre>
<p>

<p>

<p><H3><A NAME="sec243"/>6.5.2 Expandable array: <a href="../api/classcArray.html">cArray</a></H3>

<p><p class="subheading">Basic usage</p>

<p>
<tt><a href="../api/classcArray.html">cArray</a></tt> is a container class that holds objects derived from
<tt><a href="../api/classcObject.html">cObject</a></tt>. <tt><a href="../api/classcArray.html">cArray</a></tt> stores the pointers of the objects
inserted instead of making copies. <tt><a href="../api/classcArray.html">cArray</a></tt> works as an array,
but it grows automatically when it gets full. Internally,
<tt><a href="../api/classcArray.html">cArray</a></tt> is implemented with an array of pointers; when the array
fills up, it is reallocated.

<p><tt><a href="../api/classcArray.html">cArray</a></tt> objects are used in OMNeT++ to store parameters
attached to messages, and internally, for storing module parameters
and gates.

<p>
Creating an array:

<pre>
<a href="../api/classcArray.html">cArray</a> array("array");
</pre>
<p>
Adding an object at the first free index:

<pre>
<a href="../api/classcPar.html">cPar</a> *p = new <a href="../api/classcPar.html">cPar</a>("par");
int index = array.add( p );
</pre>
<p>

<p>Adding an object at a given index (if the index is occupied,
you'll get an error message):

<pre>
<a href="../api/classcPar.html">cPar</a> *p = new <a href="../api/classcPar.html">cPar</a>("par");
int index = array.addAt(5,p);
</pre>
<p>

<p>Finding an object in the array:

<pre>
int index = array.find(p);
</pre>
<p>
Getting a pointer to an object at a given index:

<pre>
<a href="../api/classcPar.html">cPar</a> *p = (<a href="../api/classcPar.html">cPar</a> *) array[index];
</pre>
<p>
You can also search the array or get a pointer to an object by
the object's name:

<pre>
int index = array.find("par");
Par *p = (<a href="../api/classcPar.html">cPar</a> *) array["par"];
</pre>
<p>

<p>You can remove an object from the array by calling <tt>remove()</tt>
with the object name, the index position or the object pointer:

<pre>
array.remove("par");
array.remove(index);
array.remove( p );
</pre>
<p>

<p>The <tt>remove()</tt> function doesn't deallocate the object, but it
returns the object pointer. If you also want to deallocate it, you can
write:

<pre>
delete array.remove( index );
</pre>
<p>
<p class="subheading">Iteration</p>

<p>
<tt><a href="../api/classcArray.html">cArray</a></tt> has no iterator, but it is easy to loop through all the
indices with an integer variable. The <tt>items()</tt> member function
returns the largest index plus one.

<pre>
for (int i=0; i&lt;array.items(); i++)
{
  if (array[i]) // is this position used?
  {
    <a href="../api/classcObject.html">cObject</a> *obj = array[i];
    ev &lt;&lt; obj-&gt;name() &lt;&lt; endl;
  }
}
</pre>
<p>



<p>

<p><H2><A NAME="sec244"/>6.6 The parameter class: <a href="../api/classcPar.html">cPar</a></H2>
<a name="sec:ch-sim-lib:cpar"></a>

<p>Module parameters (as discussed in section <a href="#sec189">[4.7]</a>)
are represented as <tt><a href="../api/classcPar.html">cPar</a></tt> objects.
The module parameter name is the <tt><a href="../api/classcPar.html">cPar</a></tt> object's name, and the object
can store any parameter type supported by the NED language, that is,
numeric (long or double), bool, string and XML config file reference.
    <br><ul><font size=-1>[<tt><a href="../api/classcPar.html">cPar</a></tt> objects used to be employed also for adding
    parameters (extra fields) to <tt><a href="../api/classcMessage.html">cMessage</a></tt>. While technically this is
    still feasible, message definitions (section <a href="#sec213">[5.2]</a>)
    are a far superior solution in every respect.]</font></ul>

<p>Module parameters are accessed via <tt><a href="../api/classcModule.html">cModule</a></tt>'s <tt>par()</tt> method:

<pre>
<a href="../api/classcPar.html">cPar</a>& par(const char *parameterName);
</pre>
<p>
<H3><A NAME="sec245"/>6.6.1 Reading the value</H3>

<p><tt><a href="../api/classcPar.html">cPar</a></tt> has a number of methods for getting the parameter's value:

<pre>
bool boolValue();
long longValue();
const char *stringValue();
double doubleValue();
<a href="../api/classcXMLElement.html">cXMLElement</a> *xmlValue();
</pre>
<p>
There are also overloaded type cast operators for C/C++ primitive types
including <tt>bool</tt>, <tt>int</tt>, <tt>long</tt>, <tt>double</tt>, <tt>const char *</tt>,
and also for <tt><a href="../api/classcXMLElement.html">cXMLElement</a> *</tt>.
    <br><ul><font size=-1>[<tt><a href="../api/classcPar.html">cPar</a></tt> also supports the <tt>void *</tt> and <tt><a href="../api/classcObject.html">cObject</a> *</tt> types,
    but these types were used primarily for message parameters before
    message definitions (section <a href="#sec213">[5.2]</a>)
    got supported, and you cannot create such module parameters from NED.]</font></ul>

<p>Thus, any of the following ways would work to store a parameter's value in
a variable:

<pre>
double foo = par("foo").doubleValue();
double foo = (double) par("foo");
double foo = par("foo");
</pre>
<p>
If you use the <tt>par("foo")</tt> parameter in expressions (such as
<tt>4*par("foo")+2</tt>), the C++ compiler may be unable to decide
between overloaded operators and report ambiguity. In that case
you have to clarify by adding either an explicit cast
(<tt>(double)par("foo")</tt> or <tt>(long)par("foo")</tt>) or use
the <tt>doubleValue()</tt> or <tt>longValue()</tt> methods.

<p>The <tt>isConstant()</tt> method can be used to determine whether a
<tt><a href="../api/classcPar.html">cPar</a></tt> stores a constant, or an expression that may produce a different
value every time the object is read, such as <tt>1+exponential(0.5)</tt>.

<p>
<H3><A NAME="sec246"/>6.6.2 Changing the value</H3>

<p>There are many ways to set a <tt><a href="../api/classcPar.html">cPar</a></tt>'s value. One is the <tt>set...Value()</tt>
member functions:

<pre>
<a href="../api/classcPar.html">cPar</a>& foo = par("foo");
foo.setLongValue(12);
foo.setDoubleValue(2.7371);
foo.setStringValue("one two three");
</pre>
<p>
There are also overloaded assignment operators for C++ primitive types,
<tt>const char *</tt>, and <tt><a href="../api/classcXMLElement.html">cXMLElement</a> *</tt>.

<pre>
<a href="../api/classcPar.html">cPar</a> pp("pp");
pp = 12;
pp = 2.7371;
pp = "one two three";
</pre>
<p>
The <tt><a href="../api/classcPar.html">cPar</a></tt> object makes its own copy of the string, so the
original one does not need to be preserved. Short strings (less than
<it>~</it>20 chars) are handled more efficiently because they
are stored in the object's memory space (and are not dynamically
allocated).

<p><tt><a href="../api/classcPar.html">cPar</a></tt> can also store other types which yield numeric
results such as function with constant args;
they will be mentioned in the next section.

<p>For numeric and string types, an input flag<!--input flag--> can be
set. In this case, when the object's value is first used, the
parameter value will be searched for in the configuration (ini)
file<!--ini file-->; if it is not found there, the user will be offered
to enter the value interactively.

<p>Examples:

<pre>
<a href="../api/classcPar.html">cPar</a> foo("foo");
foo.setPrompt("Enter foo value:");
foo.setInput(true);   // make it an input parameter

double d = (double)foo; // the user will be prompted HERE
</pre>
<p>
Further <tt>set..()</tt> functions to assign other storage types,
e.g. double function with constant args (MathFuncNoArgs, MathFunc1Args, etc),
reverse Polish expression, compiled expressions based on
<tt><a href="../api/classcDoubleExpression.html">cDoubleExpression</a></tt>, random distribution based on a
<tt><a href="../api/classcStatistic.html">cStatistic</a></tt>'s <tt>random()</tt> method, pointer to <tt><a href="../api/classcObject.html">cObject</a></tt>,
etc. are listed in the next section; however, they are rarely useful
for programming simulation models.

<p>

<H3><A NAME="sec247"/>6.6.3 <a href="../api/classcPar.html">cPar</a> storage types</H3>

<p><tt><a href="../api/classcPar.html">cPar</a></tt> supports the basic data types (long, double, bool, string, XML) via
several <i>storage types</i>. Storage types are internally
identified by type characters. The type character is
returned by the <tt>type()</tt> method.

<p>Example:

<pre>
<a href="../api/classcPar.html">cPar</a> par = 10L;
char typechar = par.type(); // returns storage type 'L'
</pre>
<p>
The all <tt><a href="../api/classcPar.html">cPar</a></tt> data types and are summarized in the table below.
The <tt>isNumeric()</tt> function tells whether the object
stores a data types which allows the <tt>doubleValue()</tt> method
to be called.

<p><table border>
<TR> <TD align=left>

<b>Type<br> char</b> </TD> <TD align=left>
<b>Storage<br> type</b> </TD> <TD align=left>
<b>Member functions</b> </TD> <TD align=left>
<b>Description</b></TD></TR>
<TR> <TD align=left>
S </TD> <TD align=left>  string </TD> <TD align=left>
<tt>setStringValue( <br>
  const char *); <br>
const char * <br>
 <tt>stringValue()</tt>; <br>
op const char *(); <br>
op=(const char *);</tt> </TD> <TD align=left>

string value. Short strings (len<tt>&lt;</tt>=27) are stored inside
<tt><a href="../api/classcPar.html">cPar</a></tt> object, without using heap allocation.</TD></TR>
<TR> <TD align=left> B </TD> <TD align=left>  boolean </TD> <TD align=left>
<tt>setBoolValue(bool); <br>
bool <tt>boolValue()</tt>; <br>
op <tt>bool()</tt>; <br>
op=(bool);</tt> </TD> <TD align=left>
boolean value. Can also be retrieved from the object as long  (0 or 1).</TD></TR>
<TR> <TD align=left> L </TD> <TD align=left> long int </TD> <TD align=left>
<tt>setLongValue(long); <br>
long <tt>longValue()</tt>; <br>
op <tt>long()</tt>; <br>
op=(long);</tt> </TD> <TD align=left>
signed long integer value. Can also be retrieved from the object
as double.</TD></TR>
<TR> <TD align=left> D </TD> <TD align=left> double </TD> <TD align=left>
<tt>setDoubleValue(double); <br>
double <tt>doubleValue()</tt>; <br>
op <tt>double()</tt>; <br>
op=(double);</tt> </TD> <TD align=left>
double-precision floating point value.</TD></TR>
<TR> <TD align=left> F </TD> <TD align=left> function </TD> <TD align=left>
<tt>setDoubleValue( <br>
 MathFunc, <br>
 [double], <br>
 [double], <br>
 [double]); <br>
double <tt>doubleValue()</tt>; <br>
op <tt>double()</tt>; <br>
</tt> </TD> <TD align=left>
Mathematical function with constant arguments. The function
is given by its pointer; it must take 0,1,2 or 3 doubles and
return a double. This type is mainly used to generate random
numbers: e.g. the function takes mean and standard deviation
and returns a random variable of a certain distribution.</TD></TR>
<TR> <TD align=left> X </TD> <TD align=left> expr. </TD> <TD align=left>
<tt>setDoubleValue( <br>
 <a href="../api/classcPar.html">cPar</a>::ExprElem*,int); <br>
double <tt>doubleValue()</tt>; <br>
op <tt>double()</tt>;</tt>
</TD> <TD align=left>
Runtime-evaluated Reverse Polish expression. Expression can contain constants,
<tt><a href="../api/classcPar.html">cPar</a></tt> objects, refer to other <tt>cPars</tt> (e.g. module parameters),
can use math operators (+-*/^% etc), function calls
(function must take 0,1,2 or 3 doubles and return a double).
The expression must be given in an array of <tt><a href="../api/classcPar.html">cPar</a>::ExprElem</tt> structs.</TD></TR>
<TR> <TD align=left> C </TD> <TD align=left> compiled<br> expr. </TD> <TD align=left>
<tt>setDoubleValue( <br>
 <a href="../api/classcDoubleExpression.html">cDoubleExpression</a> *expr); <br>
double <tt>doubleValue()</tt>; <br>
op <tt>double()</tt>;</tt>
</TD> <TD align=left>
Runtime-evaluated compiled expression. The expression should be
supplied in a method of an object subclassed from <tt><a href="../api/classcDoubleExpression.html">cDoubleExpression</a></tt>.
</TD></TR>
<TR> <TD align=left> T </TD> <TD align=left> distrib. </TD> <TD align=left>
<tt>setDoubleValue( <br>
 <tt><a href="../api/classcStatistic.html">cStatistic</a></tt>*); <br>
double <tt>doubleValue()</tt>; <br>
op <tt>double()</tt>; <br>
</tt> </TD> <TD align=left>
random variable generated from a distribution collected by a
statistical data collection object (derived from <tt><a href="../api/classcStatistic.html">cStatistic</a></tt>).</TD></TR>
<TR> <TD align=left> M </TD> <TD align=left> XML </TD> <TD align=left>
<tt>setXMLValue( <br>
 <tt><a href="../api/classcXMLElement.html">cXMLElement</a></tt> *node); <br>
<tt><a href="../api/classcXMLElement.html">cXMLElement</a></tt> *<tt>xmlValue</tt>()</tt>; <br>
op <tt><a href="../api/classcXMLElement.html">cXMLElement</a>*()</tt>;
</TD> <TD align=left>
Reference to an XML element, found in an XML config file.
</TD></TR>
<TR> <TD align=left> P </TD> <TD align=left> void* pointer </TD> <TD align=left>
<tt>setPointerValue(void*); <br>
void *<tt>pointerValue()</tt>; <br>
op void *(); <br>
op=(void *);</tt> </TD> <TD align=left>
pointer to a non-<tt><a href="../api/classcObject.html">cObject</a></tt> item (C struct, non-<tt><a href="../api/classcObject.html">cObject</a></tt> object
etc.) Memory management can be controlled through the <tt>configPointer()</tt>
member function.</TD></TR>
<TR> <TD align=left> O </TD> <TD align=left> object pointer </TD> <TD align=left>
<tt>setObjectValue(<a href="../api/classcObject.html">cObject</a>*); <br>
<a href="../api/classcObject.html">cObject</a> *<tt>objectValue()</tt>; <br>
op <a href="../api/classcObject.html">cObject</a> *(); <br>
op=(<a href="../api/classcObject.html">cObject</a> *);</tt>
</TD> <TD align=left>
 pointer to an object derived from <tt><a href="../api/classcObject.html">cObject</a></tt>.
Ownership management is done through <tt>takeOwnership()</tt>.</TD></TR>
<TR> <TD align=left> I </TD> <TD align=left> indirect value </TD> <TD align=left>
<tt>setRedirection(<a href="../api/classcPar.html">cPar</a>*); <br>
bool <tt>isRedirected()</tt>; <br>
<a href="../api/classcPar.html">cPar</a> *<tt>redirection()</tt>; <br>
<tt>cancelRedirection()</tt>;</tt>
</TD> <TD align=left>
 value is redirected to another <tt><a href="../api/classcPar.html">cPar</a></tt> object. All value setting
and reading operates on the other <tt><a href="../api/classcPar.html">cPar</a></tt>; even the <tt>type()</tt> function
will return the type in the other <tt><a href="../api/classcPar.html">cPar</a></tt> (so you'll never get 'I'
as the type). This redirection can only be broken with the <tt>cancelRedirection()</tt>
member function. Module parameters taken by <tt>ref</tt> use this mechanism.</TD></TR>
</table>

<p>


<p><H2><A NAME="sec248"/>6.7 Routing support: <a href="../api/classcTopology.html">cTopology</a></H2>

<p><H3><A NAME="sec249"/>6.7.1 Overview</H3>

<p>The <tt><a href="../api/classcTopology.html">cTopology</a></tt> class was designed primarily to support
routing<!--routing support--> in telecommunication or multiprocessor
networks.

<p>A <tt><a href="../api/classcTopology.html">cTopology</a></tt> object stores an abstract representation of the
network in graph form:
<ul>
  <li>each <tt><a href="../api/classcTopology.html">cTopology</a></tt> node corresponds to a <i>module</i>
    (simple or compound), and
  <li>each <tt><a href="../api/classcTopology.html">cTopology</a></tt> edge corresponds to a <i>link</i> or
    <i>series of connecting links</i>.
</ul>

<p>You can specify which modules (either simple or compound) you want to
include in the graph. The graph will include all connections among the
selected modules. In the graph, all nodes are at the same level,
there's no submodule nesting.  Connections which span across compound
module boundaries are also represented as one graph edge. Graph edges
are directed, just as module gates are.

<p>
If you're writing a router or switch model, the <tt><a href="../api/classcTopology.html">cTopology</a></tt>
graph can help you determine what nodes are available through which
gate and also to find optimal routes<!--optimal routes-->. The
<tt><a href="../api/classcTopology.html">cTopology</a></tt> object can calculate shortest paths<!--shortest
  path--> between nodes for you.

<p>The mapping between the graph (nodes, edges) and network model
(modules, gates, connections) is preserved: you can easily find
the corresponding module for a <tt><a href="../api/classcTopology.html">cTopology</a></tt> node and vica versa.

<p>

<p>

<p><H3><A NAME="sec250"/>6.7.2 Basic usage</H3>

<p>You can extract the network topology into a <tt><a href="../api/classcTopology.html">cTopology</a></tt>
object by a single function call. You have several ways to select
which modules you want to include in the topology:
<ul>
  <li>by module type
  <li>by a parameter's presence and its value
  <li>with a user-supplied boolean function
</ul>

<p>First, you can specify which node types you want to include. The
following code extracts all modules of type <tt>Router</tt> or <tt>Host</tt>.
(<tt>Router</tt> and <tt>Host</tt> can be either simple or compound module types.)

<pre>
<a href="../api/classcTopology.html">cTopology</a> topo;
topo.extractByModuleType("Router", "Host", NULL);
</pre>
<p>
Any number of module types can be supplied; the list must be terminated by <tt>NULL</tt>.

<p>A dynamically assembled list of module types can be passed as a
<tt>NULL</tt>-terminated array of <tt>const char*</tt> pointers, or
in an STL string vector <tt>std::vector&lt;std::string&gt;</tt>.
An example for the former:

<pre>
<a href="../api/classcTopology.html">cTopology</a> topo;
const char *typeNames[3];
typeNames[0] = "Router";
typeNames[1] = "Host";
typeNames[2] = NULL;
topo.extractByModuleType(typeNames);
</pre>
<p>
Second, you can extract all modules which have a certain parameter:

<pre>
topo.extractByParameter( "ipAddress" );
</pre>
<p>
You can also specify that the parameter must have a certain value
for the module to be included in the graph:

<pre>
<a href="../api/classcPar.html">cPar</a> yes = "yes";
topo.extractByParameter( "includeInTopo", &yes );
</pre>
<p>
The third form allows you to pass a function which can determine for
each module whether it should or should not be included.  You can have
<tt><a href="../api/classcTopology.html">cTopology</a></tt> pass supplemental data to the function through a
<tt>void*</tt> pointer. An example which selects all top-level modules (and
does not use the <tt>void*</tt> pointer):

<pre>
int selectFunction(<a href="../api/classcModule.html">cModule</a> *mod, void *)
{
  return mod-&gt;parentModule() == simulation.systemModule();
}

topo.extractFromNetwork( selectFunction, NULL );
</pre>
<p>

A <tt><a href="../api/classcTopology.html">cTopology</a></tt> object uses two types: <tt><a href="../api/classcTopology.html">cTopology</a>::Node</tt> for
nodes and <tt><a href="../api/classcTopology.html">cTopology</a>::Link</tt> for edges. (<tt>sTopoLinkIn</tt> and
<tt><a href="../api/classcTopology.html">cTopology</a>::LinkOut</tt> are `aliases' for <tt><a href="../api/classcTopology.html">cTopology</a>::Link</tt>; we'll
talk about them later.)

<p>Once you have the topology extracted, you can start exploring
it. Consider the following code (we'll explain it shortly):

<pre>
for (int i=0; i&lt;topo.nodes(); i++)
{
  <a href="../api/classcTopology.html">cTopology</a>::Node *node = topo.node(i);
  ev &lt;&lt; "Node i=" &lt;&lt; i &lt;&lt; " is " &lt;&lt; node-&gt;module()-&gt;fullPath() &lt;&lt; endl;
  ev &lt;&lt; " It has " &lt;&lt; node-&gt;outLinks() &lt;&lt; " conns to other nodes\n";
  ev &lt;&lt; " and " &lt;&lt; node-&gt;inLinks() &lt;&lt; " conns from other nodes\n";

  ev &lt;&lt; " Connections to other modules are:\n";
  for (int j=0; j&lt;node-&gt;outLinks(); j++)
  {
    <a href="../api/classcTopology.html">cTopology</a>::Node *neighbour = node-&gt;out(j)-&gt;remoteNode();
    <a href="../api/classcGate.html">cGate</a> *gate = node-&gt;out(j)-&gt;localGate();
    ev &lt;&lt; " " &lt;&lt; neighbour-&gt;module()-&gt;fullPath()
       &lt;&lt; " through gate " &lt;&lt; gate-&gt;fullName() &lt;&lt; endl;
  }
}
</pre>
<p>
The <tt>nodes()</tt> member function (1st line) returns the number of
nodes in the graph, and node(i) returns a pointer to the <i>i</i>th
node, an <tt><a href="../api/classcTopology.html">cTopology</a>::Node</tt> structure.

<p>
The correspondence between a graph node and a module can be obtained
by:

<pre>
<a href="../api/classcTopology.html">cTopology</a>::Node *node = topo.nodeFor( module );
<a href="../api/classcModule.html">cModule</a> *module = node-&gt;module();
</pre>
<p>

<p>The <tt>nodeFor()</tt> member function returns a pointer to the graph
node for a given module. (If the module is not in the graph, it
returns <tt>NULL</tt>). <tt>nodeFor()</tt> uses binary search within the
<tt><a href="../api/classcTopology.html">cTopology</a></tt> object so it is fast enough.

<p>
<tt><a href="../api/classcTopology.html">cTopology</a>::Node</tt>'s other member functions let you determine the
connections of this node: <tt>inLinks()</tt>, <tt>outLinks()</tt> return
the number of connections, <tt>in(i)</tt> and
<tt>out(i)</tt> return pointers to graph edge objects.

<p>
By calling member functions of the graph edge object, you can
determine the modules and gates involved. The <tt>remoteNode()</tt>
function returns the other end of the connection, and
<tt>localGate()</tt>, <tt>remoteGate()</tt>, <tt>localGateId()</tt> and
<tt>remoteGateId()</tt> return the gate pointers and ids of the gates
involved. (Actually, the implementation is a bit tricky here: the same
graph edge object <tt><a href="../api/classcTopology.html">cTopology</a>::Link</tt> is returned either as
<tt><a href="../api/classcTopology.html">cTopology</a>::LinkIn</tt> or as <tt><a href="../api/classcTopology.html">cTopology</a>::LinkOut</tt> so that ``remote''
and ``local'' can be correctly interpreted for edges of both
directions.)

<p>

<p>

<p><H3><A NAME="sec251"/>6.7.3 Shortest paths</H3>

<p>The real power of <tt><a href="../api/classcTopology.html">cTopology</a></tt> is in finding shortest
paths<!--topology!shortest path--> in the network to support optimal
routing<!--optimal routing-->. <tt><a href="../api/classcTopology.html">cTopology</a></tt> finds shortest paths
from <i>all</i> nodes <i>to</i> a target node. The algorithm is
computationally inexpensive. In the simplest case, all edges are
assumed to have the same weight.

<p>A real-life example when we have the target module pointer, finding
the shortest path looks like this:

<pre>
<a href="../api/classcModule.html">cModule</a> *targetmodulep =...;
<a href="../api/classcTopology.html">cTopology</a>::Node *targetnode = topo.nodeFor( targetmodulep );
topo.unweightedSingleShortestPathsTo( targetnode );
</pre>
<p>

<p>This performs the Dijkstra algorithm<!--Dijkstra algorithm--> and
stores the result in the <tt><a href="../api/classcTopology.html">cTopology</a></tt> object. The result can
then be extracted using <tt><a href="../api/classcTopology.html">cTopology</a></tt> and
<tt><a href="../api/classcTopology.html">cTopology</a>::Node</tt><!--<a href="../api/classcTopology.html">cTopology</a>::Node--> methods.  Naturally, each call to
<tt>unweightedSingleShortestPathsTo()</tt> overwrites the results of
the previous call.

<p>Walking along the path from our module to the target node:

<pre>
<a href="../api/classcTopology.html">cTopology</a>::Node *node = topo.nodeFor( this );

if (node == NULL)
{
  ev &lt; "We (" &lt;&lt; fullPath() &lt;&lt; ") are not included in the topology.\n";
}
else if (node-&gt;paths()==0)
{
  ev &lt;&lt; "No path to destination.\n";
}
else
{
  while (node != topo.targetNode())
  {
    ev &lt;&lt; "We are in " &lt;&lt; node-&gt;module()-&gt;fullPath() &lt;&lt; endl;
    ev &lt;&lt; node-&gt;distanceToTarget() &lt;&lt; " hops to go\n";
    ev &lt;&lt; "There are " &lt;&lt; node-&gt;paths()
       &lt;&lt; " equally good directions, taking the first one\n";
    <a href="../api/classcTopology.html">cTopology</a>::LinkOut *path = node-&gt;path(0);
    ev &lt;&lt; "Taking gate " &lt;&lt; path-&gt;localGate()-&gt;fullName()
       &lt;&lt; " we arrive in " &lt;&lt; path-&gt;remoteNode()-&gt;module()-&gt;fullPath()
       &lt;&lt; " on its gate " &lt;&lt; path-&gt;remoteGate()-&gt;fullName() &lt;&lt; endl;
    node = path-&gt;remoteNode();
  }
}
</pre>
<p>

<p>The purpose of the <tt>distanceToTarget()</tt> member function of a
node is self-explanatory. In the unweighted case, it returns the
number of hops. The <tt>paths()</tt> member function returns the number
of edges which are part of a shortest path, and
<tt>path(i)</tt> returns the <i>i</i>th edge of them as
<tt><a href="../api/classcTopology.html">cTopology</a>::LinkOut</tt>. If the shortest paths were created by the
<tt>...SingleShortestPaths()</tt> function,
<tt>paths()</tt> will always return 1 (or 0 if the target is not
reachable), that is, only one of the several possible shortest paths
are found.  The
<tt>...MultiShortestPathsTo()</tt> functions
find all paths, at increased run-time cost. The <tt><a href="../api/classcTopology.html">cTopology</a></tt>'s
<tt>targetNode()</tt> function returns the target node of the last
shortest path search.

<p>You can enable/disable nodes or edges in the graph. This is done by
calling their <tt>enable()</tt> or <tt>disable()</tt> member functions.
Disabled nodes or edges are ignored by the shortest paths calculation
algorithm. The <tt>enabled()</tt> member function returns the state of
a node or edge in the topology graph.

<p>One usage of <tt>disable()</tt> is when you want to determine in how many
hops the target node can be reached from our node <i>through
a particular output gate</i>. To calculate this, you calculate the
shortest paths to the target <i>from the neighbor node</i>, but
you must disable the current node to prevent the shortest paths
from going through it:

<pre>
<a href="../api/classcTopology.html">cTopology</a>::Node *thisnode = topo.nodeFor( this );
thisnode-&gt;disable();
topo.unweightedSingleShortestPathsTo( targetnode );
thisnode-&gt;enable();

for (int j=0; j&lt;thisnode-&gt;outLinks(); j++)
{
  <a href="../api/classcTopology.html">cTopology</a>::LinkOut *link = thisnode-&gt;out(i);
  ev &lt;&lt; "Through gate " &lt;&lt; link-&gt;localGate()-&gt;fullName() &lt;&lt; " : "
     &lt;&lt; 1 + link-&gt;remoteNode()-&gt;distanceToTarget() &lt;&lt; " hops" &lt;&lt; endl;
}
</pre>
<p>
In the future, other shortest path algorithms will also be implemented:

<pre>
unweightedMultiShortestPathsTo(<a href="../api/classcTopology.html">cTopology</a>::Node *target);
weightedSingleShortestPathsTo(<a href="../api/classcTopology.html">cTopology</a>::Node *target);
weightedMultiShortestPathsTo(<a href="../api/classcTopology.html">cTopology</a>::Node *target);
</pre>
<p>

<p>

<p>

<p><H2><A NAME="sec252"/>6.8 Statistics and distribution estimation</H2>

<p><H3><A NAME="sec253"/>6.8.1 <a href="../api/classcStatistic.html">cStatistic</a> and descendants</H3>

<p>There are several statistic and result collection classes:
<tt><a href="../api/classcStdDev.html">cStdDev</a></tt>, <tt><a href="../api/classcWeightedStdDev.html">cWeightedStdDev</a></tt>, <tt>LongHistogram</tt>,
<tt><a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a></tt>, <tt><a href="../api/classcVarHistogram.html">cVarHistogram</a></tt>, <tt><a href="../api/classcPSquare.html">cPSquare</a></tt> and
<tt><a href="../api/classcKSplit.html">cKSplit</a></tt>. They are all derived from the abstract base class
<tt><a href="../api/classcStatistic.html">cStatistic</a></tt>.

<p><ul>
  <li><tt><a href="../api/classcStdDev.html">cStdDev</a></tt> keeps number of samples, mean, standard
    deviation, minimum and maximum value etc.
  <li><tt><a href="../api/classcWeightedStdDev.html">cWeightedStdDev</a></tt> is similar to <tt><a href="../api/classcStdDev.html">cStdDev</a></tt>, but
    accepts weighted observations. <tt><a href="../api/classcWeightedStdDev.html">cWeightedStdDev</a></tt> can be used
    for example to calculate time average. It is the only weighted
    statistics class.
  <li><tt><a href="../api/classcLongHistogram.html">cLongHistogram</a></tt> and <tt><a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a></tt> are
    descendants of <tt><a href="../api/classcStdDev.html">cStdDev</a></tt> and also keep an approximation of
    the distribution of the observations using equidistant
    (equal-sized) cell histograms<!--histogram!equal-sized-->.
  <li><tt><a href="../api/classcVarHistogram.html">cVarHistogram</a></tt> implements a histogram where cells do not
    need to be the same size. You can manually add the cell (bin)
    boundaries, or alternatively, automatically have a partitioning
    created where each bin has the same number of observations (or as
    close to that as possible).
  <li><tt><a href="../api/classcPSquare.html">cPSquare</a></tt> is a class that uses the <i>P<sup>2</sup></i> algorithm
    described in [<a href="#bib-JCh85">JCh85</a>]. The algorithm calculates quantiles without
    storing the observations; one can also think of it as a histogram
    with equiprobable cells<!--histogram!equiprobable-cells-->.
  <li><tt><a href="../api/classcKSplit.html">cKSplit</a></tt> uses a novel, experimental method, based on an
    adaptive histogram-like algorithm.
</ul>

<p><p class="subheading">Basic usage</p>

<p>One can insert an observation into a statistic object with the
<tt>collect()</tt> function or the <tt>+=</tt> operator (they are
equivalent).  <tt><a href="../api/classcStdDev.html">cStdDev</a></tt> has the following methods for getting
statistics out of the object: <tt>samples()</tt>, <tt>min()</tt>,
<tt>max()</tt>, <tt>mean()</tt>, <tt>stddev()</tt>, <tt>variance()</tt>,
<tt>sum()</tt>, <tt>sqrSum()</tt> with the obvious meanings. An example
usage for <tt><a href="../api/classcStdDev.html">cStdDev</a></tt>:

<pre>
<a href="../api/classcStdDev.html">cStdDev</a> stat("stat");

for (int i=0; i&lt;10; i++)
  stat.collect( normal(0,1) );

long numSamples = stat.samples();
double smallest = stat.min(),
       largest = stat.max();
double mean = stat.mean(),
       standardDeviation = stat.stddev(),
       variance = stat.variance();
</pre>
<p>

<p>

<p>
<H3><A NAME="sec254"/>6.8.2 Distribution estimation</H3>

<p><p class="subheading">Initialization and usage</p>

<p>
The distribution estimation<!--distribution!estimation--> classes
(<tt><a href="../api/classcLongHistogram.html">cLongHistogram</a></tt>, <tt><a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a></tt>, <tt><a href="../api/classcVarHistogram.html">cVarHistogram</a></tt>,
<tt><a href="../api/classcPSquare.html">cPSquare</a></tt> and <tt><a href="../api/classcKSplit.html">cKSplit</a></tt>) are derived from
<tt><a href="../api/classcDensityEstBase.html">cDensityEstBase</a></tt>. Distribution estimation classes (except for
<tt><a href="../api/classcPSquare.html">cPSquare</a></tt>) assume that the observations are within a range.
You may specify the range explicitly (based on some a-priori info
about the distribution) or you may let the object collect the first
few observations and determine the range from them. Methods which let
you specify range settings are part of <tt><a href="../api/classcDensityEstBase.html">cDensityEstBase</a></tt>.

<p>The following member functions exist for setting up the range
and to specify how many observations should be used for
automatically determining the range.

<pre>
setRange(lower,upper);
setRangeAuto(numFirstvals, rangeExtFactor);
setRangeAutoLower(upper, numFirstvals, rangeExtFactor);
setRangeAutoUpper(lower, numFirstvals, rangeExtFactor);
</pre>
<p>
<pre>
setNumFirstVals(numFirstvals);
</pre>

<p>The following example creates a histogram with 20 cells and automatic
range estimation<!--histogram!range estimation-->:

<pre>
<a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a> histogram("histogram", 20);
histogram.setRangeAuto(100,1.5);
</pre>
<p>

<p>Here, 20 is the number of cells (not including the underflow/overflow
cells, see later), and 100 is the number of observations to be
collected before setting up the cells. 1.5 is the range extension
factor. It means that the actual range of the initial observations
will be expanded 1.5 times and this expanded range will be used to lay
out the cells. This method increases the chance that further
observations fall in one of the cells and not outside the histogram
range.

<p>
  <div align=center>
    <img src="usmanFig12.gif">
    <center><i>Figure: Setting up a histogram's range</i></center>
  </div>

<p>
After the cells have been set up, collection can go on.

<p>The <tt>transformed()</tt> function returns <i>true</i> when the cells have
already been set up. You can force range estimation and setting
up the cells by calling the <tt>transform()</tt> function.

<p>The observations that fall outside the histogram range will be counted
as underflows and overflows. The number of underflows and overflows
are returned by the <tt>underflowCell()</tt> and <tt>overflowCell()</tt>
member functions.

<p>
<div align=center>
  <img src="usmanFig13.gif">
  <center><i>Figure: Histogram structure after setting up the cells</i></center>
</div>

<p>
You create a <i>P<sup>2</sup></i> object by specifying the number of cells:

<pre>
<a href="../api/classcPSquare.html">cPSquare</a> psquare("interarrival-times", 20);
</pre>
<p>
Afterwards, a <tt><a href="../api/classcPSquare.html">cPSquare</a></tt> can be used with the same member functions
as a histogram.

<p>
<p class="subheading">Getting histogram data</p>

<p>
There are three member functions to explicitly return cell boundaries
and the number of observations is each cell. <tt>cells()</tt> returns
the number of cells, <tt>basepoint(int k)</tt> returns the
<i>k</i>th base point, <tt>cell(int k)</tt> returns the
number of observations in cell <i>k</i>, and
<tt>cellPDF(int k)</tt> returns the PDF value in the cell
(i.e. between <tt>basepoint(k)</tt> and
<tt>basepoint(k+1)</tt>).  These functions work for all
histogram types, plus <tt><a href="../api/classcPSquare.html">cPSquare</a></tt> and <tt><a href="../api/classcKSplit.html">cKSplit</a></tt>.

<p>
  <div align=center>
    <img src="usmanFig14.gif">
    <center><i>Figure: base points and cells</i></center>
  </div>

<p>
An example:

<pre>
long n = histogram.samples();
for (int i=0; i&lt;histogram.cells(); i++)
{
  double cellWidth = histogram.basepoint(i+1)-histogram.basepoint(i);
  int count = histogram.cell(i);
  double pdf = histogram.cellPDF(i);
  //...
}
</pre>
<p>

<p>The <tt>pdf(x)</tt> and <tt>cdf(x)</tt> member functions
return the value of the Probability Density Function and the Cumulated
Density Function at a given <i>x</i>, respectively.

<p>
<p class="subheading">Random number generation from distributions</p>

<p>
The <tt>random()</tt> member function generates random
numbers<!--random!numbers--> from the distribution stored by the
object:

<pre>
double rnd = histogram.random();
</pre>
<p>

<p><tt><a href="../api/classcStdDev.html">cStdDev</a></tt> assumes normal distribution.

<p>You can also wrap the distribution object in a <tt><a href="../api/classcPar.html">cPar</a></tt>:

<pre>
<a href="../api/classcPar.html">cPar</a> rndPar("rndPar");
rndPar.setDoubleValue(&histogram);
</pre>
<p>

<p>The <tt><a href="../api/classcPar.html">cPar</a></tt> object stores the pointer to the histogram (or <i>P<sup>2</sup></i> object),
and whenever it is asked for the value, calls the histogram object's <tt>random()</tt>
function:

<pre>
double rnd = (double)rndPar; // random number from the <a href="../api/classcPSquare.html">cPSquare</a>
</pre>
<p>
<p class="subheading">Storing/loading distributions</p>

<p>
The statistic classes have <tt>loadFromFile()</tt> member functions
that read the histogram data from a text file. If you need a custom
distribution<!--distribution!custom--> that cannot be written (or it
is inefficient) as a C function, you can describe it in histogram form
stored in a text file, and use a histogram object with
<tt>loadFromFile()</tt>.

<p>You can also use <tt>saveToFile()</tt>that writes out the distribution
collected by the histogram object:

<pre>
FILE *f = fopen("histogram.dat","w");
histogram.saveToFile(f); // save the distribution
fclose(f);

<a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a> hist2("Hist-from-file");
FILE *f2 = fopen("histogram.dat","r");
hist2.loadFromFile(f2); // load stored distribution
fclose(f2);
</pre>
<p>

<p><p class="subheading">Histogram with custom cells</p>

<p>
The <tt><a href="../api/classcVarHistogram.html">cVarHistogram</a></tt> class can be used to create
histograms with arbitrary (non-equidistant) cells.
It can operate in two modes:

<p><ul>
  <li> <i>manual</i>, where you specify cell boundaries explicitly
     before starting collecting
  <li> <i>automatic</i>, where <tt>transform()</tt> will set up the cells
     after collecting a certain number of initial observations. The cells
     will be set up so that as far as possible, an equal number of observations
     fall into each cell (equi-probable cells).
</ul>

<p>Modes are selected with a <i>transform-type</i> parameter:
<ul>
  <li><tt>HIST_TR_NO_TRANSFORM</tt>: no transformation; uses bin boundaries
    previously defined by <tt>addBinBound()</tt>
  <li><tt>HIST_TR_AUTO_EPC_DBL</tt>: automatically creates equiprobable cells
  <li><tt>HIST_TR_AUTO_EPC_INT</tt>: like the above, but for integers
</ul>

<p>Creating an object:

<pre>
<a href="../api/classcVarHistogram.html">cVarHistogram</a>(const char *s=NULL,
              int numcells=11,
              int transformtype=HIST_TR_AUTO_EPC_DBL);
</pre>
<p>
Manually adding a cell boundary:

<pre>
void addBinBound(double x);
</pre>
<p>
Rangemin and rangemax is chosen after collecting the
<tt>numFirstVals</tt> initial observations. One cannot add cell
boundaries when the histogram has already been transformed.

<p>

<p>

<p><H3><A NAME="sec255"/>6.8.3 The k-split algorithm</H3>

<p><p class="subheading">Purpose</p>

<p>
The <i>k</i>-split algorithm is an on-line distribution
estimation<!--distribution!online estimation--> method.  It was
designed for on-line result collection in simulation programs.  The
method was proposed by Varga and Fakhamzadeh in 1997. The primary
advantage of <i>k</i>-split is that without having to store the
observations, it gives a good estimate without requiring a-priori
information about the distribution, including the sample size. The
<i>k</i>-split algorithm can be extended to multi-dimensional
distributions<!--distribution!multi-dimensional-->, but here we deal
with the one-dimensional version only.

<p>
<p class="subheading">The algorithm</p>

<p>
The <i>k-split</i> algorithm is an adaptive histogram-type estimate which
maintains a good partitioning by doing cell splits. We start out with
a histogram range <i>[x<sub>lo</sub>, x<sub>hi</sub>)</i> with <i>k</i> equal-sized histogram
cells with observation counts <i>n<sub>1</sub>,n<sub>2</sub>, .. n<sub>k</sub></i>.  Each collected
observation increments the corresponding observation count. When an
observation count <i>n<sub>i</sub></i> reaches a <i>split threshold</i>, the cell
is split into <i>k</i> smaller, equal-sized cells with observation counts
<i>n<sub>i,1</sub>, n<sub>i,2</sub>, .. n<sub>i,k</sub></i> initialized to zero. The <i>n<sub>i</sub></i>
observation count is remembered and is called the <i>mother
  observation count</i> to the newly created cells. Further observations
may cause cells to be split further (e.g. <i>n<sub>i,1,1</sub>,...n<sub>i,1,k</sub></i>
etc.), thus creating a <i>k</i>-order tree of observation counts where
leaves contain live counters that are actually incremented by new
observations, and intermediate nodes contain mother observation counts
for their children. If an observation falls outside the histogram
range, the range is extended in a natural manner by inserting new
level(s) at the top of the tree. The fundamental parameter to the
algorithm is the split factor <i>k</i>. Experience shows that <i>k=2</i> worked best.

<p>
  <div align=center>
    <img src="usmanFig15.gif">
    <center><i>Figure: Illustration of the k-split algorithm, <i>k=2</i>. The
      numbers in boxes represent the observation count values</i></center>
  </div>

<p>

<p>For density estimation, the total number of observations that
fell into each cell of the partition has to be determined. For
this purpose, mother observations in each internal node of the
tree must be distributed among its child cells and propagated
up to the leaves.

<p>
Let <i>n<sub>...,i</sub></i> be the (mother) observation count for a cell,
<i>s<sub>...,i</sub></i> be the total observation count in a cell <i>n<sub>...,i</sub></i> plus
the observation counts in all its sub-, sub-sub-, etc. cells), and
<i>m<sub>...,i</sub></i> the mother observations propagated to the cell. We are
interested in the <i>&ntilde;<sub>...,i</sub> = n<sub>...,i</sub> + m<sub>...,i</sub></i>
estimated amount of observations in the tree nodes, especially in the
leaves. In other words, if we have <i>&ntilde;<sub>...,i</sub></i> estimated
observation amount in a cell, how to divide it to obtain
<i>m<sub>...,i,1</sub>, m<sub>...,i,2</sub> .. m<sub>...,i,k</sub></i>
that can be propagated to child cells. Naturally,
<i>m<sub>...,i,1</sub> + m<sub>...,i,2</sub> + .. + m<sub>...,i,k</sub> = &ntilde;<sub>...,i</sub></i>.

<p>
Two natural distribution methods are even
distribution<!--distribution!even--> (when
<i>m<sub>...,i,1</sub> = m<sub>...,i,2</sub> = .. = m<sub>...,i,k</sub></i>) and proportional
distribution<!--distribution!proportional--> (when
<i>m<sub>...,i,1</sub> : m<sub>...,i,2</sub> : .. : m<sub>...,i,k</sub> = s<sub>...,i,1</sub> : s<sub>...,i,2</sub> : .. : s<sub>...,i,k</sub></i>).
Even distribution is optimal when the
<i>s<sub>...,i,j</sub></i> values are very small, and proportional distribution is
good when the <i>s<sub>...,i,j</sub></i> values are large compared to
<i>m<sub>...,i,j</sub></i>. In practice, a linear combination of them seems
appropriate, where <i>&lambda;=0</i> means even and <i>&lambda;=1</i> means
proportional distribution:

<p>
<i>m<sub>..,i,j</sub> = (1-&lambda;)&ntilde;<sub>..,i</sub>/k + &lambda; &ntilde;<sub>..,i</sub> s<sub>...,i,j</sub> / s<sub>..,i</sub></i>
where <i>&lambda; is in [0,1]</i>

<p>
  <div align=center>
    <img src="usmanFig16.gif">
    <center><i>Figure: Density estimation from the k-split cell tree. We
      assume <i>&lambda;=0</i>, i.e. we distribute mother observations
      evenly.</i></center>
  </div>

<p>

Note that while <i>n<sub>...,i</sub></i> are integers, <i>m<sub>...,i</sub></i> and thus
<i>&ntilde;<sub>...,i</sub></i> are typically real numbers. The histogram estimate
calculated from <i>k</i>-split is not exact, because the frequency
counts calculated in the above manner contain a degree of estimation
themselves. This introduces a certain <i>cell division error</i>;
the <i>&lambda;</i> parameter should be selected so that it minimizes that
error. It has been shown that the cell division error can
be reduced to a more-than-acceptable small value.<br>
Strictly speaking, the <i>k</i>-split algorithm is semi-online,
because its needs some observations to set up the initial histogram
range.  Because of the range extension and cell split
capabilities, the algorithm is not very sensitive to the choice of the
initial range, so very few observations are sufficient for range
estimation (say <i>N<sub>pre</sub>=10</i>). Thus we can regard <i>k</i>-split as
an on-line method.

<p><i>K</i>-split can also be used in semi-online mode, when the
algorithm is only used to create an optimal partition from a larger
number of <i>N<sub>pre</sub></i> observations. When the partition has been created,
the observation counts are cleared and the <i>N<sub>pre</sub></i> observations are
fed into <i>k</i>-split once again. This way all mother (non-leaf)
observation counts will be zero and the cell division error is
eliminated. It has been shown that the partition created by
<i>k</i>-split can be better than both the equi-distant and the
equal-frequency partition.

<p>
OMNeT++ contains an experimental implementation of the <i>k</i>-split
algorithm, the <tt><a href="../api/classcKSplit.html">cKSplit</a></tt> class. Research on <i>k</i>-split is
still under way.

<p>
<p class="subheading">The <a href="../api/classcKSplit.html">cKSplit</a> class</p>

<p>The <tt><a href="../api/classcKSplit.html">cKSplit</a></tt> class is an implementation of the <i>k-split</i> method.
Member functions:


<pre>
void setCritFunc(KSplitCritFunc _critfunc, double *_critdata);
void setDivFunc(KSplitDivFunc \_divfunc, double *\_divdata);
void rangeExtension( bool enabled );
</pre>
<p>

<pre>
int treeDepth();
int treeDepth(sGrid& grid);
</pre>
<p>
<pre>
double realCellValue(sGrid& grid, int cell);
void printGrids();
</pre>

<pre>
sGrid& grid(int k);
sGrid& rootGrid();
</pre>
<p>
<pre>
struct sGrid
{
  int parent;   // index of parent grid
  int reldepth; // depth = (reldepth - rootgrid's reldepth)
  long total;   // sum of cells & all subgrids (includes `mother')
  int mother;   // observations `inherited' from mother cell
  int cells[K]; // cell values
};
</pre>

<p>

<p><H3><A NAME="sec256"/>6.8.4 Transient detection and result accuracy</H3>

<p>In many simulations, only the steady state performance (i.e.
the performance after the system has reached a stable state)
is of interest. The initial part of the simulation is called
the transient period. After the model has entered steady state,
simulation must proceed until enough statistical data has been
collected to compute result with the required accuracy.

<p>
Detection of the end of the transient period and a certain result
accuracy is supported by OMNeT++. The user can attach transient
detection<!--transient detection--> and result accuracy<!--result
  accuracy--> objects to a result object (<tt><a href="../api/classcStatistic.html">cStatistic</a></tt>'s
descendants). The transient detection and result accuracy objects will
do the specific algorithms on the data fed into the result object and
tell if the transient period is over or the result accuracy has been
reached.

<p>The base classes for classes implementing specific transient
detection and result accuracy detection algorithms are:
<ul>
<li><tt><a href="../api/classcTransientDetection.html">cTransientDetection</a></tt>: base class for transient detection
<li><tt><a href="../api/classcAccuracyDetection.html">cAccuracyDetection</a></tt>: base class for result accuracy detection
</ul>

<p>
<p class="subheading">Basic usage</p>


Attaching detection objects to a <tt><a href="../api/classcStatistic.html">cStatistic</a></tt> and getting pointers
to the attached objects:

<pre>
addTransientDetection(<a href="../api/classcTransientDetection.html">cTransientDetection</a> *object);
addAccuracyDetection(<a href="../api/classcAccuracyDetection.html">cAccuracyDetection</a> *object);
<a href="../api/classcTransientDetection.html">cTransientDetection</a> *transientDetectionObject();
<a href="../api/classcAccuracyDetection.html">cAccuracyDetection</a> *accuracyDetectionObject();
</pre>
<p>

<p>Detecting the end of the period:
<ul>
<li>polling the <tt>detect()</tt> function of the object
<li>installing a post-detect function
</ul>

<p>
<p class="subheading">Transient detection</p>

<p>
Currently one transient detection<!--transient detection--> algorithm
is implemented, i.e.  there's one class derived from
<tt><a href="../api/classcTransientDetection.html">cTransientDetection</a></tt>. The <tt><a href="../api/classcTDExpandingWindows.html">cTDExpandingWindows</a></tt> class
uses the sliding window approach with two windows, and checks the
difference of the two averages to see if the transient period is over.

<pre>
void setParameters(int reps=3,
                   int minw=4,
                   double wind=1.3,
                   double acc=0.3);
</pre>
<p>
<p class="subheading">Accuracy detection</p>

<p>
Currently one accuracy detection<!--accuracy detection--> algorithm
is implemented, i.e.  there's one class derived from
<tt><a href="../api/classcAccuracyDetection.html">cAccuracyDetection</a></tt>. The algorithm implemented in the
<tt><a href="../api/classcADByStddev.html">cADByStddev</a></tt> class is: divide the standard deviation by the
square of the number of values and check if this is small enough.

<pre>
void setParameters(double acc=0.1, int reps=3);
</pre>
<p>

<p>

<p><H2><A NAME="sec257"/>6.9 Recording simulation results</H2>

<p><H3><A NAME="sec258"/>6.9.1 Output vectors: <a href="../api/classcOutVector.html">cOutVector</a></H3>
<a name="sec:ch-sim-lib:coutvector"></a>

<p>Objects of type <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> are responsible for writing time series
data (referred to as <i>output vectors</i>) to a file. The <tt>record()</tt>
method is used to output a value (or a value pair) with a timestamp.
The object name will serve as the name of the output vector.

<p>The vector name can be passed in the constructor,

<pre>
<a href="../api/classcOutVector.html">cOutVector</a> responseTimeVec("response time");
</pre>
<p>
but in the usual arrangement you'd make the <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> a member
of the module class and set the name in <tt>initialize()</tt>. You'd
record values from <tt>handleMessage()</tt> or from a function called from
<tt>handleMessage()</tt>.

<p>The following example is a <tt>Sink</tt> module which records the lifetime
of every message that arrives to it.

<pre>
class Sink : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    <a href="../api/classcOutVector.html">cOutVector</a> endToEndDelayVec;

    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
};

Define_Module(Sink);

void Sink::initialize()
{
    endToEndDelayVec.setName("End-to-End Delay");
}

void Sink::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    simtime_t eed = simTime() - msg-&gt;creationTime();
    endToEndDelayVec.record(eed);
    delete msg;
}
</pre>
<p>
There is also a <tt>recordWithTimestamp()</tt> method<sup><b>[New!]</b></sup>, to make it
possible to record values into output vectors with a timestamp other than
<tt>simTime()</tt>. Increasing timestamp order is still enforced though.

<p>All <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects write to a single <i>output vector file</i>
named <tt>omnetpp.vec</tt> by default.
You can configure output vectors from <tt>omnetpp.ini</tt>:
you can disable writing to the file, or limit it to a certain
simulation time interval for recording (section
<a href="#sec302">[8.5]</a>).

<p>The format and processing of output vector files is described in section
<a href="#sec352">[10.1]</a>.

<p>If the output vector object is disabled or the simulation time is
outside the specified interval, <tt>record()</tt> doesn't write
anything to the output file. However, if you have a Tkenv inspector
window open for the output vector object<!--output!vector object-->,
the values will be displayed there, regardless of the state of the
output vector object.

<p>

<p><H3><A NAME="sec259"/>6.9.2 Output scalars</H3>

<p>While output vectors are to record time series data and thus they
typically record a large volume of data during a simulation run,
output scalars<!--output!scalars--> are supposed to record a single
value per simulation run. You can use output scalars

<p><ul>
<li>to record summary data at the end of the simulation run
<li>to do several runs with different parameter settings/random seed
    and determine the dependence of some measures on the parameter
    settings. For example, multiple runs and output scalars are the
    way to produce <i>Throughput vs. Offered Load</i> plots.
</ul>

<p>Output scalars are recorded with the <tt>recordScalar()</tt> method of
<tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>, and you'll usually want to insert this code
into the <tt>finish()</tt> function. An example:

<pre>
void Transmitter::finish()
{
    double avgThroughput = totalBits / simTime();
    recordScalar("Average throughput", avgThroughput);
}
</pre>
<p>
You can record whole statistics objects by calling their <tt>recordScalar()</tt>
methods, declared as part of <tt><a href="../api/classcStatistic.html">cStatistic</a></tt>. In the following example
we create a <tt>Sink</tt> module which calculates the mean, standard
deviation, minimum and maximum values of a variable, and records them at the
end of the simulation.

<pre>
class Sink : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    <a href="../api/classcStdDev.html">cStdDev</a> eedStats;

    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
    virtual void finish();
};

Define_Module(Sink);

void Sink::initialize()
{
    eedStats.setName("End-to-End Delay");
}

void Sink::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    simtime_t eed = simTime() - msg-&gt;creationTime();
    eedStats.collect(eed);
    delete msg;
}

void Sink::finish()
{
    recordScalar("Simulation duration", simTime());
    eedStats.recordScalar();
}
</pre>
<p>
The above calls write into the <i>output scalar file</i> which is named
<tt>omnetpp.sca</tt> by default. The output scalar file is preserved across
simulation runs (unlike the output vector file which gets deleted
at the beginning of every simulation run).
Data are always appended at the end of the file, and
output from different simulation runs are separated by special lines.
The format and processing of output vector files is described in section
<a href="#sec356">[10.2]</a>.

<p>
<H3><A NAME="sec260"/>6.9.3 Precision<sup><b>[New!]</b></sup></H3>
<a name="sec:outputfile-precision"></a>

<p>Output scalar and output vector files are text files, and floating point
values (<tt>double</tt>s) are recorded into it using <tt>fprintf()</tt>'s
<tt>"%g"</tt> format.
The number of significant digits can be configured using the
<tt>output-scalar-precision=</tt> and <tt>output-vector-precision=</tt>
configuration entries (see <a href="#sec296">[8.2.6]</a>).
The default precision is 12 digits. The following has to be considered
when changing the default value:

<p>IEEE-754 doubles are 64-bit numbers. The mantissa is 52 bits, which
is roughly equivalent to 16 decimal places (52*log(2)/log(10)).
However, due to rounding errors, usually only
12..14 digits are correct, and the rest is pretty much random garbage
which should be ignored. However, when you convert the decimal
representation back into an IEEE-754 double (as in Plove and Scalars),
an additional small error will occurs because 0.1, 0.01, etc cannot be
accurately represented in binary. This conversion error is usually
smaller than the one that the <tt>double</tt>
variable already had before recording into the file, however if
it is important you can eliminate it by setting &gt;16 digits precision
for the file (but again, be aware that the last digits are garbage).
The practical upper limit is 17 digits, setting it higher
doesn't make any difference in <tt>fprintf()</tt>'s output.



<p>Errors coming from converting to/from decimal representation can be
eliminated by choosing an output vector/output scalar manager class
which stores <tt>double</tt>s in their native binary form.
The appropriate configuration entries are <tt>outputvectormanager-class=</tt>
and <tt>outputvectormanager-class=</tt>; see <a href="#sec296">[8.2.6]</a>.
For example, <tt>cMySQLOutputScalarManager</tt> and <tt>cMySQLOutputScalarManager</tt>
provided in <tt>samples/database</tt> fulfill this requirement.

<p>However, before worrying too much about rounding and conversion errors,
it is worth considering what is the <i>real</i> accuracy of your results.
Some things to consider:

<p><ul>
  <li>in real life, it is very hard to measure quantities (weight, distance,
     even time) with more than a few digits of precision. What precision
     are your input data? For example, if you approximate inter-arrival
     time as <i>exponential(0.153)</i> when the mean is really
     <i>0.152601...</i> and the distribution is not even exactly exponential,
     you are already starting out with a bigger error than rounding can cause.

<p>  <li>the simulation model is itself an approximation of real life. How much
     error do the (known and unknown) simplifications cause in the results?
</ul>

<p>

<p>
<H2><A NAME="sec261"/>6.10 Watches and snapshots</H2>

<p><H3><A NAME="sec262"/>6.10.1 Basic watches</H3>

<p>It would be nice, but variables of type <tt>int</tt>, <tt>long</tt>, <tt>double</tt>
do not show up by default in Tkenv; neither do STL classes
(<tt>std::string</tt>, <tt>std::vector</tt>, etc.) or your own structs and
classes. This is because the simulation kernel, being a library, knows
nothing about types and variables in your source code.

<p>OMNeT++ provides <tt>WATCH()</tt> and set of other macros to come to your rescue,
and make variable to be inspectable in Tkenv and to be output into the snapshot
file<!--snapshot file-->. <tt>WATCH()</tt> macros are usually placed into
<tt>initialize()</tt> (to watch instance variables) or to the top of the
<tt>activity()</tt> function (to watch its local variables), the point being
that they should only be executed once.

<pre>
long packetsSent;
double idleTime;

WATCH(packetsSent);
WATCH(idleTime);
</pre>
<p>
Of course, members of classes and structs can also be watched:

<pre>
WATCH(config.maxRetries);
</pre>
<p>
When you open an inspector for the simple module in Tkenv and click
the Objects/Watches tab in it, you'll see your watched variables
and their values there. Tkenv also lets you change the value of a
watched variable.

<p>The <tt>WATCH()</tt> macro can be used with any type that has a
stream output operator (<tt>operator&lt;&lt;</tt>) defined<sup><b>[New!]</b></sup>. By default,
this includes all primitive types and <tt>std::string</tt>, but since
you can write <tt>operator&lt;&lt;</tt> for your classes/structs and basically
any type, <tt>WATCH()</tt> can be used with anything. The only limitation
is that since the output should more or less fit on single line, the
amount of information that can be conveniently displayed is limited.

<p>An example stream output operator:

<pre>
std::ostream& operator&lt;&lt;(std::ostream& os, const ClientInfo& cli)
{
    os &lt;&lt; "addr=" &lt;&lt; cli.clientAddr &lt;&lt; "  port=" &lt;&lt; cli.clientPort; // no endl!
    return os;
}
</pre>
<p>
And the <tt>WATCH()</tt> line:

<pre>
WATCH(currentClientInfo);
</pre>
<p>

<p><H3><A NAME="sec263"/>6.10.2 Read-write watches<sup><b>[New!]</b></sup></H3>

<p>Watches for primitive types and <tt>std::string</tt> allow for changing
the value from the GUI as well, but for other types you need to explicitly
add support for that. What you need to do is define a stream input
operator (<tt>operator&gt;&gt;</tt>) and use the <tt>WATCH_RW()</tt> macro instead of
<tt>WATCH()</tt>.

<p>The stream input operator:

<pre>
std::ostream& operator&gt;&gt;(std::istream& is, ClientInfo& cli)
{
    // read a line from "is" and parse its contents into "cli"
    return is;
}
</pre>
<p>
And the <tt>WATCH_RW()</tt> line:

<pre>
WATCH_RW(currentClientInfo);
</pre>
<p>

<p><H3><A NAME="sec264"/>6.10.3 Structured watches<sup><b>[New!]</b></sup></H3>

<p><tt>WATCH()</tt> and <tt>WATCH_RW()</tt> are basic watches: they allow one
line of (unstructured) text to be displayed. However, if you have a
data structure generated from message definitions (see Chapter <a href="#sec206">[5]</a>),
then one can do better. The message compiler automatically generates
meta-information describing individual fields of the class or struct,
which makes it possible to display the contents on field level.

<p>The <tt>WATCH</tt> macros to be used for this purpose are <tt>WATCH_OBJ()</tt>
and <tt>WATCH_PTR()</tt>. Both expect the object to be subclassed from
<tt><a href="../api/classcPolymorphic.html">cPolymorphic</a></tt>; <tt>WATCH_OBJ()</tt> expects a reference to such class,
and <tt>WATCH_PTR()</tt> expects a pointer variable.

<pre>
ExtensionHeader hdr;
ExtensionHeader *hdrPtr;
...
WATCH_OBJ(hdr);
WATCH_PTR(hdrPtr);
</pre>
<p>
CAUTION: With <tt>WATCH_PTR()</tt>, the pointer variable must point to a valid
object or be <tt>NULL</tt> at all times, otherwise the GUI may crash
while trying to display the object. This practically means that
the pointer should be initialized to <tt>NULL</tt> even if not used, and
should be set to <tt>NULL</tt> when the object to which it points gets deleted.

<pre>
delete watchedPtr;
watchedPtr = NULL;  // set to NULL when object gets deleted
</pre>
<p>

<p><H3><A NAME="sec265"/>6.10.4 STL watches<sup><b>[New!]</b></sup></H3>

<p>The standard C++ container classes (<tt>vector</tt>, <tt>map</tt>, <tt>set</tt>, etc)
also have structured watches, available via the following macros:

<p><tt>WATCH_VECTOR()</tt>, <tt>WATCH_PTRVECTOR()</tt>,
<tt>WATCH_LIST()</tt>, <tt>WATCH_PTRLIST()</tt>,
<tt>WATCH_SET()</tt>, <tt>WATCH_PTRSET()</tt>,
<tt>WATCH_MAP()</tt>, <tt>WATCH_PTRMAP()</tt>.

<p>The <tt>PTR</tt>-less versions expect the data items ("T") to have
stream output operators (<tt>operator &lt;&lt;</tt>), because that's how
they will display them. The <tt>PTR</tt> versions assume that
data items are pointers to some type which has <tt>operator &lt;&lt;</tt>.
<tt>WATCH_PTRMAP()</tt> assumes that only the value type (``second'')
is a pointer, the key type (``first'') is not. (If you happen to use
pointers as key, then define <tt>operator &lt;&lt;</tt> for the pointer type
itself.)

<p>Examples:

<pre>
std::vector&lt;int&gt; intvec;
WATCH_VECTOR(intvec);

std::map&lt;std::string,Command*&gt; commandMap;
WATCH_PTRMAP(commandMap);
</pre>
<p>

<p>
<H3><A NAME="sec266"/>6.10.5 Snapshots</H3>
<a name="sec:ch-sim-lib:snapshots"></a>

<p>The <tt>snapshot()</tt> function outputs textual information about all
or selected objects of the simulation (including the objects created
in module functions by the user) into the snapshot file<!--snapshot file-->.

<pre>
bool snapshot(<a href="../api/classcObject.html">cObject</a> *obj = &simulation, const char *label = NULL);
</pre>
<p>

<p>The function can be called from module functions, like this:

<pre>
snapshot();     // dump the whole network
snapshot(this); // dump this simple module and all its objects
snapshot(&simulation.msgQueue); // dump future events
</pre>
<p>
This will append snapshot information to the end of the snapshot file.
(The snapshot file name has an extension of <tt>.sna</tt>, default is
<tt>omnetpp.sna</tt><!--omnetpp.sna-->. Actual file name can be set in the
config file.)

<p>
The snapshot file output is detailed enough to be used for debugging
the simulation: by regularly calling <tt>snapshot()</tt>, one can trace
how the values of variables, objects changed over the simulation.
The arguments: label is a string that will appear in the output
file; obj is the object whose inside is of interest. By default,
the whole simulation (all modules etc) will be written out.

<p>If you run the simulation with Tkenv, you can also create a snapshot
from the menu.

<p>
An example of a snapshot file:

<p><pre>
[...]

(<a href="../api/classcSimulation.html">cSimulation</a>) `simulation' begin
  Modules in the network:
    `token' #1 (TokenRing)
      `comp[0]' #2 (Computer)
        `mac' #3 (TokenRingMAC)
        `gen' #4 (Generator)
        `sink' #5 (Sink)
      `comp[1]' #6 (Computer)
        `mac' #7 (TokenRingMAC)
        `gen' #8 (Generator)
        `sink' #9 (Sink)
      `comp[2]' #10 (Computer)
        `mac' #11 (TokenRingMAC)
        `gen' #12 (Generator)
        `sink' #13 (Sink)
end

(TokenRing) `token' begin
  #1 params     (<a href="../api/classcArray.html">cArray</a>) (n=6)
  #1 gates      (<a href="../api/classcArray.html">cArray</a>) (empty)
  comp[0]          (<a href="../api/classcCompoundModule.html">cCompoundModule</a>,#2)
  comp[1]          (<a href="../api/classcCompoundModule.html">cCompoundModule</a>,#6)
  comp[2]          (<a href="../api/classcCompoundModule.html">cCompoundModule</a>,#10)
end

(<a href="../api/classcArray.html">cArray</a>) `token.parameters' begin
  num_stations (<a href="../api/classcModulePar.html">cModulePar</a>) 3 (L)
  num_messages (<a href="../api/classcModulePar.html">cModulePar</a>) 10000 (L)
  ia_time      (<a href="../api/classcModulePar.html">cModulePar</a>) truncnormal(0.005,0.003) (F)
  THT          (<a href="../api/classcModulePar.html">cModulePar</a>) 0.01 (D)
  data_rate    (<a href="../api/classcModulePar.html">cModulePar</a>) 4000000 (L)
  cable_delay  (<a href="../api/classcModulePar.html">cModulePar</a>) 1e-06 (D)
end

[...]

(<a href="../api/classcQueue.html">cQueue</a>) `token.comp[0].mac.local-objects.send-queue' begin
  0--&gt;1         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0158105774 ( 15ms) Src=#4 Dest=#3
  0--&gt;2         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0163553310 ( 16ms) Src=#4 Dest=#3
  0--&gt;1         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0205628236 ( 20ms) Src=#4 Dest=#3
  0--&gt;2         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0242203591 ( 24ms) Src=#4 Dest=#3
  0--&gt;2         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0300994268 ( 30ms) Src=#4 Dest=#3
  0--&gt;1         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0364005251 ( 36ms) Src=#4 Dest=#3
  0--&gt;1         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0370745702 ( 37ms) Src=#4 Dest=#3
  0--&gt;2         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0387984129 ( 38ms) Src=#4 Dest=#3
  0--&gt;1         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0457462493 ( 45ms) Src=#4 Dest=#3
  0--&gt;2         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0487308918 ( 48ms) Src=#4 Dest=#3
  0--&gt;2         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0514466766 ( 51ms) Src=#4 Dest=#3
end

(<a href="../api/classcMessage.html">cMessage</a>) `token.comp[0].mac.local-objects.send-queue.0--&gt;1' begin
  #4 --&gt; #3
  sent:         0.0158105774 ( 15ms)
  arrived:      0.0158105774 ( 15ms)
  length:       33536
  kind:         0
  priority:     0
  error:        FALSE
  time stamp:   0.0000000 ( 0.00s)
  parameter list:
    dest        (<a href="../api/classcPar.html">cPar</a>) 1 (L)
    source      (<a href="../api/classcPar.html">cPar</a>) 0 (L)
    gentime     (<a href="../api/classcPar.html">cPar</a>) 0.0158106 (D)
end

[...]
</pre>

<p>It is possible that the format of the snapshot file will change to XML
in future OMNeT++ releases.

<p>

<p><H3><A NAME="sec267"/>6.10.6 Breakpoints</H3>

<p><b>With activity() only!</b> In those user interfaces which support
debugging, breakpoints stop execution and the state of the simulation
can be examined.

<p>You can set a breakpoint<!--breakpoint--> inserting a
<tt>breakpoint()</tt> call into the source:

<pre>
for(;;)
{
    <a href="../api/classcMessage.html">cMessage</a> *msg = receive();
    breakpoint("before-processing");
    breakpoint("before-send");
    send( reply_msg, "out" );
    //..
}
</pre>
<p>

<p>In user interfaces that do not support debugging, <tt>breakpoint()</tt>
calls are simply ignored.

<p>

<p>



<p>

<p>
<H3><A NAME="sec268"/>6.10.7 Getting coroutine stack usage</H3>

<p>It is important to choose the correct stack size for
modules<!--module!stack size--><!--stack!size-->.  If the stack is
too large, it unnecessarily consumes memory; if it is too small, stack
violation occurs.

<p>From the Feb99 release, OMNeT++ contains a mechanism that detects stack
overflows<!--stack!overflow-->. It checks the intactness of a
predefined byte pattern (<tt>0xdeadbeef</tt>) at the stack boundary,
and reports ``stack violation''<!--stack!violation--> if it was
overwritten. The mechanism usually works fine, but occasionally it can
be fooled by large -- and not fully used -- local variables (e.g. char
buffer[256]): if the byte pattern happens to fall in the middle of
such a local variable, it may be preserved intact and OMNeT++ does not
detect the stack violation.

<p>To be able to make a good guess about stack size, you can use
the <tt>stackUsage()</tt> call which tells you how much stack the module
actually uses. It is most conveniently called from <tt>finish()</tt>:

<pre>
void FooModule::finish()
{
  ev &lt;&lt; stackUsage() &lt;&lt;  "bytes of stack used\n";
}
</pre>
<p>

<p>The value includes the extra stack added by the user interface library
(see <i>extraStackforEnvir</i><!--extraStackforEnvir--> in
envir/omnetapp.h), which is currently 8K for Cmdenv and at least 16K
for Tkenv.
  <br><ul><font size=-1>[The actual value is platform-dependent.]</font></ul>

<p><tt>stackUsage()</tt>also works by checking the existence of predefined
byte patterns in the stack area, so it is also subject to the above
effect with local variables.

<p>

<p><H2><A NAME="sec269"/>6.11 Deriving new classes</H2>
<a name="sec:ch-sim-lib:deriving-new-classes"></a>

<p><H3><A NAME="sec270"/>6.11.1 <a href="../api/classcObject.html">cObject</a> or not?</H3>

<p>If you plan to implement a completely new class (as opposed to
subclassing something already present in OMNeT++), you have
to ask yourself whether you want the new class to be based
on <tt><a href="../api/classcObject.html">cObject</a></tt> or not.
Note that we are <i>not</i> saying you should always
subclass from <tt><a href="../api/classcObject.html">cObject</a></tt>.
Both solutions have advantages and disadvantages, which you
have to consider individually for each class.

<p><tt><a href="../api/classcObject.html">cObject</a></tt> already carries (or provides a framework for)
significant functionality that is either relevant to
your particular purpose or not. Subclassing <tt><a href="../api/classcObject.html">cObject</a></tt>
generally means you have more code to write (as you <i>have to</i>
redefine certain virtual functions and adhere to conventions)
and your class will be a bit more heavy-weight.
However, if you need to store your objects in OMNeT++ objects like <tt><a href="../api/classcQueue.html">cQueue</a></tt>,
or you'll want to store OMNeT++ classes in your object,
then you <i>must</i> subclass from <tt><a href="../api/classcObject.html">cObject</a></tt>.
  <br><ul><font size=-1>[For simplicity, in the these sections ``OMNeT++ object''
  should be understood as ``object of a class subclassed from
  <tt><a href="../api/classcObject.html">cObject</a></tt>'']</font></ul>

<p>The most significant features <tt><a href="../api/classcObject.html">cObject</a></tt> has is
the name string (which has to be stored somewhere, so it has
its overhead) and ownership management (see section
<a href="#sec274">[6.12]</a>) which
also has the advantages but also some costs.

<p>As a general rule, small <tt>struct</tt>-like classes like <tt>IPAddress</tt>,
<tt>MACAddress</tt>, <tt>RoutingTableEntry</tt>, <tt>TCPConnectionDescriptor</tt>, etc.
are better <i>not</i> sublassed from <tt><a href="../api/classcObject.html">cObject</a></tt>.
If your class has at least one virtual member function, consider
subclassing from <tt><a href="../api/classcPolymorphic.html">cPolymorphic</a></tt>, which does not impose any
extra cost because it doesn't have data members at all, only
virtual functions.

<p>
<H3><A NAME="sec271"/>6.11.2 <a href="../api/classcObject.html">cObject</a> virtual methods</H3>

<p>Most classes in the simulation class library are descendants of
<tt><a href="../api/classcObject.html">cObject</a></tt>. If you want to derive a new class from
<tt><a href="../api/classcObject.html">cObject</a></tt> or a <tt><a href="../api/classcObject.html">cObject</a></tt> descendant, you must redefine
some member functions so that objects of the new type can fully
co-operate with other parts of the simulation system. A more or less
complete list of these functions is presented here. You do not need to
worry about the length of the list: most functions are not
absolutely necessary to implement. For example, you do not need to
redefine <tt>forEachChild()</tt> unless your class is a container class.

<p>The following methods <b>must</b> be implemented:

<p><ul>
  <li><i>Constructor</i>. At least two constructors should be provided:
        one that takes the object name string as <tt>const char *</tt>
        (recommended by convention), and another one with no arguments
        (must be present). The two are usually implemented as a single
        method, with <tt>NULL</tt> as default name string.
  <li><i>Copy constructor</i>, which must have the following signature
        for a class <tt>X</tt>: <tt>X(const X&amp;)</tt>. The copy constructor is used
        whenever an object is duplicated. The usual implementation of
        the copy constructor is to initialize the base class with the
        name (<tt>name()</tt>) of the other object it receives, then call the
        assignment operator (see below).
  <li><i>Destructor</i>.
  <li><i>Duplication function,</i> <tt><a href="../api/classcPolymorphic.html">cPolymorphic</a> *dup() const</tt>.
        It should create and return an exact duplicate of the object.
        It is usually a one-line function, implemented with the help
        of the <tt>new</tt> operator and the copy constructor.
  <li><i>Assigment operator</i>, that is, <tt>X&amp; operator=(const X&amp;)</tt>
        for a class <tt>X</tt>. It should copy the contents of the other
        object into this one, except the name string. See later what to do
        if the object contains pointers to other objects.
</ul>

<p>If your class contains other objects subclassed from <tt><a href="../api/classcObject.html">cObject</a></tt>,
either via pointers or as data member, the following function <b>should</b>
be implemented:

<p><ul>
  <li><i>Iteration function,</i> <tt>void forEachChild(<a href="../api/classcVisitor.html">cVisitor</a> * v)</tt>.
        The implementation should call the function passed
        for each object it contains via pointer or as data member;
        see the API Reference on <tt><a href="../api/classcObject.html">cObject</a></tt> on how to implement
        <tt>forEachChild()</tt>. <tt>forEachChild()</tt> makes it possible
        for Tkenv to display the object tree to you, to perform searches on it, etc.
        It is also used by <tt>snapshot()</tt> and some other library functions.
</ul>

<p>The following methods are <b>recommended</b> to implement:

<p><ul>
  <li><i>Object info,</i> <tt>std::string info()</tt>. The <tt>info()</tt> function
        should return a one-line string describing the object's contents or state.
        <tt>info()</tt> is displayed at several places in Tkenv.
  <li><i>Detailed object info,</i> <tt>std::string detailedInfo()</tt>.
        This method may potentially be implemented in addition to <tt>info()</tt>;
        it can return a multi-line description. <tt>detailedInfo()</tt> is also
        displayed by Tkenv in the object's inspector.
  <li><i>Serialization</i>, <tt>netPack()</tt> and <tt>netUnpack()</tt> methods.
        These methods are needed for parallel simulation, if you want
        objects of this type to be transmitted across partitions.
</ul>

<p>
<H3><A NAME="sec272"/>6.11.3 Class registration</H3>

<p>You should also use the <tt>Register_Class()</tt> macro to register the
new class. It is used by the <tt>createOne()</tt> factory function, which can
create any object given the class name as a string. <tt>createOne()</tt>
is used by the Envir library to implement <tt>omnetpp.ini</tt> options
such as <tt>rng-class="..."</tt> or <tt>scheduler-class="..."</tt>.
(see Chapter <a href="#sec387">[13]</a>)

<p>For example, an omnetpp.ini entry such as

<pre>
rng-class="cMersenneTwister"
</pre>
<p>
would result in something like the following code to be executed
for creating the RNG objects:

<pre>
<a href="../api/classcRNG.html">cRNG</a> *rng = check_and_cast&lt;<a href="../api/classcRNG.html">cRNG</a>*&gt;(createOne("cMersenneTwister"));
</pre>
<p>
But for that to work, we needed to have the following line somewhere in the code:

<pre>
Register_Class(cMersenneTwister);
</pre>
<p>
<tt>createOne()</tt> is also needed by the parallel distributed simulation feature
(Chapter <a href="#sec378">[12]</a>) to create blank objects to unmarshal into
on the receiving side.

<p>
<H3><A NAME="sec273"/>6.11.4 Details</H3>

<p>We'll go through the details using an example. We create a new
class <tt>NewClass</tt>, redefine all above mentioned <tt><a href="../api/classcObject.html">cObject</a></tt>
member functions, and explain the conventions, rules and tips
associated with them.
To demonstrate as much as possible, the class will contain
an <tt>int</tt> data member, dynamically allocated non-<tt><a href="../api/classcObject.html">cObject</a></tt> data
(an array of <tt>double</tt>s),
an OMNeT++ object as data member (a <tt><a href="../api/classcQueue.html">cQueue</a></tt>), and
a dynamically allocated OMNeT++ object (a <tt><a href="../api/classcMessage.html">cMessage</a></tt>).

<p>The class declaration is the following. It contains the declarations
of all methods discussed in the previous section.

<pre>
//
// file: NewClass.h
//
#include &lt;omnetpp.h&gt;

class NewClass : public <a href="../api/classcObject.html">cObject</a>
{
  protected:
    int data;
    double *array;
    <a href="../api/classcQueue.html">cQueue</a> queue;
    <a href="../api/classcMessage.html">cMessage</a> *msg;
    ...
  public:
    NewClass(const char *name=NULL, int d=0);
    NewClass(const NewClass& other);
    virtual ~NewClass();
    virtual <a href="../api/classcPolymorphic.html">cPolymorphic</a> *dup() const;
    NewClass& operator=(const NewClass& other);

    virtual void forEachChild(<a href="../api/classcVisitor.html">cVisitor</a> *v);
    virtual std::string info();
};
</pre>
<p>
We'll discuss the implementation method by method.
Here's the top of the <tt>.cc</tt> file:

<pre>
//
// file: NewClass.cc
//
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream.h&gt;
#include "newclass.h"

Register_Class( NewClass );


NewClass::NewClass(const char *name, int d) : <a href="../api/classcObject.html">cObject</a>(name)
{
    data = d;
    array = new double[10];
    take(&queue);
    msg = NULL;
}
</pre>
<p>
The constructor (above) calls the base class constructor with
the name of the object, then initializes its own data members.
You need to call <tt>take()</tt> for <tt><a href="../api/classcObject.html">cObject</a></tt>-based data members.

<p>
<pre>
NewClass::NewClass(const NewClass& other) : <a href="../api/classcObject.html">cObject</a>(other.name())
{
    array = new double[10];
    msg = NULL;
    take(&queue);
    operator=(other);
}
</pre>

<p>The copy constructor relies on the assignment operator. Because
by convention the assignment operator does not copy the
name member, it is passed here to the base class constructor.
(Alternatively, we could have written <tt>setName(other.name())</tt>
into the function body.)

<p>Note that pointer members have to be initialized (to <tt>NULL</tt> or to an
allocated object/memory) before calling the assignment operator,
to avoid crashes.

<p>You need to call <tt>take()</tt> for <tt><a href="../api/classcObject.html">cObject</a></tt>-based data members.

<pre>
NewClass::~NewClass()
{
    delete [] array;
    if (msg-&gt;owner()==this)
        delete msg;
}
</pre>
<p>
The destructor should delete all data structures the object allocated.
<tt><a href="../api/classcObject.html">cObject</a></tt>-based objects should <i>only</i> be deleted if they
are owned by the object -- details will be covered in section
<a href="#sec274">[6.12]</a>.

<pre>
<a href="../api/classcPolymorphic.html">cPolymorphic</a> *NewClass::dup() const
{
    return new NewClass(*this);
}
</pre>
<p>
The <tt>dup()</tt> functions is usually just one line, like the one above.

<pre>
NewClass& NewClass::operator=(const NewClass& other)
{
    if (&other==this)
        return *this;
    <a href="../api/classcObject.html">cObject</a>::operator=(other);

    data = other.data;

    for (int i=0; i&lt;10; i++)
        array[i] = other.array[i];

    queue = other.queue;
    queue.setName(other.queue.name());

    if (msg && msg-&gt;owner()==this)
        delete msg;
    if (other.msg && other.msg-&gt;owner()==const_cast&lt;<a href="../api/classcMessage.html">cMessage</a>*&gt;(&other))
        take(msg = (<a href="../api/classcMessage.html">cMessage</a> *)other.msg-&gt;dup());
    else
        msg = other.msg;
    return *this;
}
</pre>
<p>
Complexity associated with copying and duplicating the object
is concentrated in the assignment operator, so it is usually
the one that requires the most work from you of all methods
required by <tt><a href="../api/classcObject.html">cObject</a></tt>.

<p>If you do not want to implement object copying and duplication,
you should implement the assigment operator to call
<tt>copyNotSupported()</tt> -- it'll throw an exception that
stops the simulation with an error message if this function
is called.

<p>The assignment operator copies contents of the <tt>other</tt> object
to this one, except the name string. It should always return
<tt>*this</tt>.

<p>First, we should make sure we're not trying to copy the object
to itself, because it might be disastrous. If so (that is,
<tt>&amp;other==this</tt>), we return immediately without doing anything.

<p>The base class part is copied via invoking the assignment operator of
the base class.

<p>New data members are copied in the normal C++ way. If the class
contains pointers, you'll most probably want to make a deep copy of
the data where they point, and not just copy the pointer values.

<p>If the class contains pointers to OMNeT++ objects, you need
to take ownership into account. If the contained object is <i>not owned</i>
then we assume it is a pointer to an ``external'' object, consequently
we only copy the pointer. If it is <i>owned</i>, we duplicate
it and become the owner of the new object. Details of ownership
management will be covered in section <a href="#sec274">[6.12]</a>.

<p>
<pre>
void NewClass::forEachChild(<a href="../api/classcVisitor.html">cVisitor</a> *v)
{
    v-&gt;visit(queue);
    if (msg)
        v-&gt;visit(msg);
}
</pre>

<p>The <tt>forEachChild()</tt> function should call <tt>v-&gt;visit(obj)</tt>
for each <tt>obj</tt> member of the class. See the API Reference for more
information of <tt>forEachChild()</tt>.

<pre>
std::string NewClass::info()
{
    std::stringstream out;
    out &lt;&lt; "data=" &lt;&lt; data &lt;&lt; ", array[0]=" &lt;&lt; array[0];
    return out.str();

}
</pre>
<p>
The <tt>info()</tt> method should produce a concise, one-line string
about the object. You should try not to exceed 40-80 characters, since the
string will be shown in tooltips and listboxes.

<p>See the virtual functions of <tt><a href="../api/classcPolymorphic.html">cPolymorphic</a></tt> and <tt><a href="../api/classcObject.html">cObject</a></tt>
in the class library reference for more information. The sources of the
Sim library (<tt>include/</tt>, <tt>src/sim/</tt>) can serve as further examples.

<p>

<p><H2><A NAME="sec274"/>6.12 Object ownership management</H2>
<a name="sec:ch-sim-lib:ownership-management"></a>

<p><H3><A NAME="sec275"/>6.12.1 The ownership tree</H3>

<p>OMNeT++ has a built-in ownership management mechanism which
is used for sanity checks, and as part of the infrastructure
supporting Tkenv inspectors.

<p>Container classes like <tt><a href="../api/classcQueue.html">cQueue</a></tt> own the objects inserted
into them. But this is not limited to objects inserted into a container:
<i>every <tt><a href="../api/classcObject.html">cObject</a></tt>-based object has an owner all the time</i>.
From the user's point of view, ownership is managed transparently.
For example, when you create a new <tt><a href="../api/classcMessage.html">cMessage</a></tt>,
it will be owned by the simple module. When you send it, it will
first be handed over to (i.e. change owership to) the FES<!--FES-->, and,
upon arrival, to the destination simple module. When you encapsulate
the message in another one, the encapsulating message will become
the owner. When you decapsulate it again, the currently active
simple module becomes the owner.

<p>The <tt>owner()</tt> method, defined in <tt><a href="../api/classcObject.html">cObject</a></tt>, returns the
owner of the object:

<pre>
<a href="../api/classcObject.html">cObject</a> *o = msg-&gt;owner();
ev &lt;&lt; "Owner of " &lt;&lt; msg-&gt;name() &lt;&lt; " is: " &lt;&lt;
   &lt;&lt; "(" &lt;&lt; o-&gt;className() &lt;&lt; ") " &lt;&lt; o-&gt;fullPath() &lt;&lt; endl;
</pre>
<p>
The other direction, enumerating the objects owned can be implemented with
the <tt>forEachChild()</tt> method by it looping through all
contained objects and checking the owner of each object.

<p><p class="subheading">Why do we need this?</p>

<p>The traditional concept of object ownership is associated with
the ``right to delete'' objects. In addition to that,
keeping track of the owner and the list of objects owned also
serves other purposes in OMNeT++:

<p><ul>
    <li>enables methods like <tt>fullPath()</tt> to be implemented.

<p>    <li>prevents certain types of programming errors, namely,
    those associated with wrong ownership handling.

<p>    <li>enables Tkenv to display the list of simulation objects
    present within a simple module. This is extremely useful for finding
    memory leaks caused by forgetting to delete messages that are
    no longer needed.
</ul>

<p>Some examples of programming errors that can be caught
by the ownership facility:

<p><ul>
    <li>attempts to send a message while it is still in a queue,
    encapsulated in another message, etc.

<p>    <li>attempts to send/schedule a message while it is still owned
    by the simulation kernel (i.e. scheduled as a future event)

<p>    <li>attempts to send the very same message object to multiple
    destinations at the same time (ie. to all connected modules)
</ul>

<p>For example, the <tt>send()</tt> and <tt>scheduleAt()</tt> functions check
that the message being sent/scheduled <i>must</i> is owned by the module.
If it is not, then it signals a programming error: the message is probably
owned by another module (already sent earlier?), or currently scheduled, or
inside a queue, a message or some other object -- in either case, the
module does not have any authority over it. When you get the error message
(<tt>"not owner of object"</tt>), you need to carefully examine the error
message: which object has the ownership of the message, why's that, and
then probably you'll need to fix the logic somewhere in your program.

<p>The above errors are easy to make in the code, and if not detected
automatically, they could cause random crashes which are usually very
difficult to track down. Of course, some errors of the same kind still
cannot be detected automatically, like calling member functions of a
message object which has been sent to (and so currently kept by) another
module.

<p>
<H3><A NAME="sec276"/>6.12.2 Managing ownership</H3>

<p>Ownership is managed transparently for the user, but this mechanism
has to be supported by the participating classes themselves.
It will be useful to look inside <tt><a href="../api/classcQueue.html">cQueue</a></tt> and <tt><a href="../api/classcArray.html">cArray</a></tt>,
because they might give you a hint what behavior you need
to implement when you want to use non-OMNeT++ container classes
to store messages or other <tt><a href="../api/classcObject.html">cObject</a></tt>-based objects.

<p>
<p class="subheading">Insertion</p>

<p><tt><a href="../api/classcArray.html">cArray</a></tt> and <tt><a href="../api/classcQueue.html">cQueue</a></tt> have internal data structures
(array and linked list) to store the objects which are inserted
into them. However, they do <i>not</i> necessarily own all of these
objects.  (Whether they own an object or not can be determined
from that object's <tt>owner()</tt> pointer.)

<p>The default behaviour of <tt><a href="../api/classcQueue.html">cQueue</a></tt> and <tt><a href="../api/classcArray.html">cArray</a></tt> is
to take ownership of the objects inserted.
This behavior can be changed via the <i>takeOwnership</i> flag.

<p>Here's what the <i>insert</i> operation of <tt><a href="../api/classcQueue.html">cQueue</a></tt> (or <tt><a href="../api/classcArray.html">cArray</a></tt>) does:
<ul>
    <li>insert the object into the internal array/list data structure

<p>    <li>if the <i>takeOwnership</i> flag is true, take ownership
    of the object, otherwise just leave it with its original owner
</ul>

<p>The corresponding source code:

<pre>
void <a href="../api/classcQueue.html">cQueue</a>::insert(<a href="../api/classcObject.html">cObject</a> *obj)
{
    // insert into queue data structure
    ...

    // take ownership if needed
    if (takeOwnership())
        take(obj);

}
</pre>
<p>

<p><p class="subheading">Removal</p>

<p>Here's what the <i>remove</i> family of operations in <tt><a href="../api/classcQueue.html">cQueue</a></tt>
(or <tt><a href="../api/classcArray.html">cArray</a></tt>) does:

<p><ul>
    <li>remove the object from the internal array/list data structure

<p>    <li>if the object is actually owned by this <tt><a href="../api/classcQueue.html">cQueue</a></tt>/<tt><a href="../api/classcArray.html">cArray</a></tt>,
    release ownership of the object, otherwise just leave it with
    its current owner
</ul>

<p>After the object was removed from a <tt><a href="../api/classcQueue.html">cQueue</a></tt>/<tt><a href="../api/classcArray.html">cArray</a></tt>,
you may further use it, or if it is not needed any more, you can delete it.

<p>The <i>release ownership</i> phrase requires further explanation.
When you remove an object from a queue or array, the ownership
is expected to be transferred to the simple module's local objects list.
This is acomplished by the <tt>drop()</tt> function, which transfers the
ownership to the object's default owner.
<tt>defaultOwner()</tt> is a virtual method returning <tt><a href="../api/classcObject.html">cObject</a>*</tt>
defined in <tt><a href="../api/classcObject.html">cObject</a></tt>, and its implementation returns
the currently executing simple module's local object list.

<p>As an example, the <tt>remove()</tt> method of <tt><a href="../api/classcQueue.html">cQueue</a></tt> is
implemented like this:
  <br><ul><font size=-1>[Actual code in <tt>src/sim</tt> is structured somewhat
  differently, but the meaning is the same.]</font></ul>

<pre>
<a href="../api/classcObject.html">cObject</a> *<a href="../api/classcQueue.html">cQueue</a>::remove(<a href="../api/classcObject.html">cObject</a> *obj)
{
    // remove object from queue data structure
    ...

    // release ownership if needed
    if (obj-&gt;owner()==this)
        drop(obj);

    return obj;
}
</pre>
<p>

<p><p class="subheading">Destructor</p>

<p>The concept of <tt>ownership</tt> is that <i>the owner has the
exclusive right and duty to delete the objects it owns</i>.
For example, if you delete a <tt><a href="../api/classcQueue.html">cQueue</a></tt> containing <tt><a href="../api/classcMessage.html">cMessage</a></tt>s,
all messages it contains <i>and</i> owns will also be deleted.

<p>The destructor should delete all data structures the object allocated.
From the contained objects, only the owned ones are deleted -- that is,
where <tt>obj-&gt;owner()==this</tt>.

<p>
<p class="subheading">Object copying</p>

<p>The ownership mechanism also has to be taken into consideration
when a <tt><a href="../api/classcArray.html">cArray</a></tt> or <tt><a href="../api/classcQueue.html">cQueue</a></tt> object is duplicated.
The duplicate is supposed to have the same content as the
original, however the question is whether the contained objects
should also be duplicated or only their pointers taken over
to the duplicate <tt><a href="../api/classcArray.html">cArray</a></tt> or <tt><a href="../api/classcQueue.html">cQueue</a></tt>.

<p>The convention followed by <tt><a href="../api/classcArray.html">cArray</a></tt>/<tt><a href="../api/classcQueue.html">cQueue</a></tt> is that
only owned objects are copied, and the contained but not owned ones
will have their pointers taken over and their original owners
left unchanged.

<p>In fact, the same question arises in three places:
the assignment operator <tt>operator=()</tt>, the copy constructor
and the <tt>dup()</tt> method.
In OMNeT++, the convention is that copying is implemented
in the assignment operator, and the other two just rely on it.
(The copy constructor just constructs an empty object and
invokes assigment, while <tt>dup()</tt>
is implemented as <tt>new <a href="../api/classcArray.html">cArray</a>(*this)</tt>).



</BODY>
</HTML>
<hr><hr><H1><A NAME="sec277"/>7 Building Simulation Programs</H1>
<a name="cha:building-simulation-programs"></a>

<p>

<p>
<H2><A NAME="sec278"/>7.1 Overview</H2>

<p>As it was already mentioned, an OMNeT++ model physically consists of
the following parts:
<ul>
  <li>NED language<!--ned!files--> topology description(s). These
      are files with the <tt>.ned</tt> suffix.
  <li>Message definitions<!--message definitions-->, in files
      with <tt>.msg</tt> suffix.
  <li>Simple modules implementations and other C++ code, in <tt>.cc</tt>
        files (or <tt>.cpp</tt>, on Windows)
</ul>

<p>
To build an executable simulation program,
you first need to translate the NED files<!--ned!files-->
and the message files into C++, using the NED compiler<!--ned!compiler-->
(<tt>nedtool</tt>) and the message compiler (<tt>opp_msgc</tt>).
After this step, the process is the same as building any C/C++
program from source: all C++ sources need to be compiled into object files
(<tt>.o</tt> files on Unix/Linux, and <tt>.obj</tt> on Windows),
and all object files need to be linked with the necessary libraries to get
an executable.


File names for libraries differ for Unix/Linux and for Windows,
and also different for static and shared libraries.
Let us suppose you have a library called Tkenv.
On a Unix/Linux system, the file name for the static library
would be something like <tt>libtkenv.a</tt> (or <tt>libtkenv.a.</tt><i>&lt;version&gt;</i>),
and the shared library would be called <tt>libtkenv.so</tt>
(or <tt>libtkenv.so.</tt><i>&lt;version&gt;</i>).
The Windows version of the static library would be <tt>tkenv.lib</tt>,
and the DLL (which is the Windows equivalent of shared libraries)
would be a file named <tt>tkenv.dll</tt>.

<p>You'll need to link with the following libraries:

<p><ul>
  <li>The simulation kernel and class library<!--simulation!kernel-->,
    called <i>sim_std</i> (file <tt>libsim_std.a</tt>, <tt>sim_std.lib</tt>, etc).
  <li>User interfaces. The common part of all user interfaces is
    the <i>envir</i> library (file <tt>libenvir.a</tt>, etc),
    and the specific user interfaces are <i>tkenv</i> and <i>cmdenv</i>
    (<tt>libtkenv.a</tt>, <tt>libcmdenv.a</tt>, etc). You have to link
    with <i>envir</i>, plus either <i>tkenv</i> or <i>cmdenv</i>.
</ul>

<p>Luckily, you do not have to worry about the above details, because
automatic tools like <tt>opp_makemake</tt> will take care of the hard
part for you.

<p>The following figure gives an overview of the process of building
and running simulation programs.

<p>
  <div align=center>
    <img src="usmanFig17.gif">
    <center><i>Figure: Building and running simulation</i></center>
  </div>

<p>

<p>This section discusses how to use the simulation system on the
following platforms:
<ul>
  <li>Unix with gcc (also Windows with Cygwin or MinGW)
  <li>MSVC 6.0 on Windows
</ul>

<p>

<p>
<H2><A NAME="sec279"/>7.2 Using Unix and gcc</H2>

<p>This section applies to using OMNeT++ on Linux, Solaris, FreeBSD and
other Unix derivatives, and also more or less to Cygwin and MinGW
on Windows.

<p>Here in the manual we can give you a rough overview only.
The <tt>doc/</tt> directory of your OMNeT++ installation contains
<tt>Readme.</tt><i>&lt;platform&gt;</i> files that provide
up-to-date, more detailed and more precise instructions.

<p>
<H3><A NAME="sec280"/>7.2.1 Installation</H3>

<p>The installation process depends on what distribution you take
(source, precompiled RPM, etc.) and it may change from release
to release, so it is better to refer to the readme files.
If you compile from source, you can expect the usual GNU
procedure: <tt>./configure</tt> followed by <tt>make</tt>.

<p>
<H3><A NAME="sec281"/>7.2.2 Building simulation models</H3>

<p>The <tt>opp_makemake</tt> script can automatically generate the
<tt>Makefile</tt> for your simulation program, based on the source files
in the current directory. (It can also handle large models
which are spread across several directories; this is covered later in
this section.)

<p><tt>opp_makemake</tt> has several options, with the <tt>-h</tt>
option it displays a summary.

<pre>
% opp_makemake -h
</pre>
<p>
Once you have the source files (<tt>*.ned</tt>, <tt>*.msg</tt>, <tt>*.cc</tt>,
<tt>*.h</tt>) in a directory, <tt>cd</tt> there then type:

<pre>
% opp_makemake
</pre>
<p>
This will create a file named <tt>Makefile</tt><!--Makefile-->. Thus if you
simply type <tt>make</tt>, your simulation program should build. The name of
the executable will be the same as the name of the directory
containing the files.

<p>
The freshly generated <tt>Makefile</tt> doesn't contain
dependencies<!--Makefile!dependencies-->, it is advisable to add them
by typing <tt>make depend</tt>. The warnings during the
dependency generation process can be safely ignored.

<p>In addition to the simulation executable, the <tt>Makefile</tt>
contains other targets, too. Here is a list of important ones:

<p><table border>
<TR> <TD align=left>

<p><b>Target</b> </TD> <TD align=left> <b>Action</b></TD></TR>
<TR> <TD align=left>  </TD> <TD align=left> The default target is to build the simulation executable</TD></TR>
<TR> <TD align=left> depend </TD> <TD align=left> Adds (or refreshes) dependencies in the <tt>Makefile</tt></TD></TR>
<TR> <TD align=left> clean </TD> <TD align=left>  Deletes all files that were produced by the make process</TD></TR>
<TR> <TD align=left> makefiles </TD> <TD align=left> Regenerates the <tt>Makefile</tt> using <tt>opp_makemake</tt> (this is useful if e.g.  after upgrading OMNeT++, if <tt>opp_makemake</tt> has changed)</TD></TR>
<TR> <TD align=left> makefile-ins </TD> <TD align=left> Similar to <tt>make makefiles</tt>, but it regenerates the <tt>Makefile.in</tt> instead</TD></TR>
</table>

<p>If you already had a <tt>Makefile</tt> in that directory, <tt>opp_makemake</tt>
will refuse to overwrite it. You can force overwriting the old <tt>Makefile</tt>
with the -f option:

<pre>
% opp_makemake -f
</pre>
<p>
If you have problems, check the path definitions (locations of include
files and libraries etc.) in the configure script<!--configure script-->
and correct them if necessary. Then re-run configure for the changes
to take effect.

<p>You can specify the user interface (Cmdenv/Tkenv) with the -u option
(with no -u, Tkenv is the default):

<pre>
% opp_makemake -u Tkenv
</pre>
<p>
Or:

<pre>
% opp_makemake -u Cmdenv
</pre>
<p>
The name of the output file<!--output!file--> is set with the -o
option (the default is the name of the directory):

<pre>
% opp_makemake -o fddi-net
</pre>
<p>
If some of your source files are generated from other files (for
example, you use generated NED files), write your make rules
into a file called <tt>makefrag</tt>. When you run <tt>opp_makemake</tt>, it
will automatically insert <tt>makefrag</tt> into the resulting <tt>makefile</tt>.
With the -i option, you can also name other files to be included into
<tt>Makefile</tt>.

<p>
If you want better portability for your models, you can generate
<tt>Makefile.in</tt> instead of <tt>Makefile</tt> with <tt>opp_makemake</tt>'s
-m option. You can then use <tt>autoconf</tt>-like configure scripts to generate
the <tt>Makefile</tt>.

<p>

<p>
<H3><A NAME="sec282"/>7.2.3 Multi-directory models</H3>

<p>In the case of a large project, your source files may be spread across
several directories. You have to decide whether you want to use static
linking<!--static linking-->, shared or run-time loaded (shared)
libraries<!--shared libraries-->. Here we discuss static linking.

<p>In every subdirectory which contains source files, (say <tt>app/</tt> and
<tt>routing/</tt>), run

<pre>
opp_makemake -n
</pre>
<p>
The -n option means no linking is necessary, only compiling has
to be done.

<p>In non-leaf directories, run

<pre>
opp_makemake -r -n
</pre>
<p>
The -r option enables recursive make: when you build the simulation, make
will descend into the subdirectories and runs make in them too.
By default, -r decends into all subdirectories; the -X directory option
can be used to make it ignore certain subdirectories.

<p>You may need to use the -I option if you include files from other
directories. The -I option is for both C++ and NED
files<!--ned!include path-->. In our example, you could run

<pre>
opp_makemake -n -I../routing
</pre>
<p>
in the <tt>app/</tt> directory, and vice versa.

<p>To build an executable, the -w option can be used; it causes a simulation
executable to be built using all object files from the include (-I) directories:

<pre>
opp_makemake -w -I../routing -I../app
</pre>
<p>
You can affect build order by adding dependencies among subdirectories
into the <tt>makefrag</tt> (<tt>makefrag.vc</tt>) file.

<p>For a complex example of using opp_makemake, check the Makefiles
of the INET Framework, or rather, the makemake script (and makemake.bat file)
which contain the commands to generate the makefiles.

<p>

<p><H3><A NAME="sec283"/>7.2.4 Static vs shared OMNeT++ system libraries</H3>

<p>Default linking uses the shared libraries<!--shared libraries-->. One
reason you would want static linking is that
debugging<!--debugging--> the OMNeT++ class library is more trouble
with shared libraries. Another reason might be that you want to run
the executable on another machine without having to worry about
setting the <tt>LD_LIBRARY_PATH</tt> variable (which should contain the name
of the directory where the OMNeT++ shared libraries are).

<p>If you want static linking<!--static linking-->, find the

<pre>
build_shared_libs=yes
</pre>
<p>

<p>line in the <tt>configure.user</tt> script and change it to

<pre>
build_shared_libs=no
</pre>
<p>
Then you have to re-run the configure script and rebuild everything:

<pre>
./configure
make clean
make
</pre>
<p>

<p>
<H2><A NAME="sec284"/>7.3 Using Windows and Microsoft Visual C++</H2>

<p>This is only a rough overview. Up-to-date, more detailed and more
precise instructions can be found in the <tt>doc/</tt> directory
of your OMNeT++ installation, in the file <tt>Readme.MSVC</tt>.

<p>
<H3><A NAME="sec285"/>7.3.1 Installation</H3>

<p>It is easiest to start with the binary, installer version.
It contains all necessary software except MSVC<!--MSVC-->,
and you can get a working system up and running very fast.

<p>Later you'll probably want to download and build the source
distribution too. Reasons for that might be to compile the libraries
with different flags, to debug into them, or to recompile
with support for additional packages (e.g. Akaroa, MPI).
Compilation should be painless (it takes a single
<tt>nmake -f Makefile.vc</tt> command) after you get the different
component directories right in <tt>configuser.vc</tt>.
Additional software needed for the compilation is also described
in <tt>doc/</tt>.

<p>
<H3><A NAME="sec286"/>7.3.2 Building simulation models on the command line</H3>

<p>OMNeT++ has an automatic MSVC makefile creator named <tt>opp_nmakemake</tt>
which is probably the easier way to go. Its usage is very similar
to the similarly named tool for Unix.

<p>If you run <tt>opp_nmakemake</tt> in a directory of model sources, it
collects all the names of all source files in the directory,
and creates a makefile from them. The resulting makefile is
called <tt>Makefile.vc</tt>.

<p>To use <tt>opp_nmakemake</tt>, open a command window (<i>Start menu</i>
-&gt; <i>Run...</i> --&gt; type <tt>cmd</tt>), then <tt>cd</tt> to the directory
of your model and type:

<pre>
opp_nmakemake
</pre>
<p>
<tt>opp_nmakemake</tt> has several command-line options, mostly the
same as the Unix version.

<p>Then you can build the program by typing:

<pre>
nmake -f Makefile.vc
</pre>
<p>
The most common problem is that <tt>nmake</tt> (which is is part of MSVC)
cannot be found because it is not in the path. You can fix
this by running <tt>vcvars32.bat</tt>, which can be found in the
MSVC <tt>bin</tt> directory (usually
<tt>C:\Program Files\Microsoft
Visual Studio\VC98\Bin</tt>).

<p>
<H3><A NAME="sec287"/>7.3.3 Building simulation models from the MSVC IDE</H3>

<p>You can also use the MSVC IDE for development.
It is best to start by copying one of the sample simulations.

<p>If you want to use compiled NED files (as opposed to dynamic
NED loading, described in section <a href="#sec297">[8.3]</a>),
you need to add NED files to the project, with Custom Build Step
commands to invoke the NED compiler (<tt>nedtool</tt>) on them.
You also need to add the <tt>_n.cc</tt> files generated by <tt>nedtool</tt>
to the project. There is an <tt>AddNEDFileToProject</tt>
macro which performs exactly this task: adding a NED file and
the corresponding <tt>_n.cc</tt> file, and configuring
the Custom Build Step.

<p>
Some caveats (please read <tt>doc/Readme.MSVC</tt> for more!):

<p><ul>
 <li> <b>how to get the graphical environment</b>. By default,
   the sample simulations link with Cmdenv if you rebuild them
   from the IDE. To change to Tkenv, choose Build|Set
   active configuration from the menu, select ``Debug-Tkenv''
   or ``Release-Tkenv'', then re-link the executable.

<p> <li> <b>can't find a usable init.tcl</b>. If you get this message,
   Tcl/Tk is missing the <tt>TCL_LIBRARY</tt> environment variable
   which is normally set by the installer. If you see this message,
   you need to set this variable yourself to the Tcl <tt>lib/</tt> directory.

<p> <li> <b>changed compiler settings</b>. Changes since OMNeT++ 2.2:
   You'll need exception handling and RTTI turned ON, and
   stack size set to as low as 64K.
   See the readme file for rationale and more hints.

<p> <li> <b>adding NED files</b>. After you added a <tt>.ned</tt> file
   to the project, you also have to add a <tt>_n.cpp</tt> file, and set a
   <i>Custom Build Step</i> for them:

<pre>
Description: NED Compiling $(InputPath)
Command: nedtool -s _n.cpp $(InputPath)
Outputs: $(InputName)_n.cpp
</pre>
<p>
   For msg files you need an analogous procedure.

<p> <li> <b>file name extension</b>: MSVC 6.0 doesn't recognize <tt>.cc</tt> files
   as C++ sources. Your options are to switch to the <tt>.cpp</tt> extension,
   to convince MSVC by changing by the corresponding registry entries.
   Do a web search to find out what exactly you need to change.

<p></ul>

<p>

</BODY>
</HTML>
<hr><hr><H1><A NAME="sec288"/>8 Configuring and Running Simulations</H1>
<a name="cha:run-sim"></a>

<p><H2><A NAME="sec289"/>8.1 User interfaces</H2>

<p>OMNeT++ simulations can be run under different user interfaces.
Currenly, two user interfaces are supported:

<p><ul>
  <li> Tkenv: Tcl/Tk-based graphical, windowing user interface
  <li> Cmdenv: command-line user interface for batch execution
</ul>

<p>
You would typically test and debug your simulation under Tkenv,
then run actual simulation experiments from the command line or
shell script, using Cmdenv. Tkenv is also better suited for educational or
demonstration purposes.

<p>Both Tkenv and Cmdenv are provided in the form of a library, and
you choose between them by linking one or the other into your
simulation executable. (Creating the executable was described in
chapter <a href="#sec277">[7]</a>). Both user interfaces
are supported on Unix and Windows platforms.

<p>Common functionality in Tkenv and Cmdenv has been collected and
placed into the Envir library<!--Envir-->, which can be thought of as the
``common base class'' for the two user interfaces.

<p>The user interface<!--user interface--> is separated from the
simulation kernel, and the two parts interact through a well-defined
interface. This also means that, if needed, you can write your
own user interface or embed an OMNeT++ simulation into your application
without any change to models or the simulation library.

<p>Configuration and input data for the simulation are described in
a configuration file usually called <tt>omnetpp.ini</tt>.
Some entries in this file apply to Tkenv or Cmdenv only, other
settings are in effect regardless of the user interface.
Both user interfaces accept command-line arguments, too.

<p>
The following sections explain <tt>omnetpp.ini</tt> and the common part of
the user interfaces, describe Cmdenv and Tkenv in detail, then
go on to specific problems.

<p>
<H2><A NAME="sec290"/>8.2 The configuration file: omnetpp.ini<!--omnetpp.ini--></H2>

<p><H3><A NAME="sec291"/>8.2.1 An example</H3>

<p>For a start, let us see a simple <tt>omnetpp.ini</tt> file which
can be used to run the Fifo1 sample simulation under Cmdenv.

<pre>
[General]
network = fifonet1
sim-time-limit = 500000s
output-vector-file = fifo1.vec

[Cmdenv]
express-mode = yes

[Parameters]
# generate a large number of jobs of length 5..10 according to Poisson
fifonet1.gen.num_messages = 10000000
fifonet1.gen.ia_time = exponential(1)
fifonet1.gen.msg_length = intuniform(5,10)
# processing speeed of queue server
fifonet1.fifo.bits_per_sec = 10
</pre>
<p>
The file is grouped into <i>sections</i> named <tt>[General]</tt>, <tt>[Cmdenv]</tt>
and <tt>[Parameters]</tt>, each one containing several <i>entries</i>.
The <tt>[General]</tt> section applies to both Tkenv and Cmdenv, and the entries
in this case specify that the network named <tt>fifonet1</tt> should be simulated and run
for 500,000 simulated seconds, and vector results should be written into the
<tt>fifo1.vec</tt> file. The entry in the <tt>[Cmdenv]</tt> section tells
Cmdenv to run the simulation at full speed and print periodic updates
about the progress of the simulation. The <tt>[Parameters]</tt> section assigns
values to parameters that did not get a value (or got <tt>input</tt> value)
inside the NED files.

<p>Lines that start with ``#'' or ``;'' are comments.

<p>When you build the Fifo1 sample with Cmdenv and you run it by typing <tt>fifo1</tt>
(or on Unix, <tt>./fifo1</tt>) on the command prompt, you should see
something like this.

<pre>
OMNeT++ Discrete Event Simulation  (C) 1992-2003 Andras Varga
See the license for distribution terms and warranty disclaimer
Setting up Cmdenv (command-line user interface)...

Preparing for Run #1...
Setting up network `fifonet1'...
Running simulation...
** Event #0        T=0.0000000  ( 0.00s)   Elapsed: 0m  0s   ev/sec=0
** Event #100000   T=25321.99 ( 7h  2m)    Elapsed: 0m  1s   ev/sec=0
** Event #200000   T=50275.694 (13h 57m)   Elapsed: 0m  3s   ev/sec=60168.5
** Event #300000   T=75217.597 (20h 53m)   Elapsed: 0m  5s   ev/sec=59808.6
** Event #400000   T=100125.76 ( 1d  3h)   Elapsed: 0m  6s   ev/sec=59772.9
** Event #500000   T=125239.67 ( 1d 10h)   Elapsed: 0m  8s   ev/sec=60168.5
...
** Event #1700000  T=424529.21 ( 4d 21h)   Elapsed: 0m 28s   ev/sec=58754.4
** Event #1800000  T=449573.47 ( 5d  4h)   Elapsed: 0m 30s   ev/sec=59066.7
** Event #1900000  T=474429.06 ( 5d 11h)   Elapsed: 0m 32s   ev/sec=59453
** Event #2000000  T=499417.66 ( 5d 18h)   Elapsed: 0m 34s   ev/sec=58719.9
&lt;!&gt; Simulation time limit reached -- simulation stopped.

Calling finish() at end of Run #1...
*** Module: fifonet1.sink***
Total jobs processed: 9818
Avg queueing time:    1.8523
Max queueing time:    10.5473
Standard deviation:   1.3826

End run of OMNeT++
</pre>
<p>
As Cmdenv runs the simulation, periodically it prints the sequence number
of the current event, the simulation time, the elapsed (real) time,
and the performance of the simulation (how many events are processed per
second; the first two values are 0 because there wasn't enough data
for it to calculate yet). At the end of the simulation, the <tt>finish()</tt>
methods of the simple modules are run, and the output from them are displayed.
On my machine this run took 34 seconds. This Cmdenv output can be
customized via <tt>omnetpp.ini</tt> entries. The output file <tt>fifo1.vec</tt>
contains vector data recorded during simulation (here, queueing times),
and it can be processed using Plove or other tools.

<p><H3><A NAME="sec292"/>8.2.2 The concept of simulation runs</H3>

<p>OMNeT++ can execute several simulation runs automatically one after
another. If multiple runs<!--simulation!multiple runs--> are
selected, option settings and parameter values can be given either
individually for each run, or together for all runs, depending in
which section the option or parameter appears.

<p><H3><A NAME="sec293"/>8.2.3 File syntax</H3>

<p>The ini file is a text file consisting of entries grouped into different sections.
The order of the sections doesn't matter. Also, if you have two sections
with the same name (e.g. <tt>[General]</tt> occurs twice in the file),
they will be merged.

<p>Lines that start with "#" or ";" are comments, and will be ignored during
processing.

<p>Long lines can be broken up using the backslash notation: if the last character
of a line is "\", it will be merged with the next line.

<p>The size of the ini file (the number of sections and entries) is not limited.
Currently there is a 1024-character limit on the line length,
which <i>cannot</i> be increased by breaking up the line using backslashes.
This limit might be lifted in future releases.

<p>Example:

<pre>
[General]
# this is a comment
foo="this is a single value \
for the foo parameter"

[General]  # duplicate sections are merged
bar="belongs to the same section as foo"
</pre>
<p>
<H3><A NAME="sec294"/>8.2.4 File inclusion</H3>

<p>OMNeT++ supports including an ini file in another<!--ini file!file inclusion-->,
via the <tt>include</tt> keyword. This feature allows you to partition large ini
files into logical units, fixed and varying part etc.

<p>An example:

<pre>
# omnetpp.ini
...
include parameters.ini
include per-run-pars.ini
...
</pre>
<p>
You can also include files from other directories. If the included ini file
further includes others, their path names will be understood as relative
to the location of the file which contains the reference,
rather than relative to the current working directory of the simulation.
This rule also applies to other file names occurring in ini files
(such as the <tt>preload-ned-files=</tt>, <tt>load-libs=</tt>,
<tt>bitmap-path=</tt>, <tt>output-vector-file=</tt>, <tt>output-scalar-file=</tt> etc
entries, and <tt>xmldoc()</tt> module parameter values.)

<p>
<H3><A NAME="sec295"/>8.2.5 Sections</H3>

<p>The following sections can exist:

<p><table border>
<TR> <TD align=left>

<p><b>Section</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=left> <tt>[General]</tt> </TD> <TD align=left> Contains general settings that apply to all simulation runs
and all user interfaces. For details, see section <a href="#sec296">[8.2.6]</a>.
</TD></TR>
<TR> <TD align=left> <tt>[Run 1]</tt>, <tt>[Run 2]</tt>, ...  </TD> <TD align=left> Contains per-run settings.
These sections may contain any entries that are accepted in other
sections.
</TD></TR>
<TR> <TD align=left> <tt>[Cmdenv]</tt> </TD> <TD align=left> Contains Cmdenv-specific settings.
For details, see section <a href="#sec312">[8.7.2]</a>
</TD></TR>
<TR> <TD align=left> <tt>[Tkenv]</tt> </TD> <TD align=left> Contains Tkenv-specific settings.
For details, see section <a href="#sec316">[8.8.2]</a>
</TD></TR>
<TR> <TD align=left> <tt>[Parameters]</tt> </TD> <TD align=left> Contains values for module parameters that did not
get a value (or got <tt>input</tt> value) inside the NED files.
For details, see section <a href="#sec298">[8.4]</a>
</TD></TR>
<TR> <TD align=left> <tt>[OutVectors]</tt> </TD> <TD align=left> Configures recording of output vectors. You can specify
filtering by vector names and by simulation time (start/stop recording).
For details, see section <a href="#sec302">[8.5]</a>
</TD></TR>
<TR> <TD align=left> </table>

<p>

<p><H3><A NAME="sec296"/>8.2.6 The [General] section</H3>
<a name="sec:ch-run-sim:general-section"></a>

<p>The most important options of the <tt>[General]</tt> section are the
following.
<ul>
  <li>The <tt>network</tt> option selects the model to be set up and run.
  <li>The length of the simulation can be set with the
    <tt>sim-time-limit</tt> and the <tt>cpu-time-limit</tt> options (the
    usual time units such as ms, s, m, h, etc. can be used).
  <li>The output file names can be set with the following options:
    <tt>output-vector-file</tt>, <tt>output-scalar-file</tt> and <tt>snapshot-file</tt>.
</ul>

<p>The full list of supported options follows. Almost every one these options
can also be put into the <tt>[Run <i>n</i>]</tt> sections. Per-run settings
have priority over globally set ones.

<p>
<table border>
<TR> <TD align=left>

<p><b>Name and default value</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=center colspan=2><b>[General]</b> </TD></TR>
<TR> <TD align=left> <tt>ini-warnings</tt> = yes </TD> <TD align=left> When enabled, OMNeT++ lists the names of
ini file entries for which the default values were used.
This can at times be useful for debugging ini files.
</TD></TR>
<TR> <TD align=left> <tt>preload-ned-files</tt> = </TD> <TD align=left> List of NED files to be loaded dynamically
(see <a href="#sec297">[8.3]</a>). </TD></TR>
<TR> <TD align=left> <tt>network</tt> = </TD> <TD align=left> The name of the network to be simulated. </TD></TR>
<TR> <TD align=left> <tt>snapshot-file</tt> = omnetpp.sna </TD> <TD align=left> Name of the snapshot file. The result of
each <tt>snapshot()</tt> call will be appended to this file. </TD></TR>
<TR> <TD align=left> <tt>output-vector-file</tt> = omnetpp.vec </TD> <TD align=left> Name of output vector file. </TD></TR>
<TR> <TD align=left> <tt>output-scalar-file</tt> = omnetpp.sca </TD> <TD align=left> Name of output scalar file. </TD></TR>
<TR> <TD align=left> <tt>pause-in-sendmsg</tt> = no </TD> <TD align=left> Only makes sense with step-by-step execution.
If enabled, OMNeT++ will split <tt>send()</tt> calls to two steps.</TD></TR>
<TR> <TD align=left> <tt>sim-time-limit</tt> = </TD> <TD align=left> Duration of the simulation in simulation time.</TD></TR>
<TR> <TD align=left> <tt>cpu-time-limit</tt> = </TD> <TD align=left> Duration of the simulation in real time.</TD></TR>
<TR> <TD align=left> <tt>num-rngs</tt> = 1 </TD> <TD align=left> Number of random number generators.</TD></TR>
<TR> <TD align=left> <tt>rng-class</tt> = <tt>"cMersenneTwister"</tt> </TD> <TD align=left> The RNG class to be used. It can be
<tt>"cMersenneTwister"</tt>, <tt>"cLCG32"</tt>, or <tt>"cAkaroaRNG"</tt>,
or you can use your own RNG class (it must be subclassed from <tt><a href="../api/classcRNG.html">cRNG</a></tt>).</TD></TR>
<TR> <TD align=left> <tt>seed-N-mt</tt> =, <tt>seed-N-lcg32</tt> = </TD> <TD align=left> Specifies seeds for the
cMersenneTwister and the cLCG32 RNGs (substitute N with the RNG number: 0, 1, 2...);
default is auto seed selection. This obsoletes the <i>random-seed=</i> and
<i>gen0-seed=</i>, <i>gen1-seed=</i>, etc. entries which are no longer in use.</TD></TR>
<TR> <TD align=left> <tt>total-stack-kb</tt> = </TD> <TD align=left> Specifies the total stack size (sum of all coroutine stacks)
in kilobytes. You need to increase this value if you get the
``Cannot allocate coroutine stack...'' error.</TD></TR>
<TR> <TD align=left> <tt>debug-on-errors</tt> = false </TD> <TD align=left> When set to <tt>true</tt>, runtime errors will
cause the simulation program to break into the C++ debugger (if the simulation
is running under one, or just-in-time debugging is activated).
Once in the debugger, you can view the stack trace or examine variables. </TD></TR>
<TR> <TD align=left> <tt>load-libs</tt> = </TD> <TD align=left>  List of shared libraries (separated by
spaces) to load in the initialization phase. OMNeT++ appends a platform-specific
extension to the library name: <tt>.dll</tt> on Windows and <tt>.so</tt> on Unix systems.
This feature can be used to dynamically load Envir extensions (RNGs, output vector
managers, etc.) or simple modules. Example:

<p><tt>load-libs</tt> = <tt>"../lib/rng2 ../lib/ospfrouting"</tt></TD></TR>
<TR> <TD align=left> <tt>perform-gc</tt> = false </TD> <TD align=left>  If <tt>true</tt>, the simulation kernel
will <tt>delete</tt> on network cleanup the simulation objects not deleted
by simple module destructors. Not recommended because it may cause crashes
under certain scenarios. See <a href="#sec170">[4.3.5]</a>. <sup><b>[New!]</b></sup></TD></TR>
<TR> <TD align=left> <tt>print-undisposed</tt> = true </TD> <TD align=left>  When perform-gc is <tt>false</tt>
(default setting), it selects whether simulation objects not deleted by
simple module destructors should be reported by the simulation kernel. <sup><b>[New!]</b></sup></TD></TR>
<TR> <TD align=left> <tt>output-scalar-precision</tt> = <tt>12</tt> </TD> <TD align=left>  Adjusts the number
of significant digits recorded into the output scalar file.
See <a href="#sec260">[6.9.3]</a> for a discussion. <sup><b>[New!]</b></sup></TD></TR>
<TR> <TD align=left> <tt>output-vector-precision</tt> = <tt>12</tt> </TD> <TD align=left>  Adjusts the number
of significant digits recorded into the output vector file.
See <a href="#sec260">[6.9.3]</a> for a discussion. <sup><b>[New!]</b></sup></TD></TR>
<TR> <TD align=left> <tt>fname-append-host</tt> = false </TD> <TD align=left>  Turning it on will cause the
host name and process Id to be appended to the names of output files
(e.g. <tt>omnetpp.vec</tt>, <tt>omnetpp.sca</tt>). This is especially useful
for parallel distributed simulation (chapter <a href="#sec378">[12]</a>).</TD></TR>
<TR> <TD align=left> <tt>parallel-simulation</tt> = false </TD> <TD align=left>  Enables parallel distributed
simulation (see chapter <a href="#sec378">[12]</a>).</TD></TR>
<TR> <TD align=left> <tt>scheduler-class</tt> = <br>
<tt><a href="../api/classcSequentialScheduler.html">cSequentialScheduler</a></tt>
</TD> <TD align=left>
 Part of the Envir<!--Envir--> plugin mechanism:
selects the scheduler class. This plugin interface allows for implementing
real-time, hardware-in-the-loop, distributed and distributed parallel simulation.
The class has to implement the <tt><a href="../api/classcScheduler.html">cScheduler</a></tt> interface
defined in <tt>envirext.h</tt>.
More details in section <a href="#sec397">[13.5.3]</a>.</TD></TR>
<TR> <TD align=left> <tt>configuration-class</tt> = <br>
<tt>cInifile</tt>
</TD> <TD align=left>
 Part of the Envir<!--Envir--> plugin mechanism: selects the
class from which all configuration will be obtained. In other words, this
option lets you replace <tt>omnetpp.ini</tt> with some other implementation,
e.g. database input. The simulation program still has to bootstrap from
an <tt>omnetpp.ini</tt> though (which contains the <tt>configuration-class</tt>
setting). The class has to implement the <tt><a href="../api/classcConfiguration.html">cConfiguration</a></tt> interface
defined in <tt>envirext.h</tt>.
More details in section <a href="#sec397">[13.5.3]</a>.</TD></TR>
<TR> <TD align=left> <tt>outputvectormanager-class</tt> = <br>
<tt>cFileOutputVectorManager</tt>
</TD> <TD align=left>
 Part of the Envir<!--Envir--> plugin mechanism: selects
the output vector manager class to be used to record data from output
vectors<!--output!vector-->.  The class has to implement the
<tt><a href="../api/classcOutputVectorManager.html">cOutputVectorManager</a></tt> interface defined in <tt>envirext.h</tt>.
More details in section <a href="#sec397">[13.5.3]</a>.</TD></TR>
<TR> <TD align=left> <tt>outputscalarmanager-class</tt> = <br>
<tt>cFileOutputScalarManager</tt>
</TD> <TD align=left>
 Part of the Envir plugin mechanism: selects the output
scalar manager class to be used to record data passed to
<tt>recordScalar()</tt>. The class has to implement the
<tt><a href="../api/classcOutputScalarManager.html">cOutputScalarManager</a></tt> interface defined in <tt>envirext.h</tt>.
More details in section <a href="#sec397">[13.5.3]</a>.</TD></TR>
<TR> <TD align=left> <tt>snapshotmanager-class</tt> = <br>
<tt>cFileSnapshotManager</tt>
</TD> <TD align=left>
 Part of the Envir plugin mechanism: selects the class to
handle streams to which <tt>snapshot()</tt> writes its output.  The
class has to implement the <tt><a href="../api/classcSnapshotManager.html">cSnapshotManager</a></tt> interface defined
in <tt>envirext.h</tt>.
More details in section <a href="#sec397">[13.5.3]</a>.</TD></TR>
<TR> <TD align=left> 
</table>

<p>
<H2><A NAME="sec297"/>8.3 Dynamic NED loading</H2>
<a name="cha:run-sim:dynamic-ned"></a>

<p>Prior to OMNeT++ 3.0, NED files had to be translated into C++ by the
NED compiler, compiled and linked into the simulation program.
From OMNeT++ 3.0 up, one can use dynamic NED loading, which means
that a simulation program can load NED files at runtime when it starts
-- compiling NED files into the simulation program is no longer necessary.
This results in more flexibility, and can also save model development time.

<p>The key is the <tt>preload-ned-files=</tt> configuration option in the
<tt>[General]</tt> section of <tt>omnetpp.ini</tt>. This option should
list the names of the NED files to be loaded when the simulation program
starts.

<p>Example:

<pre>
[General]
preload-ned-files = host.ned router.ned networks/testnetwork1.ned
</pre>
<p>
Wildcards can also be used:

<pre>
[General]
preload-ned-files = *.ned networks/*.ned
</pre>
<p>
It is also possible to use list files, with the <tt>@</tt> notation:

<pre>
[General]
preload-ned-files = *.ned @../nedfiles.lst
</pre>
<p>
where the <tt>nedfiles.lst</tt> file contains the list of NED files,
one per line, like this:

<pre>
transport/tcp/tcp.ned
transport/udp/udp.ned
network/ip/ip.ned
</pre>
<p>
The Unix <tt>find</tt> command is often a very convenient way
to create list files (try <tt>find . -name '*.ned' &gt; listfile.lst</tt>).

<p>Moreover, the list file can also contain wildcards, and references
to other list files:

<pre>
transport/tcp/*.ned
transport/udp/*.ned
@moreprotocols.lst
</pre>
<p>
Files given with relative paths are relative to the location of the
list file (and not to the current working directory). That is,
the <tt>transport</tt> directory and <tt>moreprotocols.lst</tt> in the example
above are expected to be in the same directory as <tt>nedfiles.lst</tt>,
whatever the current working directory is.

<p>It is important to note, that the loaded NED files may contain
any number of modules, channel and <i>any number of networks</i> as well.
It does not matter whether you use all or just some of them
in the simulations. You will be able to select <tt>any</tt> of the
networks that occur in the loaded NED files using the <tt>network=</tt>
<tt>omnetpp.ini</tt> entry, and as long as every module, channel etc
for it has been loaded, network setup will be successful.

<p>
<H2><A NAME="sec298"/>8.4 Setting module parameters in omnetpp.ini</H2>
<a name="sec:ch-run-sim:parameter-settings"></a>
<!--module!parameters-->

<p>Simulations get input via module parameters, which can be assigned a
value in NED files or in <tt>omnetpp.ini</tt> -- in this order. Since parameters
assigned in NED files cannot be overridden in omnetpp.ini, one can
think about them as being ``hardcoded''. In contrast, it is easier
and more flexible to maintain module parameter settings in omnetpp.ini.

<p>In omnetpp.ini, module parameters are referred to by their full paths
or hiearchical names. This name consists of the dot-separated list of
the module names (from the top-level module down to the module containg
the parameter), plus the parameter name
(see section <a href="#sec229">[6.1.5]</a>).

<p>An example <tt>omnetpp.ini</tt> which sets the <tt>numHosts</tt> parameter of
the toplevel module and the <tt>transactionsPerSecond</tt> parameter of the
<tt>server</tt> module:

<pre>
[Parameters]
net.numHosts = 15
net.server.transactionsPerSecond = 100
</pre>
<p>

<p><H3><A NAME="sec299"/>8.4.1 Run-specific and general sections</H3>

<p>Values for module parameters can be placed into the <tt>[Parameters]</tt>
or the <tt>[Run 1]</tt>, <tt>[Run 2]</tt> etc. sections of the ini file.
The run-specific settings take precedence over the overall settings.

<p>Though runs are identified by numbers, you can assign them short
descriptive labels, which will get displayed e.g. in the Tkenv
run selection dialog. Just place a <tt>description="some text"</tt>
line under the <tt>[Run x]</tt> heading.

<p>An example <tt>omnetpp.ini</tt> (everything after # is a comment):

<pre>
[Parameters]
net.numHosts = 15
net.server.transactionsPerSecond = 100

[Run 1]
description="general settings"
# uses settings from the [Parameters] section

[Run 2]
description="higher transaction rate"
net.server.transactionsPerSecond = 150  # overrides the value in [Parameters]
# net.numHosts comes from the [Parameters] section

[Run 3]
description="more hosts and higher transaction rate"
# override both setting in [Parameters]
net.numHosts = 20
net.server.transactionsPerSecond = 150
</pre>
<p>

<p>

<p><H3><A NAME="sec300"/>8.4.2 Using wildcard patterns</H3>
<a name="sec:ch-run-sim:wildcards"></a>
<!--ini file!wildcards-->

<p>Models can have a large number of parameters to be configured, and it would
be tedious to set them one-by-one in <tt>omnetpp.ini</tt>. OMNeT++ supports
<i>wildcards patterns</i> which allow for setting several model parameters
at once.

<p>The notation is a variation on the usual glob-style patterns.
The most apperent differences to the usual rules are the distinction between
<tt>*</tt> and <tt>**</tt>, and that character ranges should be written
with curly braces instead of square brackets (that is, <i>any-letter</i>
is <tt>{a-zA-Z}</tt> not <tt>[a-zA-Z]</tt>, because square brackets are
already reserved for the notation of module vector indices).

<p>Pattern syntax:

<p><ul>
  <li> <tt>?</tt> : matches any character except dot (.)
  <li> <tt>*</tt> : matches zero or more characters except dot (.)
  <li> <tt>**</tt> : matches zero or more character (any character)
  <li> <tt>{a-f}</tt> : <i>set</i>: matches a character in the range a-f
  <li> <tt>{^a-f}</tt>: <i>negated set</i>: matches a character
    NOT in the range a-f
  <li> <tt>{38..150}</tt> : <i>numeric range</i>: any number (i.e. sequence of digits)
    in the range 38..150  (e.g. <tt>99</tt>)
  <li> <tt>[38..150]</tt> : <i>index range</i>: any number in square brackets in the
    range 38..150 (e.g. <tt>[99]</tt>)
  <li> backslash (\) : takes away the special meaning of the
    subsequent character
</ul>

<p><p class="subheading">Precedence</p>

<p>If you use wildcards, the order of entries is important: if a parameter
name matches several wildcards-patterns, the <i>first</i> matching occurrence
is used. This means that you need to list specific settings first, and
more general ones later. Catch-all settings should come last.

<p>An example ini file:

<pre>
[Parameters]
*.host[0].waitTime = 5ms   # specifics come first
*.host[3].waitTime = 6ms
*.host[*].waitTime = 10ms  # catch-all comes last
</pre>
<p>

<p><p class="subheading">Asterisk vs double asterisk</p>

<p>The <tt>*</tt> wildcard is for matching a single module or parameter name in the
path name, while <tt>**</tt> can be used to match several components in the path.
For example, <tt>**.queue*.bufSize</tt> matches the <tt>bufSize</tt> parameter of any module
whose name begins with <tt>queue</tt> in the model, while <tt>*.queue*.bufSize</tt>
or <tt>net.queue*.bufSize</tt> selects only queues immediately on network level.
Also note that <tt>**.queue**.bufSize</tt> would match <tt>net.queue1.foo.bar.bufSize</tt>
as well!

<p><p class="subheading">Sets, negated sets</p>

<p>Sets and negated sets can contain several character ranges and also
enumeration of characters. For example, <tt>{_a-zA-Z0-9}</tt> matches any letter
or digit, plus the underscore; <tt>{xyzc-f}</tt> matches any of the characters
x, y, z, c, d, e, f.
To include '-' in the set, put it at a position where it cannot be
interpreted as character range, for example: <tt>{a-z-}</tt> or <tt>{-a-z}</tt>.
If you want to include '}' in the set, it must be the first
character: <tt>{}a-z}</tt>, or as a negated set: <tt>{^}a-z}</tt>. A backslash
is always taken as literal backslash (and NOT as escape character)
within set definitions.

<p>
<p class="subheading">Numeric ranges and index ranges</p>

<p>Only nonnegative integers can be matched.  The start or the end of the range
(or both) can be omitted: <tt>{10..}</tt>, <tt>{..99}</tt> or <tt>{..}</tt>
are valid numeric ranges (the last one matches any number).
The specification must use exactly two dots.
Caveat: <tt>*{17..19}</tt> will match <tt>a17</tt>, <tt>117</tt> and <tt>963217</tt> as well,
because the <tt>*</tt> can also match digits!

<p>An example for numeric ranges:

<pre>
[Parameters]
*.*.queue[3..5].bufSize = 10
*.*.queue[12..].bufSize = 18
*.*.queue[*].bufSize = 6  # this will only affect queues 0,1,2 and 6..11
</pre>
<p>
<p class="subheading">Compatibility</p>

<p>In OMNeT++ versions prior to 3.0, the <tt>**</tt> wildcard did not exist, and <tt>*</tt>
matched dot as well. This means that ini files written for earlier OMNeT++
versions may have a different meaning when used in OMNeT++ 3.0 -- so
ini files have to be updated. In practice, every line which begins
with <tt>*.</tt> should be changed to begin with <tt>**.</tt> -- that'll do most
of the time, further tweaking is rarely necessary.

<p>If you still want to run the old <tt>omnetpp.ini</tt> (for example, to check the new one
against it), you can add the line

<pre>
#% old-wildcards
</pre>
<p>
at the top of (each) old ini file. This will switch back to the old
behaviour. Since <tt>#% old-wildcards</tt> is only provided to ease transition
from OMNeT++ 2.3 to 3.0, it will be removed in some future version.

<p>
<H3><A NAME="sec301"/>8.4.3 Applying the defaults</H3>

<p>It is also possible to utilize the default values specifified with
<tt>input(</tt><i>default-value</i><tt>)</tt> in the NED files.
The <i>&lt;parameter-name&gt;</i><tt>.use-default=yes</tt> setting assigns
the default value to the parameter, or 0, false or empty string if
there was no default value in the NED file.

<p>The following example sets <tt>ttl</tt> (time-to-live) of <tt>hostA</tt>'s
<tt>ip</tt> module to 5, while all other nodes in the network
will get the default specified with <tt>input()</tt> in the NED files.

<p><pre>
[Parameters]
**.hostA.ip.ttl = 5
**.ip.ttl.use-default = yes
</pre>

<p>To make use of <i>all</i> defaults in NED files, you'd add the following to
<tt>omnetpp.ini</tt>:

<pre>
[Parameters]
**.use-default = yes
</pre>
<p>

<p><H2><A NAME="sec302"/>8.5 Configuring output vectors</H2>
<a name="sec:ch-run-sim:outvectors"></a>

<p>As a simulation program is evolving, it is becoming capable of
collecting more and more statistics. The size of output vector
files<!--output!vector file--> can easily reach a magnitude of
several ten or hundred megabytes, but very often, only some of the
recorded statistics are interesting to the analyst.

<p>In OMNeT++, you can control how <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects record data
to disk. You can turn output vectors on/off or you can assign a result
collection interval. Output vector configuration is given in the
<tt>[OutVectors]</tt> section of the ini file, or in the <tt>[Run
  1]</tt>, <tt>[Run 2]</tt> etc sections individually for each run. By
default, all output vectors are turned on.

<p>Output vectors can be configured with the following syntax:

<p><pre>
<i>module-pathname</i>.<i>objectname</i>.enabled = yes/no
<i>module-pathname</i>.<i>objectname</i>.interval = <i>start</i>..<i>stop</i>
<i>module-pathname</i>.<i>objectname</i>.interval = ..<i>stop</i>
<i>module-pathname</i>.<i>objectname</i>.interval = <i>start</i>..
</pre>

<p>The object name is the string passed to <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> in its constructor
or with the <tt>setName()</tt> member function.

<pre>
<a href="../api/classcOutVector.html">cOutVector</a> eed("End-to-End Delay");
</pre>
<p>
Start and stop values can be any time specification accepted
in NED and config files (e.g. <i>10h 30m 45.2s</i>).

<p>As with parameter names, wildcards are allowed in the object
names and module path names.

<p>An example:

<pre>
#
# omnetpp.ini
#

[OutVectors]
**.interval = 1s..60s
**.End-to-End Delay.enabled = yes
**.Router2.**.enabled = yes
**.enabled = no
</pre>
<p>

<p>The above configuration limits collection of all output vectors
to the 1s..60s interval, and disables collection of output vectors
except all end-to-end delays and the ones in any module called Router2.

<p>
<H2><A NAME="sec303"/>8.6 Configuring the random number generators</H2>
<a name="sec:ch-run-sim:rng-config"></a>

<p>The random number architecture of OMNeT++ was already outlined
in section <a href="#sec235">[6.4]</a>. Here
we'll cover the configuration of RNGs in <tt>omnetpp.ini</tt>.

<p><H3><A NAME="sec304"/>8.6.1 Number of RNGs</H3>

<p>The <tt>num-rngs=</tt> configuration entry sets the number of
random number generator instances (i.e. random number streams)
available for the simulation model (see <a href="#sec235">[6.4]</a>).
Referencing an RNG number greater or equal to this number
(from a simple module or NED file) will cause a runtime error.

<p>
<H3><A NAME="sec305"/>8.6.2 RNG choice</H3>

<p>The <tt>rng-class=</tt> configuration entry sets the random number
generator class to be used. It defaults to <tt>"cMersenneTwister"</tt>,
the Mersenne Twister RNG. Other available classes are <tt>"cLCG32"</tt>
(the "legacy" RNG of OMNeT++ 2.3 and earlier versions, with a cycle length
of <i>2<sup>31</sup>-2</i>), and <tt>"cAkaroaRNG"</tt> (Akaroa's random number generator,
see section <a href="#sec323">[8.10]</a>).

<p><H3><A NAME="sec306"/>8.6.3 RNG mapping</H3>

<p>The RNG numbers used in simple modules may be arbitrarily mapped to the
actual random number streams (actual RNG instances) from <tt>omnetpp.ini</tt>.
The mapping allows for great flexibility in RNG usage and random number
streams configuration -- even for simulation models which were not
written with RNG awareness.

<p>RNG mapping may be specified in <tt>omnetpp.ini</tt>. The syntax of
configuration entries is the following.

<pre>
[General]
&lt;modulepath&gt;.rng-N=M  (where N,M are numeric, M&lt;num-rngs)
</pre>
<p>
This maps module-local RNG N to physical RNG M. The following
example maps all  <tt>gen</tt> module's default (N=0) RNG to physical RNG 1,
and all  <tt>noisychannel</tt> module's default (N=0) RNG to physical RNG 2.

<pre>
[General]
num-rngs = 3
**.gen[*].rng-0 = 1
**.noisychannel[*].rng-0 = 2
</pre>
<p>
This mapping allows variance reduction techniques to be applied to
OMNeT++ models, without any model change or recompilation.

<p>
<H3><A NAME="sec307"/>8.6.4 Automatic seed selection</H3>

<p>Automatic seed selection gets used for an RNG if you don't explicitly
specify seeds in omnetpp.ini. Automatic and manual seed selection can
co-exist: for a particular simulation, some RNGs can be configured
manually, and some automatically.

<p>The automatic seed selection mechanism uses two inputs: the <i>run number</i>
(i.e. the number in the <tt>[Run 1]</tt>, <tt>[Run 2]</tt>, etc. section names),
and the <i>RNG number</i>. For the same the run number and RNG number,
OMNeT++ always selects the same seed value for any simulation model.
If the run number or the RNG number is different, OMNeT++ does its best
to choose different seeds which are also sufficiently apart in the RNG's sequence
so that the generated sequences don't overlap.

<p>The run number can be specified either in in omnetpp.ini (e.g. via the
<tt>[Cmdenv]/runs-to-execute=</tt> entry) or on the command line:

<pre>
./mysim -r 1
./mysim -r 2
./mysim -r 3
</pre>
<p>
For the <tt>cMersenneTwister</tt> random number generator, selecting seeds
so that the generated sequences don't overlap is easy,
due to the extremely long sequence of the RNG.
The RNG is initialized from the 32-bit seed value <i>seed = runNumber*numRngs + rngNumber</i>.
(This implies that simulation runs participating in the study should have
the same number of RNGs set).
    <br><ul><font size=-1>[While (to our knowledge) no one has proven that the seeds 0,1,2,...
    are well apart in the sequence, this is probably true, due to the extremely
    long sequence of MT. The author would however be interested in papers
    published about seed selection for MT.]</font></ul>

<p>For the <tt>cLCG32</tt> random number generator, the situation is more difficult,
because the range of this RNG is rather short (<i>2<sup>31</sup>-1</i>, about 2 billion).
For this RNG, OMNeT++ uses a table of 256 pre-generated seeds, equally spaced
in the RNG's sequence. Index into the table is calculated with the
<i>runNumber*numRngs + rngNumber</i> formula. Care should be taken that
one doesn't exceed 256 with the index, or it will wrap and the
same seeds will be used again. It is best not to use the <tt>cLCG32</tt>
at all -- <tt>cMersenneTwister</tt> is superior in every respect.

<p>
<H3><A NAME="sec308"/>8.6.5 Manual seed configuration</H3>

<p>In some cases you may want manually configure seed values.
Reasons for doing that may be that you want to use variance reduction
techniques, or you may want to use the same seeds for several simulation
runs.

<p>For the cLCG32 RNG, OMNeT++ provides a standalone program to generate
seed values (<tt>seedtool</tt> is discussed in section
<a href="#sec309">[8.6.6]</a>), and you can specify those seeds explicitly
in the ini file.

<p>The following ini file explicitly initializes two of the random
number generators, and uses different seed values for each run:

<pre>
[General]
rng-class=cLCG32  # needed because the default is cMersenneTwister
num-rngs = 2

[Run 1]
seed-0-lcg32 = 1768507984
seed-1-lcg32 = 33648008

[Run 2]
seed-0-lcg32 = 1082809519
seed-1-lcg32 = 703931312
...
</pre>
<p>
To manually set seeds for the Mersenne Twister RNG (which should
seldom, if ever, be necessary), use the <tt>seed-0-mt=</tt>,
<tt>seed-1-mt=</tt>, etc settings:

<pre>
[General]
num-rngs = 2

[Run 1]
seed-0-mt = 1317366363
seed-1-mt = 1453732904

[Run 2]
...
</pre>
<p>
To set a seed value for all runs, place the necessary seed entries
into the <tt>[General]</tt> section.

<p>
<H3><A NAME="sec309"/>8.6.6 Choosing good seed values: the seedtool utility</H3>
<a name="sec:ch-run-sim:seedtool"></a>

<p>The <tt>seedtool</tt> program can be used for selecting
seeds for the cLCG32 RNG. When started without command-line
arguments, the program prints out the following help:

<pre>
seedtool - part of OMNeT++/OMNEST, (C) 1992-2004 Andras Varga
See the license for distribution terms and warranty disclaimer.

Generates seeds for the LCG32 random number generator. This RNG has a
period length of 2^31-2, which makes about 2,147 million random numbers.
Note that Mersenne Twister is also available in OMNeT++, which has a
practically infinite period length (2^19937).

Usage:
  seedtool i seed         - index of 'seed' in cycle
  seedtool s index        - seed at index 'index' in cycle
  seedtool d seed1 seed2  - distance of 'seed1' and 'seed2' in cycle
  seedtool g seed0 dist   - generate seed 'dist' away from 'seed0'
  seedtool g seed0 dist n - generate 'n' seeds 'dist' apart, starting at 'seed0'
  seedtool t              - generate hashtable
  seedtool p              - print hashtable
</pre>
<p>

<p>The last two options, p and t were used internally to generate
a hash table of pre-computed seeds that greatly speeds up the
tool. For practical use, the g option is the most important.
Suppose you have 4 simulation runs that need two independent
random number generators each and you want to start their seeds
at least 10,000,000 values apart. The first seed value can be
simply 1. You would type the following command:

<pre>
C:\OMNETPP\UTILS&gt; seedtool g 1 10000000 8
</pre>
<p>

<p>The program outputs 8 numbers that can be used as random number
seeds:

<pre>
1768507984
33648008
1082809519
703931312
1856610745
784675296
426676692
1100642647
</pre>
<p>

<p>You would specify these seed values in the ini file.

<p>

<p><H2><A NAME="sec310"/>8.7 Cmdenv: the command-line interface</H2>

<p>The command line user interface<!--command line user interface--> is
a small, portable and fast user interface that compiles and runs on
all platforms. Cmdenv<!--Cmdenv--> is designed primarily for batch execution.

<p>Cmdenv uses simply executes some or all simulation runs that are described
in the configuration file. If one run stops with an error message,
subsequent ones will still be executed. The runs to be executed can be
passed via command-line argument or in the ini file.

<p><H3><A NAME="sec311"/>8.7.1 Command-line switches</H3>

<p>A simulation program built with Cmdenv accepts the following command line
switches<!--command line switches-->:

<p><table>
<TR> <TD align=left>   <tt>-h</tt>
  </TD> <TD align=left>
  The program prints a short help message and the networks
  contained in the executable, then exits.</TD></TR>
<TR> <TD align=left> 
  <tt>-f</tt> <tt>&lt;</tt><i>fileName<tt>&gt;</tt></i>
  </TD> <TD align=left>
  Specify the name of the configuration file.
  The default is <tt>omnetpp.ini</tt><!--omnetpp.ini-->.
  Multiple <tt>-f</tt> switches can be given; this allows you to partition your
  configuration file.  For example, one file can contain your general
  settings, another one most of the module parameters, another one the
  module parameters you change often.</TD></TR>
<TR> <TD align=left> 
  <tt>-l</tt> <tt>&lt;</tt><i>fileName<tt>&gt;</tt></i>
  </TD> <TD align=left>
  Load a shared object<!--shared objects--> (<tt>.so</tt> file on Unix).
  Multiple <tt>-l</tt> switches are accepted. Your <tt>.so</tt> files may contain module
  code etc. By dynamically loading all simple
  module code and compiled network description (<tt>_n.o</tt> files
  on Unix) you can even eliminate the need to re-link the simulation
  program after each change in a source file.  (Shared objects can be
  created with <tt>gcc -shared...</tt>)</TD></TR>
<TR> <TD align=left> 
  <tt>-r</tt> <tt>&lt;</tt><i>runs<tt>&gt;</tt></i>
  </TD> <TD align=left>
  It specifies which runs should be executed (e.g. <tt>-r 2,4,6-8</tt>).
  This option overrides the <tt>runs-to-execute=</tt> option
  in the <tt>[Cmdenv]</tt> section of the ini file<!--ini file-->
  (see later).</TD></TR>
</table>

<p>All other options are read from the configuration file.

<p>An example of running an OMNeT++ executable with the -h flag:

<pre>
% ./fddi -h

OMNeT++/OMNEST Discrete Event Simulation  (C) 1992-2005 Andras Varga
See the license for distribution terms and warranty disclaimer
Setting up Tkenv...

Command line options:
  -h            Print this help and exit.
  -f &lt;inifile&gt;  Use the given ini file instead of omnetpp.ini. Multiple
                -f options are accepted to load several ini files.
  -u &lt;ui&gt;       Selects the user interface. Standard choices are Cmdenv
                and Tkenv. To make a user interface available, you need
                to link the simulation executable with the cmdenv/tkenv
                library, or load it as shared library via the -l option.
  -l &lt;library&gt;  Load the specified shared library (.so or .dll) on startup.
                The file name should be given without the .so or .dll suffix
                (it will be appended automatically.) The loaded module may
                contain simple modules, plugins, etc. Multiple -l options
                can be present.

Tkenv-specific options:
  -r &lt;run&gt;      Set up the given run, specified in a [Run n] section of
                the ini file.

The following components are available:
  module types:
    FDDI_Monitor
    FDDI_Generator4Sniffer
    FDDI_Generator4Ring
    ...

End run of OMNeT++
</pre>
<p>

<p><H3><A NAME="sec312"/>8.7.2 Cmdenv ini file options</H3>
<a name="sec:ch-run-sim:cmdenv-section"></a>

<p>Cmdenv can be executed in two modes, selected by the <tt>express-mode</tt> ini file entry:

<p><ul>
    <li> <b>Normal</b> (non-express) mode is for debugging: detailed information
        will be written to the standard output (event banners, module output,
        etc).
    <li> <b>Express</b> mode can be used for long simulation runs: only
        periodical status update is displayed about the progress of the
        simulation.
</ul>

<p>The full list of ini file options recognized by Cmdenv:

<p><table border>
<TR> <TD align=left>

<p><b>Entry and default value</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=left colspan=2><b>[Cmdenv]</b></TD></TR>
<TR> <TD align=left> <tt>runs-to-execute</tt> = </TD> <TD align=left> Specifies which simulation runs should be executed.
It accepts a comma-separated list of run numbers or run number ranges, e.g.
<tt>1,3-4,7-9</tt>. If the value is missing, Cmdenv executes all runs that have
ini file sections; if no runs are specified in the ini file, Cmdenv does one run.
The -r command line option overrides this ini file setting. </TD></TR>
<TR> <TD align=left> <tt>express-mode</tt>=yes/no (default: no) </TD> <TD align=left> Selects ``normal'' (debug/trace) or ``express'' mode.
</TD></TR>
<TR> <TD align=left> <tt>module-messages</tt>=yes/no (default: yes) </TD> <TD align=left> In normal mode only:
printing module ev&lt;&lt; output on/off </TD></TR>
<TR> <TD align=left> <tt>event-banners</tt>=yes/no (default: yes) </TD> <TD align=left> In normal mode only:
printing event banners on/off </TD></TR>
<TR> <TD align=left> <tt>message-trace</tt>=yes/no (default: no) </TD> <TD align=left> In normal mode only: print a line
about each message sending (by <tt>send()</tt>,<tt>scheduleAt()</tt>, etc)
and delivery on the standard output </TD></TR>
<TR> <TD align=left> <tt>autoflush</tt>=yes/no (default: no) </TD> <TD align=left>  Call <tt>fflush(stdout)</tt> after each
event banner or status update; affects both express and normal mode. Turning on
autoflush can be useful with printf-style debugging for tracking down
program crashes. </TD></TR>
<TR> <TD align=left> <tt>status-frequency</tt>=&lt;integer&gt; (default: 50000) </TD> <TD align=left> In express mode only:
print status update every n events (on today's computers, and
for a typical model, this will produce an update every few seconds,
perhaps a few times per second) </TD></TR>
<TR> <TD align=left> <tt>performance-display</tt>=yes/no (default: yes) </TD> <TD align=left> In express mode only:
print detailed performance information. Turning it on results in a 3-line
entry printed on each update, containing ev/sec, simsec/sec, ev/simsec,
number of messages created/still present/currently scheduled in FES<!--FES-->.
</TD></TR>
<TR> <TD align=left> <tt>extra-stack-kb</tt> = 8 </TD> <TD align=left> Specifies the extra amount of stack
(in kilobytes) that is reserved for each <tt>activity()</tt>
simple module when the simulation is run under Cmdenv.</TD></TR>
</table>

<p>
<H3><A NAME="sec313"/>8.7.3 Interpreting Cmdenv output</H3>
<a name="sec:ch-run-sim:interpreting-cmdenv-output"></a>

<p>When the simulation is running in ``express'' mode with detailed
performance display enabled, Cmdenv periodically outputs a three-line
status info about the progress of the simulation.
The output looks like this:

<pre>
...
** Event #250000   T=123.74354 ( 2m  3s)    Elapsed: 0m 12s
     Speed:     ev/sec=19731.6   simsec/sec=9.80713   ev/simsec=2011.97
     Messages:  created: 55532   present: 6553   in FES: 8
** Event #300000   T=148.55496 ( 2m 28s)    Elapsed: 0m 15s
     Speed:     ev/sec=19584.8   simsec/sec=9.64698   ev/simsec=2030.15
     Messages:  created: 66605   present: 7815   in FES: 7
...
</pre>
<p>
The first line of the status display (beginning with <tt>**</tt>)
contains:

<p><ul>
   <li>how many events have been processed so far
   <li>the current simulation time (T), and
   <li>the elapsed time (wall clock time) since the beginning of the simulation run.
</ul>

<p>The second line displays info about simulation performance:

<p><ul>
   <li><tt>ev/sec</tt> indicates <i>performance</i>: how many events are processed
     in one real-time second.  On one hand it depends on your hardware
     (faster CPUs process more events per second), and on the other hand
     it depends on the complexity (amount of calculations) associated
     with processing one event. For example, protocol simulations tend to require
     more processing per event than e.g. queueing networks, thus
     the latter produce higher ev/sec values.
     In any case, this value is independent of the size (number of modules) in your model.
   <li><tt>simsec/sec</tt> shows <i>relative speed</i> of the simulation, that is,
     how fast the simulation is progressing compared to real time, how many
     simulated seconds can be done in one real second. This value virtuall depends
     on everything: on the hardware, on the size of the simulation model,
     on the complexity of events, and the average simulation time between events as well.
   <li><tt>ev/simsec</tt> is the <i>event density</i>: how many events are
     there per simulated second. Event density only depends on the simulation model,
     regardless of the hardware used to simulate it: in a cell-level ATM simulation
     you'll have very hight values (<i>10<sup>9</sup></i>), while in a bank teller simulation
     this value is probably well under 1. It also depends on the size of your
     model: if you double the number of modules in your model, you can expect
     the event density double, too.
</ul>

<p>The third line displays the number of messages, and it is important
because it may indicate the `health' of your simulation.

<p><ul>
   <li><tt>Created</tt>: total number of message objects created since the
     beginning of the simulation run. This does not mean that this many message
     object actually exist, because some (many) of them may have been deleted
     since then. It also does not mean that <i>you</i> created all those
     messages -- the simulation kernel also creates messages for its own use
     (e.g. to implement <tt>wait()</tt> in an <tt>activity()</tt> simple module).
   <li><tt>Present</tt>: the number of message objects currently present
     in the simulation model, that is, the number of messages created (see above)
     minus the number of messages already deleted. This number includes
     the messages in the FES<!--FES-->.
   <li><tt>In FES</tt>: the number of messages currently scheduled in the
     Future Event Set.
</ul>

<p>
The second value, the number of messages present is more useful than
perhaps one would initially think. It can indicator of the `health' of the simulation:
if it is growing steadily, then either you have a memory leak and losing
messages (which indicates a programming error), or the network you simulate is
overloaded and queues are steadily filling up (which might indicate wrong input
parameters).

<p>Of course, if the number of messages does not increase, it does not mean
that you do <i>not</i> have a memory leak (other memory leaks are also
possible). Nevertheless the value is still useful, because by far the
most common way of leaking memory in a simulation is by not deleting messages.

<p>

<p><H2><A NAME="sec314"/>8.8 Tkenv: the graphical user interface</H2>

<p><p class="subheading">Features</p>

<p>Tkenv<!--Tkenv--> is a portable graphical windowing user interface.
Tkenv supports interactive execution of the simulation, tracing and
debugging<!--simulation!debugging-->. Tkenv is recommended in the
development stage of a simulation or for presentation and educational
purposes, since it allows one to get a detailed picture of the state
of simulation at any point of execution and to follow what happens
inside the network. The most important feaures are:
<ul>
  <li>message flow animation
  <li>graphical display of statistics (histograms etc.) and output
    vectors during simulation execution
  <li>separate window for each module's text output
  <li>scheduled messages can be watched in a window as simulation
    progresses
  <li>event-by-event, normal and fast execution
  <li>labeled breakpoints
  <li>inspector windows to examine and alter objects and variables
    in the model
  <li>simulation can be restarted
  <li>snapshots (detailed report about the model: objects, variables
    etc.)
</ul>

<p>
Tkenv makes it possible to view simulation results (output vectors
etc.) during execution. Results can be displayed as histograms and
time-series diagrams. This can speed up the process of verifying the
correct operation of the simulation program and provides a good
environment for experimenting with the model during execution.  When
used together with <tt>gdb</tt> or <tt>xxgdb</tt>, Tkenv can speed up
debugging a lot.

<p>Tkenv is built with Tcl/Tk, and it work on all platforms where
Tcl/Tk has been ported to: Unix/X, Windows, Macintosh.
You can get more information about Tcl/Tk on the Web pages listed
in the Reference.

<p><H3><A NAME="sec315"/>8.8.1 Command-line switches</H3>

<p>A simulation program built with Tkenv accepts the following command line
switches<!--command line switches-->:

<p><table>
<TR> <TD align=left>   <tt>-h</tt>
  </TD> <TD align=left>
  The program prints a short help message and the networks
  contained in the executable, then exits.</TD></TR>
<TR> <TD align=left> 
  <tt>-f </tt><i>&lt;fileName&gt;</i>
  </TD> <TD align=left>
  Specify the name of the configuration file.
  The default is <tt>omnetpp.ini</tt><!--omnetpp.ini-->.
  Multiple <tt>-f</tt> switches can be given; this allows you to partition your
  configuration file.  For example, one file can contain your general
  settings, another one most of the module parameters, another one the
  module parameters you change often.</TD></TR>
<TR> <TD align=left> 
  <tt>-l </tt><i>&lt;fileName&gt;</i>
  </TD> <TD align=left>
  Load a shared object<!--shared objects--> (<tt>.so</tt> file on Unix).
  Multiple <tt>-l</tt> switches are accepted. Your <tt>.so</tt> files may contain module
  code etc. By dynamically loading all simple
  module code and compiled network description (<tt>_n.o</tt> files
  on Unix) you can even eliminate the need to re-link the simulation
  program after each change in a source file.  (Shared objects can be
  created with <tt>gcc -shared...</tt>)</TD></TR>
<TR> <TD align=left> 
  <tt>-r </tt><i>&lt;run-number&gt;</i>
  </TD> <TD align=left>
  It has the same effect as (but takes priority over) the <tt>[Tkenv]/default-run=</tt>
  ini file entry.

<p></table>

<p><H3><A NAME="sec316"/>8.8.2 Tkenv ini file settings</H3>
<a name="sec:ch-run-sim:tkenv-section"></a>

<p>Tkenv accepts the following settings in the <tt>[Tkenv]</tt> section of the ini file.

<p><table border>
<TR> <TD align=left>

<p><b>Entry and default value</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=center colspan=2><b>[Tkenv]</b></TD></TR>
<TR> <TD align=left> <tt>extra-stack-kb</tt> = 48 </TD> <TD align=left> Specifies the extra amount of stack
(in kilobytes) that is reserved for each <i><tt>activity()</tt></i>
simple module when the simulation is run under Tkenv. This value is
significantly higher than the similar one for Cmdenv -- handling
GUI events requires a large amount of stack space.</TD></TR>
<TR> <TD align=left> <tt>default-run</tt> = 1 </TD> <TD align=left> Specifies which run Tkenv should set up
automatically after startup. If there's no default-run= entry or the
value is 0, Tkenv will ask which run to set up. </TD></TR>
<TR> <TD align=left> </table>

<p>The following configuration entries are of marginal usefulness,
because corresponding settings are also accessible in the
Simulation options dialog in the Tkenv GUI, and the GUI settings
take precedence. Tkenv stores the settings in the
<tt>.tkenvrc</tt> file in the current directory -- the ini file
settings are only used if there is no <tt>.tkenvrc</tt> file.

<p><table border>
<TR> <TD align=left>

<p><b>Entry and default value</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=center colspan=2><b>[Tkenv]</b></TD></TR>
<TR> <TD align=left> <tt>use-mainwindow</tt> = yes </TD> <TD align=left> Enables/disables writing <i>ev</i> output to the Tkenv main window. </TD></TR>
<TR> <TD align=left> <tt>print-banners</tt> = yes </TD> <TD align=left> Enables/disables printing banners for
each event.</TD></TR>
<TR> <TD align=left> <tt>breakpoints-enabled</tt> = yes </TD> <TD align=left> Specifies whether the simulation
should be stopped at each <tt>breakpoint()</tt> call in the
simple modules. </TD></TR>
<TR> <TD align=left> <tt>update-freq-fast</tt> = 10 </TD> <TD align=left> Number of events executed between two
display updates when in <i>Fast</i> execution mode. </TD></TR>
<TR> <TD align=left> <tt>update-freq-express</tt> = 500 </TD> <TD align=left> Number of events executed between
two display updates when in <i>Express</i> execution mode. </TD></TR>
<TR> <TD align=left> <tt>animation-delay</tt> = 0.3s </TD> <TD align=left> Delay between steps when you slow-execute the simulation. </TD></TR>
<TR> <TD align=left> <tt>animation-enabled</tt> = yes </TD> <TD align=left> Enables/disables message flow animation. </TD></TR>
<TR> <TD align=left> <tt>animation-msgnames</tt> = yes </TD> <TD align=left> Enables/disables displaying message names during message flow
animation. </TD></TR>
<TR> <TD align=left> <tt>animation-msgcolors</tt> = yes </TD> <TD align=left> Enables/disables using different colors
for each message kind during message flow animation. </TD></TR>
<TR> <TD align=left> <tt>animation-speed</tt> = 1.0 </TD> <TD align=left> Specifies the speed of message flow animation. </TD></TR>
<TR> <TD align=left> <tt>methodcalls-delay</tt> = </TD> <TD align=left> Sets delay after method call animation. </TD></TR>
<TR> <TD align=left> <tt>show-layouting</tt> = true </TD> <TD align=left> Show layouting process of network graphics. </TD></TR>
<TR> <TD align=left> </table>

<p>
<H3><A NAME="sec317"/>8.8.3 Using the graphical environment</H3>

<p><p class="subheading">Simulation running modes in Tkenv</p>

<p>
Tkenv has the following modes for running the simulation :

<p><ul>
   <li>Step
   <li>Run
   <li>Fast run
   <li>Express run
</ul>

<p>
The running modes have their corresponding buttons on Tkenv's
toolbar.

<p>
In <b>Step</b> mode, you can execute the simulation event-by-event.

<p>In <b>Run</b> mode, the simulation runs with all tracing aids on.
Message animation is active and inspector windows are updated
after each event. Output messages are displayed in the main window
and module output windows. You can stop the simulation with the
Stop button on the toolbar. You can fully interact with the user
interface while the simulation is running: you can open inspectors
etc.

<p>In <b>Fast</b> mode, animation is turned off. The inspectors and
the message output windows are updated after each 10 events (the
actual number can be set in Options|Simulation options and
also in the ini file). Fast mode is several times faster than
the Run mode; the speedup can get close to 10 (or the configured
event count).

<p>In <b>Express</b> mode, the simulation runs at about the same speed
as with Cmdenv, all tracing disabled. Module output is not recorded
in the output windows any more. You can interact with the simulation
only once in a while (1000 events is the default as I recall),
thus the run-time overhead of the user interface is minimal.
You have to explicitly push the Update inspectors button if you
want an update.

<p>Tkenv has a status bar which is regularly updated while the simulation
is running. The gauges displayed are similar to those in Cmdenv,
described in section <a href="#sec313">[8.7.3]</a>.

<p>
<p class="subheading">Inspectors</p>

<p>
In Tkenv, objects can be viewed through inspectors. To start, choose
Inspect|Network from the menu. Usage should be obvious; just
use double-clicks and popup menus that are brought up by
right-clicking. In Step, Run and Fast Run modes, inspectors are
updated automatically as the simulation progresses. To make ordinary
variables (int, double, char etc.) appear in Tkenv, use the
<tt>WATCH()</tt> macro in the C++ code.

<p>Tkenv inspectors also display the object pointer, and can also copy
the pointer value to the clipboard. This can be invaluable for debugging:
when the simulation is running under a debugger like gdb or the MSVC IDE,
you can paste the object pointer into the debugger and have closer look
at the data structures.

<p>
<p class="subheading">Configuring Tkenv</p>

<p>
In case of nonstandard installation, it may be necessary to set the
<tt>OMNETPP_TKENV_DIR</tt> environment variable so that Tkenv can find
its parts written in Tcl script.

<p>The default path from where the icons are loaded can be changed with
the <tt>OMNETPP_BITMAP_PATH</tt> variable, which is a
semicolon-separated list of directories and defaults to
<tt><i>omnetpp-dir</i>/bitmaps;./bitmaps</tt>. (See section
<a href="#"></a> as well).

<p>

<p><p class="subheading">Embedding Tcl code into the executable</p>

<p>A significant part of Tkenv is written in Tcl, in several
<tt>.tcl</tt> script files. The default location of the scripts is
passed compile-time to <tt>tkapp.cc</tt>, and it can be overridden at
run-time by the <tt>OMNETPP_TKENV_DIR</tt> environment variable. The
existence of a separate script library can be inconvenient if you want
to carry standalone simulation executables to different machines. To
solve the problem, there is a possibility to compile the script parts
into Tkenv.

<p>The details: the <tt>tcl2c</tt> program (its C source is there in the
Tkenv directory) is used to translate the <tt>.tcl</tt> files into C
code (<tt>tclcode.cc</tt>), which gets included into
<tt>tkapp.cc</tt>. This possibility is built into the makefiles
and can be optionally enabled.

<p><H3><A NAME="sec318"/>8.8.4 In Memoriam... </H3>

<p>There used to be other windowing user interfaces which have been removed
from the distribution:

<p><ul>
  <li> <b>TVEnv</b>. A Turbo Vision-based user interface, the first
    interactive UI for OMNeT++. Turbo Vision was an excellent
    character-graphical windowing environment, originally shipped with
    Borland C++ 3.1.
  <li> <b>XEnv</b>. A GUI written in pure X/Motif. It was an
    experiment, written before I stumbled into Tcl/Tk and discovered
    its immense productivity in GUI building. XEnv never got too far
    because it was really very-very slow to program in Motif...
</ul>

<p>
<H2><A NAME="sec319"/>8.9 Repeating or iterating simulation runs</H2>

<p>Once your model works reliably, you'll usually want to run several
simulations. You may want to run the model with various
parameter settings, or you may want <i>(should want?)</i> to
run the same model with the same parameter settings but with
different random number generator seeds, to achieve statistically
more reliable results.

<p>Running a simulation several times by hand can easily become tedious,
and then a good solution is to write a control script that
takes care of the task automatically. Unix shell is
a natural language choice to write the control script in,
but other languages like Perl, Matlab/Octave, Tcl, Ruby might also have
justification for this purpose.

<p>The next sections are only for Unix users. We'll use the
Unix `Bourne' shell (<tt>sh</tt>, <tt>bash</tt>) to write the control script.
If you'd prefer Matlab/Octave, the <tt>contrib/octave/</tt> directory
contains example scripts (contributed by Richard Lyon).

<p>
<H3><A NAME="sec320"/>8.9.1 Executing several runs</H3>

<p>In simple cases, you may define all simulation runs needed in the
<tt>[Run 1]</tt>, <tt>[Run 2]</tt>, etc. sections of <tt>omnetpp.ini</tt>,
and invoke your simulation with the -r flag each time.
The -f flag lets you use a file name different from <tt>omnetpp.ini</tt>.

<p>The following script executes a simulation named <tt>wireless</tt>
several times, with parameters for the different runs
given in the <tt>runs.ini</tt> file.

<pre>
#! /bin/sh
./wireless -f runs.ini -r 1
./wireless -f runs.ini -r 2
./wireless -f runs.ini -r 3
./wireless -f runs.ini -r 4
...
./wireless -f runs.ini -r 10
</pre>
<p>
To run the above script, type it in a text file called e.g. <tt>run</tt>,
give it <tt>x</tt> (executable) permission using <tt>chmod</tt>,
then you can execute it by typing <tt>./run</tt>:

<pre>
% chmod +x run
% ./run
</pre>
<p>
You can simplify the above script by using a <i>for</i> loop.
In the example below, the variable <tt>i</tt> iterates through
the values of list given after the <tt>in</tt> keyword.
It is very practical, since you can leave out or add runs,
or change the order of runs by simply editing the list --
to demonstrate this, we skip run 6, and include run 15 instead.

<pre>
#! /bin/sh
for i in 3 2 1 4 5 7 15 8 9 10; do
   ./wireless -f runs.ini -r $i
done
</pre>
<p>
If you have many runs, you can use a C-style loop:

<pre>
#! /bin/sh
for ((i=1; $i&lt;50; i++)); do
   ./wireless -f runs.ini -r $i
done
</pre>
<p>

<p><H3><A NAME="sec321"/>8.9.2 Variations over parameter values</H3>

<p>It may not be practical to hand-write descriptions of all runs
in an ini file, especially if there are many parameter
settings to try, or you want to try all possible
combinations of two or more parameters.
The solution might be to generate only a small fraction
of the ini file with the variable parameters, and
use it via ini file inclusion. For example, you might
write your <tt>omnetpp.ini</tt> like this:

<pre>
[General]
network = Wireless

[Parameters]
Wireless.n = 10
...   # other fixed parameters
include params.ini  # include variable part
</pre>
<p>
And have the following as control script. It uses two nested loops to explore
all possible combinations of the <i>alpha</i> and <i>beta</i> parameters.
Note that <tt>params.ini</tt> is created by redirecting the <tt>echo</tt>
output into file, using the <tt>&gt;</tt> and <tt>&gt;&gt;</tt> operators.

<pre>
#! /bin/sh
for alpha in 1 2 5 10 20 50; do
   for beta in 0.1 0.2 0.3 0.4 0.5; do
       echo "Wireless.alpha=$alpha" &gt; params.ini
       echo "Wireless.beta=$beta" &gt;&gt; params.ini
       ./wireless
   done
done
</pre>
<p>

<p>As a heavy-weight example, here's the ``runall'' script of
Joel Sherrill's <i>File System Simulator</i>. It also demonstrates
that loops can iterate over string values too, not just numbers.
(<tt>omnetpp.ini</tt> includes the generated <tt>algorithms.ini</tt>.)

<p>Note that instead of redirecting every <tt>echo</tt> command to file,
they are grouped using parentheses, and redirected together.
The net effect is the same, but you can spare some typing this way.

<pre>
#! /bin/bash
#
# This script runs multiple variations of the file system simulator.
#
all_cache_managers="NoCache FIFOCache LRUCache PriorityLRUCache..."
all_schedulers="FIFOScheduler SSTFScheduler CScanScheduler..."

for c in ${all_cache_managers}; do
  for s in ${all_schedulers}; do
  (
    echo "[Parameters]"
    echo "filesystem.generator_type = \"GenerateFromFile\""
    echo "filesystem.iolibrary_type = \"PassThroughIOLibrary\""
    echo "filesystem.syscalliface_type = \"PassThroughSysCallIface\""
    echo "filesystem.filesystem_type = \"PassThroughFileSystem\""
    echo "filesystem.cache_type = \"${c}\""
    echo "filesystem.blocktranslator_type = \"NoTranslation\""
    echo "filesystem.diskscheduler_type = \"${s}\""
    echo "filesystem.accessmanager_type = \"MutexAccessManager\""
    echo "filesystem.physicaldisk_type = \"HP97560Disk\""
  ) &gt;algorithms.ini

  ./filesystem
  done
done
</pre>
<p>

<p>
<H3><A NAME="sec322"/>8.9.3 Variations over seed value (multiple independent runs)</H3>

<p>The same kind of control script can be used if you want to execute
several runs with different random seeds<!--random!seeds-->.
The following code does 500 runs with independent seeds.
(<tt>omnetpp.ini</tt> should include <tt>parameters.ini</tt>.)

<p>The seeds are 10 million numbers apart in the sequence (<tt>seedtool</tt>
parameter), so one run should not use more random numbers than this,
otherwise there will be overlaps in the sequences and the runs
will not be independent.

<pre>
#! /bin/sh
seedtool g 1 10000000 500 &gt; seeds.txt
for seed in `cat seeds.txt`; do
   (
     echo "[General]"
     echo "random-seed = ${seed}"
     echo "output-vector-file = xcube-${seed}.vec"
   ) &gt; parameters.ini
   ./xcube
done
</pre>
<p>

<p>

<p>
<H2><A NAME="sec323"/>8.10 Akaroa support: Multiple Replications in Parallel</H2>
<a name="sec:ch-run-sim:akaroa"></a>
<!--Akaroa-->
<!--Multiple Replications in Parallel-->

<p><H3><A NAME="sec324"/>8.10.1 Introduction</H3>

<p>Typical simulations are Monte-Carlo simulations: they use
(pseudo-)random numbers to drive the simulation model.
For the simulation to produce statistically reliable results,
one has to carefully consider the following:

<p><ul>
  <li>When is the initial transient over, when can we start
    collecting data? We usually do not want to include the
    initial transient when the simulation is still ``warming up.''
  <li>When can we stop the simulation? We want to wait long enough
    so that the statistics we are collecting can ``stabilize'',
    can reach the required sample size to be statistically trustable.
</ul>

<p>Neither questions are trivial to answer. One might just suggest
to wait ``very long'' or ``long enough''. However, this is neither
simple (how do you know what is ``long enough''?) nor practical
(even with today's high speed processors simulations of modest complexity
can take hours, and one may not afford multiplying runtimes by,
say, 10, ``just to be safe.'') If you need further convincing,
please read [<a href="#bib-Pawlikowsky02">Pawlikowsky02</a>] and be horrified.

<p>A possible solution is to look at the statistics while the simulation
is running, and decide at runtime when enough data have been
collected for the results to have reached the required accuracy.
One possible criterion is given by the confidence level,
more precisely, by its width relative to the mean.
But ex ante it is unknown how many observations have to be collected
to achieve this level -- it must be determined runtime.

<p>
<H3><A NAME="sec325"/>8.10.2 What is Akaroa</H3>

<p>Akaroa [<a href="#bib-Akaroa99">Akaroa99</a>] addresses the above problem.
According to its authors, Akaroa (Akaroa2) is a ``fully automated
simulation tool designed for running distributed stochastic simulations
in MRIP scenario'' in a cluster computing environment.

<p>MRIP stands for <i>Multiple Replications in Parallel</i>.
In MRIP, the computers of the cluster run independent replications
of the whole simulation process (i.e. with the same parameters but
different seed for the RNGs (random number generators)),
generating statistically equivalent streams of simulation output data.
These data streams are fed to a global data analyser responsible for
analysis of the final results and for stopping the simulation
when the results reach a satisfactory accuracy.

<p>The independent simulation processes run independently of one another
and continuously send their observations to the central analyser
and control process. This process <i>combines</i> the independent data streams,
and calculates from these observations an overall estimate of the mean value
of each parameter.
Akaroa2 decides by a given confidence level and precision
whether it has enough observations or not. When it judges that is
has enough observations it halts the simulation.

<p>If <i>n</i> processors are used, the needed simulation execution time
is usually <i>n</i> times smaller compared to a one-processor
simulation (the required number of observations are produced sooner).
Thus, the simulation would be sped up approximately in proportion
to the number of processors used and sometimes even more.

<p>Akaroa was designed at the University of Canterbury in Christchurch, New Zealand
and can be used free of charge for teaching and non-profit research activities.

<p>
<H3><A NAME="sec326"/>8.10.3 Using Akaroa with OMNeT++</H3>

<p><p class="subheading">Akaroa</p>

<p>Before the simulation can be run in parallel under Akaroa, you have to
start up the system:

<p><ul>
  <li>Start <tt>akmaster</tt> running in the background on some host.
  <li>On each host where you want to run a simulation engine,
     start <tt>akslave</tt> in the background.
</ul>

<p>Each <tt>akslave</tt> establishes a connection with the <tt>akmaster</tt>.

<p>Then you use <tt>akrun</tt> to start a simulation. <tt>akrun</tt> waits
for the simulation to complete, and writes a report of the results
to the standard output. The basic usage of the <tt>akrun</tt> command is:

<pre>
akrun -n num_hosts command [argument..]
</pre>
<p>
where <i>command</i> is the name of the simulation you want to start.
Parameters for Akaroa are read from the file named <tt>Akaroa</tt> in
the working directory. Collected data from the processes are
sent to the <tt>akmaster</tt> process, and when the required precision
has been reached, <tt>akmaster</tt> tells the simulation processes to
terminate. The results are written to the standard output.

<p>The above description is not detailed enough help you
set up and successfully use Akaroa -- for that you need to read the
Akaroa manual.

<p><p class="subheading">Configuring OMNeT++ for Akaroa</p>

<p>First of all, you have to compile OMNeT++ with Akaroa support enabled.

<p>The OMNeT++ simulation must be configured in <tt>omnetpp.ini</tt>
so that it passes the observations to Akaroa. The simulation model itself does
not need to be changed -- it continues to write
the observations into output vectors (<tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects,
see chapter <a href="#sec223">[6]</a>). You can place some of
the output vectors under Akaroa control.

<p>You need to add the following to <tt>omnetpp.ini</tt>:

<pre>
[General]
rng-class="cAkaroaRNG"
outputvectormanager-class="cAkOutputVectorManager"
</pre>
<p>
These lines cause the simulation to obtain random numbers from Akaroa,
and allows data written to selected output vectors to be passed to Akaroa's
global data analyser.
    <br><ul><font size=-1>[For more details on the plugin mechanism these settings make use of,
    see section <a href="#sec397">[13.5.3]</a>.]</font></ul>

<p>Akaroa's RNG is a Combined Multiple Recursive pseudorandom
number generator (CMRG) with a period of approximately <i>2<sup>191</sup></i>
random numbers, and provides a unique stream of random numbers
for every simulation engine. It is vital to obtain random numbers
from Akaroa: otherwise, all simulation processes would run with the same
RNG seeds, and produce exactly the same results!

<p>Then you need to specify which output vectors you want to
be under Akaroa control. By default, all output vectors are under Akaroa
control; the

<pre>
&lt;modulename&gt;.&lt;vectorname&gt;.akaroa=false
</pre>
<p>
setting can be used to make Akaroa ignore specific vectors.
You can use the <tt>*</tt>, <tt>**</tt> wildcards here (see
section <a href="#sec300">[8.4.2]</a>). For example,
if you only want a few vectors be placed under Akaroa,
you can use the following trick:

<pre>
&lt;modulename&gt;.&lt;vectorname1&gt;.akaroa=true
&lt;modulename&gt;.&lt;vectorname2&gt;.akaroa=true
...
**.*.akaroa=false  # catches everything not matched above
</pre>
<p>

<p><p class="subheading">Using shared file systems</p>
<a name="sec:run-sim:using-shared-filesystems"></a>

<p>It is usually practical to have the same physical disk mounted (e.g. via NFS or Samba)
on all computers in the cluster. However, because all OMNeT++ simulation
processes run with the same settings, they would overwrite each other's
output files (e.g. <tt>omnetpp.vec</tt>, <tt>omnetpp.sca</tt>).
Your can prevent this from happening using the
<tt>fname-append-host</tt> ini file entry:

<pre>
[General]
fname-append-host=yes
</pre>
<p>
When turned on, it appends the host name to the names of the output
files (output vector, output scalar, snapshot files).

<p>

<p><H2><A NAME="sec327"/>8.11 Typical issues</H2>

<p><H3><A NAME="sec328"/>8.11.1 Stack problems</H3>

<p><p class="subheading">``Stack violation (<i>FooModule</i> stack too small?) in module <i>bar.foo</i>''</p>
<!--stack!too small-->

<p>OMNeT++ detected that the module has used more stack space than it has
allocated. The solution is to increase the stack for that module type.
You can call the <tt>stackUsage()</tt> from <tt>finish()</tt> to find out
actually how much stack the module used.

<p>
<p class="subheading">``Error: Cannot allocate <i>nn</i> bytes stack for module <i>foo.bar''</i></p>

<p>The resolution depends on whether you are using OMNeT++ on Unix or on Windows.

<p><b>Unix.</b>
If you get the above message, you have to increase the total stack
size<!--stack!size--> (the sum of all coroutine stacks). You can do
so in <tt>omnetpp.ini</tt>:

<pre>
[General]
total-stack-kb = 2048 # 2MB
</pre>
<p>
There is no penalty if you set <tt>total-stack-kb</tt> too high. I
recommend to set it to a few K less than the maximum process stack
size allowed by the operating system (<tt>ulimit -s</tt>; see
next section).

<p>
<b>Windows.</b>
You need to set a <i>low</i> (!) ``reserved stack size''
in the linker options, for example 64K (/stack:65536 linker flag) will do.
The ``reserved stack size'' is an attribute in the Windows exe
files' internal header. It can be set from the linker, or with
the <tt>editbin</tt> Microsoft utility. You can use the <tt>opp_stacktool</tt>
program (which relies on another Microsoft utility called <tt>dumpbin</tt>)
to display reserved stack size for executables.

<p>You need a low reserved stack size because the Win32 Fiber API
which is the mechanism underlying <tt>activity()</tt> uses
this number as coroutine stack size, and with 1MB being the default,
it is easy to run out of the 2GB possible address space (2GB/1MB=2048).

<p>A more detailed explanation follows.
Each fiber has its own stack, by default 1MB (this is the ``reserved''
stack space -- i.e. reserved in the address space, but not the full
1MB is actually ``committed'', i.e. has physical memory assigned to it).
This means that a 2GB address space will run out after 2048 fibers,
which is way too few. (In practice, you won't even be able to create
this many fibers, because physical memory is also a limiting factor).
Therefore, the 1MB reserved stack size (RSS) must be set to a smaller
value: the coroutine stack size requested for the module, plus
the <tt>extra-stack-kb</tt> amount for Cmdenv/Tkenv -- which makes
about 16K with Cmdenv, and about 48K when using Tkenv.
Unfortunately, the CreateFiber() Win32 API doesn't allow the RSS to be
specified. The more advanced CreateFiberEx() API which accepts RSS as
parameter is unfortunately only available from Windows XP.

<p>The alternative is the stacksize parameter stored in the EXE header,
which can be set
via the STACKSIZE .def file parameter, via the /stack linker option,
or on an existing executable using the editbin /stack utility.
This parameter specifies a common RSS for the main program stack,
fiber and thread stacks. 64K should be enough. This is the way
simulation executable should be created: linked with the /stack:65536
option, or the /stack:65536 parameter applied using editbin later.
For example, after applying the editbin /stacksize:65536 command to
dyna.exe, I was able to successfully run the Dyna sample with 8000
Client modules on my Win2K PC with 256M RAM (that means about 12000
modules at runtime, including about 4000 dynamically created modules.)

<p>
<p class="subheading">``Segmentation fault''</p>

<p>On Unix, if you set the total stack size higher, you may get a
segmentation fault during network setup<!--segmentation fault--> (or
during execution if you use dynamically created modules) for exceeding
the operating system limit for maximum stack size. For example, in
Linux 2.4.x, the default stack limit is 8192K (that is, 8MB). The
<tt>ulimit</tt> shell command can be used to modify the
resource limits, and you can raise the allowed maximum stack size
up to 64M.

<pre>
$ ulimit -s 65500
$ ulimit -s
65500
</pre>
<p>
Further increase is only possible if you're root.
Resource limits are inherited by child processes.
The following sequence can be used under Linux to get a shell with
256M stack limit:

<pre>
$ su root
Password:
# ulimit -s 262144
# su andras
$ ulimit -s
262144
</pre>
<p>
If you do not want to go through the above process at each login, you
can change the limit in the PAM configuration files. In Redhat Linux
(maybe other systems too), add the following line to
<tt>/etc/pam.d/login</tt>:

<pre>
session    required    /lib/security/pam_limits.so
</pre>
<p>
and the following line to <tt>/etc/security/limits.conf</tt>:

<pre>
*    hard    stack    65536
</pre>
<p>
<p>
A more drastic solution is to recompile the kernel with a larger stack
limit. Edit <tt>/usr/src/linux/include/linux/sched.h</tt> and increase
<tt>_STK_LIM</tt> from <tt>(8*1024*1024)</tt> to <tt>(64*1024*1024)</tt>.
</p>

<p>Finally, it you're tight with memory, you can switch to Cmdenv. Tkenv
increases the stack size of each module by about 32K<!--stack!for
  Tkenv--> so that user interface code that is called from a
simple module's context can be safely executed.
Cmdenv does not need that much extra stack.

<p>
<p class="subheading">Eventually...</p>

<p>Once you get to the point where you have to adjust the total stack size
to get your program running,
you should probably consider transforming (some of) your <tt>activity()</tt>
simple modules to <tt>handleMessage()</tt>. <tt>activity()</tt> does not
scale well for large simulations.

<p>

<p><H3><A NAME="sec329"/>8.11.2 Memory leaks and crashes</H3>

<p>The most common problems in C++ are associated with memory allocation
(usage of <tt>new</tt> and <tt>delete</tt>):

<p><ul>
   <li><i>memory leaks,</i> that is, forgetting to delete objects
     or memory blocks no longer used;
   <li><i>crashes,</i> usually due to referring to an already deleted
     object or memory block, or trying to delete one for a second time;
   <li><i>heap corruption</i> (enventually leading to crash) due to
     overrunning allocated blocks, i.e. writing past the end of an allocated
     array.
</ul>

<p>By far the most common ways leaking memory in simulation programs
is by not deleting messages (<tt><a href="../api/classcMessage.html">cMessage</a></tt> objects or subclasses).
Both Tkenv and Cmdenv are able to display the number of messages
currently in the simulation,
see e.g. section <a href="#sec313">[8.7.3]</a>.
If you find that the number of messages is steadily increasing,
you need to find where the message objects are. You can do so
by selecting <i>Inspect|From list of all objects...</i> from
the Tkenv menu, and reviewing the list in the dialog that pops up.
(If the model is large, it may take a while for the dialog to appear.)

<p>If the number of messages is stable, it is still possible
you're leaking other <tt><a href="../api/classcObject.html">cObject</a></tt>-based objects. You can
also find them using Tkenv's <i>Inspect|From list of all objects...</i>
function.

<p>If you're leaking non-<tt><a href="../api/classcObject.html">cObject</a></tt>-based objects or just
memory blocks (<tt>struct</tt>s, <tt>int</tt>/<tt>double</tt>/<tt>struct</tt> arrays,
etc, allocated by <tt>new</tt>), you cannot find them via Tkenv.
You'll probably need a specialized memory debugging tool like
the ones described below.

<p><p class="subheading">Memory debugging tools</p>

<p>If you suspect that you may have memory allocation problems
(crashes associated with double-deletion or accessing already
deleted block, or memory leaks), you can use specialized tools
to track them down.

<p>By far the most efficient, most robust and most versatile tool
is <i>Valgrind</i>, originally developed for debugging KDE.

<p>Other memory debuggers are <i>NJAMD</i>, <i>MemProf</i>,
<i>MPatrol</i>, <i>dmalloc</i> and <i>ElectricFence</i>.
Most of the above tools support tracking down memory leaks as well as
detecting double deletion, writing past the end of an allocated block, etc.

<p>A proven commercial tool <i>Rational Purify</i>. It has
a good reputation and proved its usefulness many times.

<p>



<p><H3><A NAME="sec330"/>8.11.3 Simulation executes slowly</H3>

<p>What can you do if the simulation executes much slower than you expect?
The best advice that can be given here is that you should
<b>use a good profiler</b> to find out how much time is spent in each
part of the program. Do not make the mistake of omitting this step,
thinking that you know "which part is slow"! Even for experienced
programmers, profiling session is all too often full of surprises.
It often turns out that lots of CPU time is spent in completely
innocent-looking statements, while the big and complex algorithm
doesn't take nearly as much time as expected. <i>Don't assume anything
-- profile before you optimize!</i>
    <br><ul><font size=-1>[And before blaming the simulation kernel for poor performance...]</font></ul>

<p>A really impressive profiler on Linux is the <i>Valgrind</i>-based
<i>callgrind</i>, and its visualizer <i>KCachegrind</i>.
Unfortunately it won't be ported to Windows anytime soon.
On Windows, you're out of luck -- commercial products may help, or,
port your simulation to Linux. The latter goes usually much smoother
than one would expect.

<p>



</BODY>
</HTML>
<hr><hr><H1><A NAME="sec331"/>9 Network Graphics And Animation</H1>
<a name="cha:graphics"></a>

<p><H2><A NAME="sec332"/>9.1 Display strings</H2>
<a name="sec:ch-graphics:display-strings"></a>

<p><H3><A NAME="sec333"/>9.1.1 Display string syntax</H3>

<p>Display strings<!--display strings--> specify the arrangement and
appearance of modules in graphical user interfaces (currently only
Tkenv): they control how the objects (compound modules, their
submodules and connections) are displayed. Display strings occur in
NED description's <tt>display:</tt>
phrases.

<p>The display string format is a semicolon-separated list of tags.
Each tag consists of a key (usually one letter), an equal sign
and a comma-separated list of parameters, like:

<pre>
  "p=100,100;b=60,10,rect;o=blue,black,2"
</pre>
<p>
Parameters may be omitted also at the end and also inside the
parameter list, like:

<pre>
  "p=100,100;b=,,rect;o=blue,black"
</pre>
<p>
Module/submodule parameters can be included with the <tt>$name</tt> notation:

<pre>
  "p=$xpos,$ypos;b=rect,60,10;o=$fillcolor,black,2"
</pre>
<p>
Objects that may have display strings are:
<ul>
  <li> <i>submodules</i> -- display string may contain position, arrangement
        (for module vectors), icon, icon color, auxiliary icon, status text,
        communication range (as circle or filled circle), etc.
  <li> <i>connections</i> -- display string can specify positioning, arrow color,
        arrow thickness
  <li> <i>compound modules</i> -- display string can specify background color,
        border color, border thickness
  <li> <i>messages</i> -- display string can specify icon, icon color, etc.
</ul>

<p>The following NED sample shows where to place display strings in the code.

<p><pre>
<b>module</b> ClientServer
    <b>submodules</b>:
        pc: Host;
            <b>display</b>: "p=66,55;i=comp"; // position and icon
        server: Server;
            <b>display</b>: "p=135,73;i=server1";
    <b>connections</b>:
        pc.out --&gt; server.in
            <b>display</b> "m=m,61,40,41,28"; // note missing ":"
        server.out --&gt; pc.in
            <b>display</b> "m=m,15,57,35,69";
    <b>display</b>: "o=#ffffff"; // affects background
<b>endmodule</b>
</pre>

<p>
<H3><A NAME="sec334"/>9.1.2 Submodule display strings</H3>

<p>
The following table lists the tags used in submodule display strings:

<p><!--display strings!tags-->

<p><table border>
<TR> <TD align=left>

<b>Tag</b> </TD> <TD align=left> <b>Meaning</b> </TD></TR>
<TR> <TD align=left> <b>p=</b><i>xpos</i>,<i>ypos</i>
</TD> <TD align=left>
 Place submodule at (<i>xpos</i>,<i>ypos</i>) pixel position,
with the origin being the top-left corner of the enclosing module.

<p>Defaults: an appropriate automatic layout is where submodules do not overlap.

<p>If applied to a submodule vector, <i>ring</i> or <i>row</i> layout is
selected automatically.</TD></TR>
<TR> <TD align=left> <b>p=</b><i>xpos</i>,<i>ypos</i>,<b>row</b>,<i>deltax</i> </TD> <TD align=left>
 Used for module vectors. Arranges submodules in a row starting
at (<i>xpos</i>,<i>ypos</i>), keeping <i>deltax</i> distances.

<p>Defaults: <i>deltax</i> is chosen so that submodules do not overlap.

<p><b>row</b> may be abbreviated as <b>r</b>.</TD></TR>
<TR> <TD align=left> <b>p=</b><i>xpos</i>,<i>ypos</i>,<b>column</b>,<i>deltay</i>
</TD> <TD align=left>
 Used for module vectors. Arranges submodules in a column starting
at (<i>xpos</i>,<i>ypos</i>), keeping <i>deltay</i> distances.

<p>Defaults: <i>deltay</i> is chosen so that submodules do not overlap.

<p><b>column</b> may be abbreviated as <b>col</b> or <b>c</b>.</TD></TR>
<TR> <TD align=left> <b>p=</b><i>xpos</i>,<i>ypos</i>,<b>matrix</b>,
<i>itemsperrow</i>,<i>deltax</i>,<i>deltay</i>
</TD> <TD align=left>
 Used for module vectors. Arranges submodules in a matrix starting
at (<i>xpos</i>,<i>ypos</i>), at most <i>itemsperrow</i> submodules in
a row, keeping <i>deltax</i> and <i>deltay</i> distances.

<p>Defaults: <i>itemsperrow</i>=5, <i>deltax,deltay</i> are chosen so that
submodules do not overlap.

<p><b>matrix</b> may be abbreviated as <b>m</b>.</TD></TR>
<TR> <TD align=left> <b>p=</b><i>xpos</i>,<i>ypos</i>,<b>ring</b>,<i>width,height</i>
</TD> <TD align=left>
 Used for module vectors. Arranges submodules in an ellipse,
with the top-left corner of the ellipse's bounding box at (<i>xpos</i>,<i>ypos</i>),
with the <i>width</i> and <i>height</i>.

<p>Defaults: <i>width,height</i> are chosen so that submodules do not overlap.

<p><b>ring</b> may be abbreviated as <b>ri</b>.</TD></TR>
<TR> <TD align=left> <b>p=</b><i>xpos</i>,<i>ypos</i>,<b>exact</b>,<i>deltax</i>,<i>deltay</i>
</TD> <TD align=left>
 Used for module vectors. Each submodule is placed at
<i>(xpos+deltax</i>, <i>ypos+deltay)</i>.
This is useful if <i>deltax</i> and <i>deltay</i> are parameters
 (e.g.:<i>''p=100,100,exact,$x,$y''</i>)
which take different values for each module in the vector.

<p>Defaults: <i>none</i>

<p><b>exact</b> may be abbreviated as <b>e</b> or <b>x</b>.</TD></TR>
<TR> <TD align=left> <b>b=</b><i>width</i>,<i>height</i>,<b>rect</b>
</TD> <TD align=left>
 Rectangle with the given <i>height</i> and <i>width</i>.

<p>Defaults: <i>width</i>=40, <i>height</i>=24</TD></TR>
<TR> <TD align=left> <b>b=</b><i>width</i>,<i>height</i>,<b>oval</b>
</TD> <TD align=left>
 Ellipse with the given <i>height</i> and <i>width</i>.

<p>Defaults: <i>width</i>=40, <i>height</i>=24</TD></TR>
<TR> <TD align=left> <b>o=</b><i>fillcolor</i>,<i>outlinecolor</i>,<i>borderwidth</i>
</TD> <TD align=left>
 Specifies options for the rectangle or oval.
For color notation, see section <a href="#sec338">[9.2]</a>.

<p>Defaults: <i>fillcolor</i>=#8080ff (a lightblue), <i>outlinecolor</i>=black,
<i>borderwidth</i>=2</TD></TR>
<TR> <TD align=left> <b>i=</b><i>iconname</i>,<i>color</i>,<i>percentage</i>
</TD> <TD align=left>
 Use the named icon. It can be colorized, and percentage
specifies the amount of colorization.

<p>Defaults: <i>iconname</i>: no default -- if no icon name is present, <i>box</i> is used;
<i>color</i>: no coloring; <i>percentage</i>: 30%</TD></TR>
<TR> <TD align=left> <b>is=</b><i>size</i>
</TD> <TD align=left>
 Specifies the size of the icon. <i>size</i> can be one of
<tt>l</tt>, <tt>vl</tt>, <tt>s</tt> and <tt>vs</tt> (for large, very large, small, very small).
If this option is present, size cannot be included in the icon name (<tt>"i="</tt> tag)
with the <tt>"i=<i>&lt;iconname&gt;</i>_<i>&lt;size&gt;</i>"</tt> notation.</TD></TR>
<TR> <TD align=left> <b>i2=</b><i>iconname</i>,<i>color</i>,<i>percentage</i>
</TD> <TD align=left>
 Displays a small "modifier" icon at the top right corner of the primary icon.
Suggested icons are <tt>status/busy</tt>, <tt>status/down</tt>, <tt>status/up</tt>,
<tt>status/asleep</tt>, etc.

<p>The arguments are analoguous with those of <tt>"i="</tt>.</TD></TR>
<TR> <TD align=left> <b>r=</b><i>radius</i>,<i>fillcolor</i>,<i>color</i>,<i>width</i>
</TD> <TD align=left>
 Draws a circle (or a filled circle) around the submodule with
the given radius. It can be used to visualize transmission range of
wireless nodes.

<p>Defaults: <i>radius</i>=100, <i>fillcolor</i>=none, <i>color</i>=black,
<i>width</i>=1 (unfilled black circle)</TD></TR>
<TR> <TD align=left> <b>q=</b><i>queue-object-name</i>
</TD> <TD align=left>
 Displays the queue length next to submodule icon.
It expects a <tt><a href="../api/classcQueue.html">cQueue</a></tt> object's name (as set by the <tt>setName()</tt>
method, see section <a href="#sec228">[6.1.4]</a>). Tkenv will do a depth-first
search to find the object, and it will find the queue object within submodules
as well.</TD></TR>
<TR> <TD align=left> <b>t=</b><i>text</i>,<i>pos</i>,<i>color</i>
</TD> <TD align=left>
 Displays a short text above or next to the icon.
The text is meant to convey status information
(<i>"up"</i>, <i>"down"</i>, <i>"5Kb in buffer"</i>) or statistics
(<i>"4 pks received"</i>). <i>pos</i> can be <tt>"l"</tt>, <tt>"r"</tt> or <tt>"t"</tt>
for left, right and top.

<p>
Defaults: <i>pos</i>="t", <i>color</i>=blue</TD></TR>
<TR> <TD align=left> <b>tt=</b><i>tooltip-text</i>
</TD> <TD align=left>
 Displays the given text in a tooltip when the user moves
the mouse over the icon. This complements the <tt>t=</tt> tag, and
lets you display more information that otherwise would not fit on the
screen. </TD></TR>
<TR> <TD align=left> 
</table>

<p>Examples:

<pre>
  "p=100,60;i=workstation"
  "p=100,60;b=30,30,rect;o=4"
</pre>
<p>

<p>
<H3><A NAME="sec335"/>9.1.3 Background display strings</H3>

<p>Compound module display strings specify the background. They can contain
the following tags:

<p>
<table border>
<TR> <TD align=left>

<b>Tag</b> </TD> <TD align=left> <b>Meaning</b></TD></TR>
<TR> <TD align=left>
<b>p=</b><i>xpos</i>,<i>ypos</i> </TD> <TD align=left> Place enclosing module at
(<i>xpos</i>,<i>ypos</i>) pixel position, with (0,0) being
the top-left corner of the window.</TD></TR>
<TR> <TD align=left> <b>b=</b><i>width</i>,<i>height</i>,<b>rect</b>
</TD> <TD align=left>
 Display enclosing module as a rectangle with the given <i>height</i>
and <i>width</i>.

<p>Defaults: <i>width,</i> <i>height</i> are chosen automatically</TD></TR>
<TR> <TD align=left> <b>b=</b><i>width</i>,<i>height</i>,<b>oval</b>
</TD> <TD align=left>
 Display enclosing module as an ellipse with the given <i>height</i>
and <i>width</i>.

<p>Defaults: <i>width,</i> <i>height</i> are chosen automatically</TD></TR>
<TR> <TD align=left> <b>o=</b><i>fillcolor</i>,<i>outlinecolor</i>,<i>borderwidth</i>
</TD> <TD align=left>
 Specifies options for the rectangle or oval.
For color notation, see section <a href="#sec338">[9.2]</a>.

<p>Defaults: <i>fillcolor</i>=#8080ff (a lightblue), <i>outlinecolor</i>=black,
<i>borderwidth</i>=2</TD></TR>
<TR> <TD align=left> <b>tt=</b><i>tooltip-text</i>
</TD> <TD align=left>
 Displays the given text in a tooltip when the user moves
the mouse over the module name in the top-left corner. </TD></TR>
</table>

<p>
<H3><A NAME="sec336"/>9.1.4 Connection display strings</H3>

<p>Tags that can be used in connection display strings:

<p><table border>
<TR> <TD align=left>

<b>Tag</b> </TD> <TD align=left> <b>Meaning</b></TD></TR>
<TR> <TD align=left> <b>m=auto</b> <br>
<b>m=north</b> <br>
<b>m=west</b> <br>
<b>m=east</b> <br>
<b>m=south</b>
</TD> <TD align=left>
Drawing mode. Specifies the exact placement of the connection
arrow. The arguments can be abbreviated as a,e,w,n,s.</TD></TR>
<TR> <TD align=left>  <b>m=manual</b>,<i>srcpx</i>,<i>srcpy</i>,<i>destpx</i>,<i>destpy</i>
</TD> <TD align=left>
 The manual mode takes four parameters that explicitly specify
anchoring of the ends of the arrow: <i>srcpx</i>, <i>srcpy</i>,
<i>destpx</i>, <i>destpy</i>.
Each value is a percentage of the width/height of the source/destination
module's enclosing rectangle, with the upper-left corner being
the origin. Thus,
<pre>
m=m,50,50,50,50
</pre>
would connect the centers of the two module rectangles.</TD></TR>
<TR> <TD align=left> <b>o=</b><i>color</i>,<i>width</i> </TD> <TD align=left>
Specifies the appearance of the arrow.
For color notation, see section <a href="#sec338">[9.2]</a>.

<p>Defaults: <i>color</i>=black, <i>width</i>=2</TD></TR>
<TR> <TD align=left> <b>t=</b><i>text</i>,<i>color</i>
</TD> <TD align=left>
 Displays a short text near the connection arrow.
The text may convey status information or connection properties
(<i>"down"</i>, <i>"100Mb"</i>) or statistics.

<p>
Defaults: <i>color</i>=#005030</TD></TR>
<TR> <TD align=left> <b>tt=</b><i>tooltip-text</i>
</TD> <TD align=left>
 Displays the given text in a tooltip when the user moves
the mouse over the connection arrow. This complements the <tt>t=</tt> tag, and
lets you display more information that otherwise would not fit on the
screen. </TD></TR>
</table>

<p>
Examples:
<pre>
  "m=a;o=blue,3"
</pre>

<p>
<H3><A NAME="sec337"/>9.1.5 Message display strings</H3>

<p>Message objects do not store a display string by default, but you can redefine
the <tt><a href="../api/classcMessage.html">cMessage</a></tt>'s <tt>displayString()</tt> method and make it return
one.

<pre>
const char *CustomPacket::displayString() const
{
    return "i=msg/packet_vs";
}
</pre>
<p>
This display string affects how messages are shown during animation.
By default, they are displayed as a small filled circle, in one of
8 basic colors (the color is determined as <i>message kind modulo 8</i>),
and with the message class and/or name displayed under it
The latter is configurable in the Tkenv Options dialog, and message kind
dependent coloring can also be turned off there.

<p>The following tags can be used in message display strings:

<p><table border>
<TR> <TD align=left>

<b>Tag</b> </TD> <TD align=left> <b>Meaning</b> </TD></TR>
<TR> <TD align=left> <b>b=</b><i>width</i>,<i>height</i>,<b>oval</b>
</TD> <TD align=left>
 Ellipse with the given <i>height</i> and <i>width</i>.

<p>Defaults: <i>width</i>=10, <i>height</i>=10</TD></TR>
<TR> <TD align=left> <b>b=</b><i>width</i>,<i>height</i>,<b>rect</b>
</TD> <TD align=left>
 Rectangle with the given <i>height</i> and <i>width</i>.

<p>Defaults: <i>width</i>=10, <i>height</i>=10</TD></TR>
<TR> <TD align=left> <b>o=</b><i>fillcolor</i>,<i>outlinecolor</i>,<i>borderwidth</i>
</TD> <TD align=left>
 Specifies options for the rectangle or oval.
For color notation, see section <a href="#sec338">[9.2]</a>.

<p>Defaults: <i>fillcolor</i>=red, <i>outlinecolor</i>=black,
<i>borderwidth</i>=1</TD></TR>
<TR> <TD align=left> <b>i=</b><i>iconname</i>,<i>color</i>,<i>percentage</i>
</TD> <TD align=left>
 Use the named icon. It can be colorized, and percentage
specifies the amount of colorization. If color name is <tt>"kind"</tt>,
a message kind dependent colors is used (like default behaviour).

<p>Defaults: <i>iconname</i>: no default -- if no icon name is present, a small
red solid circle will be used;
<i>color</i>: no coloring; <i>percentage</i>: 30%</TD></TR>
<TR> <TD align=left> <b>tt=</b><i>tooltip-text</i>
</TD> <TD align=left>
 Displays the given text in a tooltip when the user moves
the mouse over the message icon.</TD></TR>
<TR> <TD align=left> 
</table>

<p>Examples:

<pre>
   "i=penguin"
</pre>
<p>
<pre>
   "b=15,15,rect;o=white,kind,5"
</pre>

<p>

<p><H2><A NAME="sec338"/>9.2 Colors</H2>
<a name="sec:ch-graphics:colors"></a>

<p><H3><A NAME="sec339"/>9.2.1 Color names</H3>

<p>Any valid Tk color specification is accepted: English color names
(blue, lightgray, wheat) or <i>#rgb</i>, <i>#rrggbb</i> format
(where <i>r</i>,<i>g</i>,<i>b</i> are hex digits).

<p>It is also possible to specify colors in HSB (hue-saturation-brightness) as
<i>@hhssbb</i> (with <i>h</i>, <i>s</i>, <i>b</i> being hex digits).
HSB makes it easier to scale colors e.g. from white to bright red.

<p>You can produce a transparent background by specifying a hyphen (<i>"-"</i>)
as color.

<p>
<H3><A NAME="sec340"/>9.2.2 Icon colorization</H3>

<p>The <tt>"i="</tt> display string tag allows for colorization of icons.
It accepts a target color and a percentage as the degree of colorization.
Percentage has no effect if the target color is missing.
Brightness of icon is also affected -- to keep the original brightness,
specify a color with about 50% brightness (e.g. #808080 mid-grey,
#008000 mid-green).

<p>Examples:

<p><ul>
  <li> <tt>"i=device/server,gold"</tt> creates a gold server icon
  <li> <tt>"i=misc/globe,#808080,100"</tt> makes the icon grayscale
  <li> <tt>"i=block/queue,white,100"</tt> yields a "burnt-in" black-and-white icon
</ul>

<p>Colorization works with both submodule and message icons.

<p>
<H2><A NAME="sec341"/>9.3 The icons</H2>
<a name="sec:ch-graphics:icon-library"></a>

<p><H3><A NAME="sec342"/>9.3.1 The bitmap path</H3>

<p>In the current OMNeT++ version, module icons are GIF files. The icons shipped
with OMNeT++ are in the <tt>bitmaps/</tt> subdirectory. Both the GNED editor
and Tkenv need the exact location of this directory to load the icons.

<p>Icons are loaded from all directories in the <i>bitmap path</i>,
a semicolon-separated list of directories.
The default bitmap path is compiled into GNED and Tkenv with the value
<tt>"<i>omnetpp-dir</i>/bitmaps;./bitmaps"</tt> -- which will work fine
as long as you don't move the directory, and you'll also be able to
load more icons from the <tt>bitmaps/</tt> subdirectory of the current
directory. As people usually run simulation models from the model's
directory, this practically means that custom icons placed in the
<tt>bitmaps/</tt> subdirectory of the model's directory are automatically
loaded.

<p>The compiled-in bitmap path can be overridden with the <tt>OMNETPP_BITMAP_PATH</tt>
environment variable. The way of setting environment variables is system
specific: in Unix, if you're using the bash shell, adding a line

<pre>
export OMNETPP_BITMAP_PATH="/home/you/bitmaps;./bitmaps"
</pre>
<p>
to <tt>~/.bashrc</tt> or <tt>~/.bash_profile</tt> will do; on Windows, environment variables
can be set via the <i>My Computer --&gt; Properties</i> dialog.

<p>You can also add to the bitmap path from <tt>omnetpp.ini</tt>, with
the <tt>bitmap-path</tt> setting:

<pre>
[Tkenv]
bitmap-path = "/home/you/model-framework/bitmaps;/home/you/extra-bitmaps"
</pre>
<p>
The value should be quoted, otherwise the first semicolon separator will be
interpreted as comment sign, which will result in the rest of the
directories being ignored.

<p>
<H3><A NAME="sec343"/>9.3.2 Categorized icons</H3>

<p>Since OMNeT++ 3.0, icons are organized into several categories, represented
by folders. These categories include:

<p><ul>
  <li> block/ - icons for subcomponents (queues, protocols, etc).
  <li> device/ - network devices: servers, hosts, routers, etc.
  <li> abstract/ - symbolic icons for various devices
  <li> misc/ - node, subnet, cloud, building, town, city, etc.
  <li> msg/ - icons that can be used for messages
</ul>

<p>Old (pre-3.0) icons are in the <tt>old/</tt> folder.

<p>Tkenv and GNED now load icons from subdirectories of all directories
of the bitmap path, and these icons can be referenced from display strings
by naming the subdirectory (subdirectories) as well:
<tt>"subdir/icon"</tt>, <tt>"subdir/subdir2/icon"</tt>, etc.

<p>For compatibility, if the display string contains a icon without
a category (i.e. subdirectory) name, OMNeT++ tries it as "old/icon" as well.

<p>
<H3><A NAME="sec344"/>9.3.3 Icon size</H3>

<p>Icons come in various sizes: normal, large, small, very small. Sizes are
encoded into the icon name's suffix: <tt>_l</tt>, <tt>_s</tt>, <tt>_vs</tt>.
In display strings, one can either use the suffix (<tt>"i=device/router_l"</tt>),
or the <tt>"is</tt>" (<i>icon size</i>) display string tag ("i=device/router;is=l").

<p>
<H2><A NAME="sec345"/>9.4 Layouting</H2>
<a name="sec:ch-graphics:layouting"></a>

<p>OMNeT++ implements an automatic layouting feature, using
a variation of the SpringEmbedder algorithm. Modules which have
not been assigned explicit positions via the <tt>"p="</tt> tag will be
automatically placed by the algorithm.

<p>SpringEmbedder is a graph layouting algorithm based on a physical model.
Graph nodes (modules) repent each other like electric charges
of the same sign, and connections are sort of springs which try
to contract and pull the nodes they're attached to. There is also friction
built in, in order to prevent oscillation of the nodes. The layouting algorithm
simulates this physical system until it reaches equilibrium
(or times out). The physical rules above have been slightly tweaked
to get better results.

<p>The algorithm doesn't move any module which has fixed coordinates.
Predefined row, matrix, ring or other arrangements (defined
via the 3rd and further args of the <tt>"p="</tt> tag) will be preserved --
you can think about them as if those modules were attached
to a wooden framework so that they can only move as one unit.

<p>Caveats:

<p><ul>
  <li> If the full graph is too big after layouting, it is scaled
    back so that it fits on the screen, <i>unless it contains
    any fixed-position module</i>. (For obvious reasons: if there's a module
    with manually specified position, we don't want to move that one).
    To prevent rescaling, you can specify a sufficiently large bounding
    box in the background display string, e.g. <tt>"b=2000,3000"</tt>.
  <li> Size is ignored by the present layouter, so longish modules
    (such as an Ethernet segment) may produce funny results.
  <li> The algorithm is prone to produce erratic results, especially
    when the number of submodules is small, or when using predefined
    (matrix, row, ring, etc) layouts. The "Re-layout" toobar button
    can then be very useful. Larger networks usually produce
    satisfactory results.
</ul>

<p>Parameters to the layouter algoritm (repulsive/attractive forces,
number of iterations,random number seed) can be specified via the
<tt>"l="</tt> background display string tag. Its current arguments are
(with default values):
<tt>"l=<i>&lt;repulsion&gt;</i>=10,<i>&lt;attraction&gt;</i>=0.3,
<i>&lt;edgelen&gt;</i>=40,<i>&lt;maxiter&gt;</i>=500,<i>&lt;rng-seed&gt;</i>"</tt>.
The <tt>"l="</tt> tag is somewhat experimental and its arguments
may change in further releases.

<p>
<H2><A NAME="sec346"/>9.5 GNED -- Graphical NED Editor</H2>

<p><!--ned!graphical interface-->

<p>The GNED editor allows you to design compound modules graphically.
GNED works directly with NED files -- it doesn't have any internal file
format. You can load any of your existing NED files, edit the compound
modules in it graphically and then save the file back. Other components
in the NED file (simple modules, channels, networks etc.) will
survive the operation. GNED puts all graphics-related data into
display strings.

<p>GNED works by parsing your NED file into an internal data structure,
and regenerating the NED text when you save the file. One consequence
of this is that indentation will be ``canonized''.
Comments in the original NED are preserved -- the parser associates
them with the NED elements they belong to, so comments won't
be messed up even if you edit the graphical representation extensively
by removing/adding submodules, gates, parameters, connections, etc.

<p>GNED is a fully two-way visual tool. While editing the graphics,
you can always switch to NED source view, edit in there and switch
back to graphics. Your changes in the NED source will be immediately
backparsed to graphics; in fact, the graphics will be totally
reconstructed from the NED source and the display strings in
it.

<p>
<H3><A NAME="sec347"/>9.5.1 Keyboard and mouse bindings</H3>

<p><!--gned!mouse bindings-->

<p>In graphics view, there are two editing modes: draw and select/mode.
The mouse bindings are the following:

<p>
<table border>
<TR> <TD align=left>

<b>Mouse</b> </TD> <TD align=left> <b>Effect</b></TD></TR>
<TR> <TD align=center colspan=2><b>In <i>draw</i> mode:</b> </TD></TR>
<TR> <TD align=left>
Drag out a rectangle in empty area: </TD> <TD align=left>  create new submodule </TD></TR>
<TR> <TD align=left> Drag from one submodule to another: </TD> <TD align=left>  create new connection </TD></TR>
<TR> <TD align=left> Click in empty area: </TD> <TD align=left> switch to select/move mode </TD></TR>
<TR> <TD align=center colspan=2><b>In <i>select/move</i> mode:</b> </TD></TR>
<TR> <TD align=left> Click submodule/connection: </TD> <TD align=left> select it</TD></TR>
<TR> <TD align=left> Ctrl-click submodule/conn.: </TD> <TD align=left> add to selection </TD></TR>
<TR> <TD align=left> Click in empty area: </TD> <TD align=left> clear selection</TD></TR>
<TR> <TD align=left> Drag a selected object: </TD> <TD align=left> move selected objects </TD></TR>
<TR> <TD align=left> Drag submodule or connection: </TD> <TD align=left> move it </TD></TR>
<TR> <TD align=left> Drag either end of connection: </TD> <TD align=left> move that end </TD></TR>
<TR> <TD align=left> Drag corner of (sub)module: </TD> <TD align=left> resize module</TD></TR>
<TR> <TD align=left> Drag starting in empty area: </TD> <TD align=left> select enclosed submodules/connections </TD></TR>
<TR> <TD align=left> <i>Del</i> key </TD> <TD align=left> delete selected objects </TD></TR>
<TR> <TD align=center colspan=2><b>Both editing modes:</b> </TD></TR>
<TR> <TD align=left> Right-click on module/submodule/connection: </TD> <TD align=left> popup menu </TD></TR>
<TR> <TD align=left> Double-click on submodule: </TD> <TD align=left> go into submodule </TD></TR>
<TR> <TD align=left> Click name label </TD> <TD align=left> edit name </TD></TR>
<TR> <TD align=left> Drag&amp;drop module type from the tree view to the canvas </TD> <TD align=left>
create a submodule of that type </TD></TR>
</table>

<p>

<p><H2><A NAME="sec348"/>9.6 Enhancing animation</H2>

<p><H3><A NAME="sec349"/>9.6.1 Changing display strings at runtime</H3>

<p>Often it is useful to manipulate the display string at runtime.
Changing colors, icon, or text may convey status change, and
changing a module's position is useful when simulating mobile
networks.

<p>Display strings are stored in <tt><a href="../api/classcDisplayString.html">cDisplayString</a></tt> objects inside
modules and gates. <tt><a href="../api/classcDisplayString.html">cDisplayString</a></tt> also lets you manipulate the string.

<p>To get a pointer to the <tt><a href="../api/classcDisplayString.html">cDisplayString</a></tt> object, you can call
the module's <tt>displayString()</tt> method:

<p><pre>
<a href="../api/classcDisplayString.html">cDisplayString</a> *dispStr = displayString();
</pre>

<p>
<pre>
<a href="../api/classcDisplayString.html">cDisplayString</a> *bgDispStr = parentModule()-&gt;backgroundDisplayString();
</pre>

<p><pre>
<a href="../api/classcDisplayString.html">cDisplayString</a> *gateDispStr = gate("out")-&gt;displayString();
</pre>

<p>
As far as <tt><a href="../api/classcDisplayString.html">cDisplayString</a></tt> is concerned, a display string
(e.g. <tt>"p=100,125;i=cloud"</tt>) is a string that consist of several
<i>tags</i> separated by semicolons, and each tag has a <i>name</i>
and after an equal sign, zero or more <i>arguments</i> separated by commas.

<p>The class facilitates tasks such as finding out what tags a display string
has, adding new tags, adding arguments to existing tags,
removing tags or replacing arguments. The internal storage method allows
very fast operation; it will generally be faster than direct string manipulation.
The class doesn't try to interpret the display string in any way, nor does
it know the meaning of the different tags; it merely parses the string
as data elements separated by semicolons, equal signs and commas.

<p>An example:

<pre>
dispStr-&gt;parse("a=1,2;p=alpha,,3");
dispStr-&gt;insertTag("x");
dispStr-&gt;setTagArg("x",0,"joe");
dispStr-&gt;setTagArg("x",2,"jim");
dispStr-&gt;setTagArg("p",0,"beta");
ev &lt;&lt; dispStr-&gt;getString();  // result: "x=joe,,jim;a=1,2;p=beta,,3"
</pre>
<p>

<p><H3><A NAME="sec350"/>9.6.2 Bubbles</H3>

<p>Modules can let the user know about important events (such as a node
going down or coming up) by displaying a bubble with a short message
("Going down", "Coming up", etc.) This is done by the <tt>bubble()</tt> method
of <tt><a href="../api/classcModule.html">cModule</a></tt>. The method takes the string to be displayed
as a <tt>const char *</tt> pointer.

<p>An example:

<pre>
bubble("Going down!");
</pre>
<p>
If the module contains a lot of code that modifies the display string or
displays bubbles, it is recommended to make these calls conditional
on <tt>ev.isGUI()</tt>. The <tt>ev.isGUI()</tt> call returns <i>false</i>
when the simulation is run under Cmdenv, so one can make the code skip
potentially expensive display string manipulation.

<pre>
if (ev.isGUI())
    bubble("Going down!");
</pre>
<p>

<p>
</BODY>
</HTML>
<hr><hr><H1><A NAME="sec351"/>10 Analyzing Simulation Results</H1>
<a name="cha:analyzing-simulation-results"></a>

<p>
<H2><A NAME="sec352"/>10.1 Output vectors</H2>
<a name="sec:ch-ana-sim:output-vectors"></a>

<p>Output vectors are time series data: values with timestamps.
You can use output vectors to record end-to-end delays or
round trip times of packets, queue lengths, queueing times,
link utilization, the number of dropped packets, etc. --
anything that is useful to get a full picture of what happened
in the model during the simulation run.

<p>Output vectors are recorded from simple modules, by <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects
(see section <a href="#sec258">[6.9.1]</a>). Since output vectors usually
record a large amount of data, in <tt>omnetpp.ini</tt> you can disable vectors
or specify a simulation time interval for recording
(see section <a href="#sec302">[8.5]</a>).

<p>All <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects write to the same, common file.
The following sections describe the format of the file, and
how to process it.

<p>
<H3><A NAME="sec353"/>10.1.1 Plotting output vectors with Plove</H3>

<p><p class="subheading">Plove features</p>

<p>Typically, you'll get output vector files as a result of a simulation.
Data written to <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects from
simple modules are written to output vector
files<!--output!vector file-->. You can use Plove to look
into the output vector files and plot vectors from them.

<p>Plove<!--Plove--> is a handy tool for plotting
OMNeT++ output vectors. Line type (lines, dots etc) for each vector can be set
as well as the most frequent drawing options like axis bounds, scaling, titles
and labels. You can save the graphs to files (as Encapsulated Postscript or
raster formats such as GIF) with a click. On Windows, you can also
copy the graph to the clipboard in a vector format (Windows metafile)
and paste it into other applications.
    <br><ul><font size=-1>[Note: prior to OMNeT++ 3.0, Plove has been a front-end to
    gnuplot. This older version of Plove is no longer supported, but it is still
    available in the OMNeT++ source distribution.]</font></ul>

<p>Filtering the results<!--filtering results--> before plotting is
possible. Filters can do averaging, truncation of extreme values,
smoothing, they can do density estimation<!--density estimation--> by
calculating histograms<!--histogram--> etc. Some filters are built
in, and you can create new filters by parameterizing and aggregating existing ones.
You can apply several filters to a vector.

<p>On startup, Plove automatically reads the <tt>.ploverc</tt> file in
your home directory. The file contains general application settings,
including the custom filters you created.

<p>

<p>
<p class="subheading">Usage</p>

<p>First, you load an output vector file (<tt>.vec</tt>) into the left
pane. You can copy vectors from the left
pane to the right pane by clicking the button with the right arrow icon
in the middle.
The PLOT button will initiate plotting the <i>selected</i>
vectors in the right pane. Selection works as in Windows: dragging
and shift+left click selects a range, and ctrl+left click selects/deselects
individual items. To adjust drawing style, change vector title or add
a filter, click the Options... button. This works for several selected
vectors too. Plove accepts nc/mc-like keystrokes: F3, F4, F5, F6, F8,
grey '+' and grey '*'.

<p>
The left pane works as a general storage for vectors you're working
with. You can load several vector files, delete vectors you don't
want to deal with, rename them etc. These changes will not affect
the vector files on disk.
(Plove never modifies the output vector files themselves.)
In the right pane, you can duplicate
vectors if you want to filter the vector and also keep the original.
If you set the right options for a vector but temporarily do
not want it to hang around in the right pane, you can put it
back into the left pane for storage.

<p>

<p><H3><A NAME="sec354"/>10.1.2 Format of output vector files</H3>

<p>An output vector file<!--output!vector file--> contains several
series of data produced during simulation. The file is textual, and it
looks like this:

<p><pre>
<b>mysim.vec:</b>
vector 1   "subnet[4].term[12]"  "response time"  1
1  12.895  2355.66666666
1  14.126  4577.66664666
vector 2   "subnet[4].srvr"  "queue length"  1
2  16.960  2.00000000000.63663666
1  23.086  2355.66666666
2  24.026  8.00000000000.44766536
</pre>

<p>
There two types of lines: vector declaration lines (beginning with
the word <tt>vector</tt>), and data lines.
A <i>vector declaration line</i> introduces a new output vector, and
its columns are: vector Id, module of creation, name of <tt><a href="../api/classcOutVector.html">cOutVector</a></tt>
object, and multiplicity (usually 1). Actual data recorded in this
vector are on <i>data lines</i> which begin with the vector Id.
Further columns on data lines are the simulation time and the recorded value.

<p>

<p>
<H3><A NAME="sec355"/>10.1.3 Working without Plove</H3>

<p>In case you have a large number of repeated experiments, you'll probably
want to automate processing of the output vector files. OMNeT++ lets you
use any tool you see fit for this purpose, because the output
vector files are text files and their format is simple enough to be
processed by common tools such as <i>perl</i>, <i>awk</i>,
<i>octave</i>, etc.

<p><p class="subheading">Extracting vectors from the file</p>

<p>You can use the Unix <tt>grep</tt> tool to extract a particular vector
from the file. As the first step, you must find out the Id of the
vector. You can find the appropriate vector line with a text editor or
you can use <tt>grep</tt> for this purpose:

<pre>
% grep "queue length" vector.vec
</pre>
<p>
Or, you can get the list of all vectors in the file by typing:

<pre>
% grep ^vector vector.vec
</pre>
<p>
This will output the appropriate vector line:

<pre>
vector 6  "subnet[4].srvr"  "queue length"  1
</pre>
<p>
Pick the vector Id, which is 6 in this case, and grep the file
for the vector's data lines:

<pre>
grep ^6 vector.vec &gt; vector6.vec
</pre>
<p>

<p>Now, <tt>vector6.vec</tt> contains the appropriate vector. The only
potential problem is that the vector Id is there at the beginning of
each line and this may be hard to digest for some programs that you
use for post-processing and/or visualization. This problem is
eliminated by the OMNeT++ <tt>splitvec</tt> utility (written in
<tt>awk</tt>), to be discussed in the next section.

<p>

<p>
<p class="subheading">Using splitvec</p>

<p>The <tt>splitvec</tt> script (part of OMNeT++) automates the process described
in the previous section: it breaks the vector file into several files which
contain one vector each. The command

<pre>
% splitvec mysim.vec
</pre>
<p>
would create the files <tt>mysim1.vec</tt>, <tt>mysim2.vec</tt> etc. with
contents similar to the following:

<p><pre>
<b>mysim1.vec:</b>
# vector 1  "subnet[4].term[12]"  "response time"  1
12.895  2355.66666666
14.126  4577.66664666
23.086  2355.66666666

<b>mysim2.vec:</b>
# vector 2  "subnet[4].srvr"  "queue length"  1
16.960  2.00000000000.63663666
24.026  8.00000000000.44766536
</pre>

<p>
As you can see, the vector Id column has been stripped from the files.
The resulting files can be directly loaded e.g. into spreadsheets or other
programs (<a href="#sec359">[10.3]</a>).

<p>
<H2><A NAME="sec356"/>10.2 Scalar statistics</H2>
<a name="sec:ch-ana-sim:output-scalars"></a>

<p>Output vectors capture the transient behaviour of the simulation run.
However, to compare model behaviour under various parameter settings,
output scalars are more useful.

<p><H3><A NAME="sec357"/>10.2.1 Format of output scalar files</H3>

<p>Scalar results are recorded with <tt>recordScalar()</tt> calls,
usually from the <tt>finish()</tt> methods of modules, with code like this:

<pre>
void EtherMAC::finish()
{
    double t = simTime();
    if (t==0) return;

    recordScalar("simulated time", t);
    recordScalar("rx channel idle (%)", 100*totalChannelIdleTime/t);
    recordScalar("rx channel utilization (%)", 100*totalSuccessfulRxTxTime/t);
    recordScalar("rx channel collision (%)", 100*totalCollisionTime);

    recordScalar("frames sent",    numFramesSent);
    recordScalar("frames rcvd",    numFramesReceivedOK);
    recordScalar("bytes sent",     numBytesSent);
    recordScalar("bytes rcvd",     numBytesReceivedOK);
    recordScalar("collisions",     numCollisions);

    recordScalar("frames/sec sent", numFramesSent/t);
    recordScalar("frames/sec rcvd", numFramesReceivedOK/t);
    recordScalar("bits/sec sent",   8*numBytesSent/t);
    recordScalar("bits/sec rcvd",   8*numBytesReceivedOK/t);
}
</pre>
<p>
The corresponding output scalar file (by default, <tt>omnetpp.sca</tt>)
will look like this:

<pre>
run 1 "lan"
scalar "lan.hostA.mac" "simulated time"             120.249243
scalar "lan.hostA.mac" "rx channel idle (%)"        97.5916992
scalar "lan.hostA.mac" "rx channel utilization (%)" 2.40820676
scalar "lan.hostA.mac" "rx channel collision (%)"   0.011312
scalar "lan.hostA.mac" "frames sent"                99
scalar "lan.hostA.mac" "frames rcvd"                3088
scalar "lan.hostA.mac" "bytes sent"                 64869
scalar "lan.hostA.mac" "bytes rcvd"                 3529448
scalar "lan.hostA.mac" "frames/sec sent"            0.823290006
scalar "lan.hostA.mac" "frames/sec rcvd"            25.6799953
scalar "lan.hostA.mac" "bits/sec sent"              4315.63632
scalar "lan.hostA.mac" "bits/sec rcvd"              234808.83
scalar "lan.hostB.mac" "simulated time"             120.249243
scalar "lan.hostB.mac" "rx channel idle (%)"        97.5916992
scalar "lan.hostB.mac" "rx channel utilization (%)" 2.40820676
scalar "lan.hostB.mac" "rx channel collision (%)"   0.011312
[...]
scalar "lan.hostC.mac" "simulated time"             120.249243
scalar "lan.hostC.mac" "rx channel idle (%)"        97.5916992
scalar "lan.hostC.mac" "rx channel utilization (%)" 2.40820676
scalar "lan.hostC.mac" "rx channel collision (%)"   0.011312
[...]

run 2 "lan"
scalar "lan.hostA.mac" "simulated time"             235.678665
[...]
</pre>
<p>
Every <tt>recordScalar()</tt> call generates one "scalar" line in the file.
(If you record statistics objects (<tt>cStatictic</tt> subclasses
such as <tt><a href="../api/classcStdDev.html">cStdDev</a></tt>) via their <tt>recordScalar()</tt> methods,
they'll generate several lines: mean, standard deviation, etc.)
In addition, several simulation runs can record their results into a single file --
this facilitates comparing them, creating x-y plots
(<i>offered load vs throughput</i>-type diagrams), etc.

<p>

<p><H3><A NAME="sec358"/>10.2.2 The Scalars tool</H3>

<p>The <tt>Scalars</tt> program can be used to visualize the contents of the
<tt>omnetpp.sca</tt> file. It can draw bar charts, x-y plots
(e.g. throughput vs offered load), or export data via the clipboard
for more detailed analysis into spreadsheets or other programs.

<p>You can open a scalar file either from the Scalars program's menu
or by specifying it as a command-line argument to Scalars.

<p>The program displays the data in a table with columns showing the
file name, run number, module name where it was recorded, and the value.
There're usually too many rows to get an overview, so you can filter
by choosing from (or editing) the three combo boxes at the top.
(The filters also accept <tt>*</tt>, <tt>**</tt> wildcards.)

<p>You could actually load further scalar files into the window,
and thus analyse them together.

<p>You can copy the selected rows to the clipboard by Edit|Copy or
the corresponding toolbar button, and paste them e.g. into
OpenOffice Calc, MS Excel or Gnumeric.

<p>The bar chart toolbar button creates -- well -- a bar chart
in a new window. You can customize the chart by right-clicking
on it and choosing from the context menu. It can also be exported
to EPS, GIF, or as metafile via the Windows clipbard (the latter
is not available on Unix of course).

<p>

<p><H2><A NAME="sec359"/>10.3 Analysis and visualization tools</H2>
<a name="sec:ana-sim:tools"></a>

<p>Output vector files (or files produced by <tt>splitvec</tt>) and
output scalar files can be analysed and/or plotted by
a number of applications in addition to <tt>Plove</tt> and <tt>Scalars</tt>.
These programs can produce output in various forms (on the screen,
as PostScript, in various image formats, etc.)

<p>One straightforward solution is to import or paste them into spreadsheet
programs such as OpenOffice Calc, Microsoft Excel or GNOME Gnumeric.
These programs have good charting and statistical features, but the number
of rows is usually limited to about 32,000..64,000.
One useful functionality spreadsheets offer for analysing scalar files is
known as <i>PivotTable</i> in Excel, and as <i>DataPilot</i> in in OpenOffice.
The easiest way to import scalar files into them is via copy/paste
from Scalars.

<p>Alternatively, one can use numerical packages such as <i>Octave</i>,
<i>Matlab</i> or the statistics package <i>R</i>.
In addition to their support for statistical computations, they can also
create various plots.

<p>There are also open-source programs directly for plotting, <i>Gnuplot</i>
still being the most commonly used one. Other, potentially more powerful ones
include <i>Grace</i>, <i>ROOT</i> and <i>PlotMTV</i>.

<p>
<H3><A NAME="sec360"/>10.3.1 Grace</H3>

<p><i>Grace</i> (also known as <i>xmgrace</i>, a successor of <i>ACE/gr</i> or
<i>Xmgr</i>) is a GPL-ed powerful data visualization program
with a WYSIWIG point-and-click graphical user interface. It was developed for
Unix, but there is a Windows version, too.

<p>You load the appropriate file by selecting it in a dialog box.
The icon bar and menu commands can be used to customize the graph.

<p>As of June 2003, Grace 1.5.12 can export graphics to (E)PS, PDF, MIF, SVG,
PNM, JPEG and PNG formats. It has many useful features like built-in statistics
and analysis functions (e.g. correlation, histogram), fitting, splines, etc.,
and it also sports its own built-in programming language.

<p>
<H3><A NAME="sec361"/>10.3.2 ROOT</H3>

<p><i>ROOT</i> is a powerful object-oriented data analysis framework,
with strong support for plotting and graphics in general.
ROOT was developed at CERN, and is distributed under a BSD-like license.

<p>ROOT is based on <i>CINT</i>, a ``C/C++ interpreter''
aimed at processing C/C++ scripts. It is probably harder to get started
using ROOT than with either Gnuplot or Grace, but if you are serious
about analysing simulation results, you will find that ROOT provides
power and flexibility that would be unattainable the other two programs.

<p>Curt Brune's page at Stanford (http://www.slac.stanford.edu/~curt/omnet++/)
shows examples what you can achieve using ROOT with OMNeT++.

<p>
<H3><A NAME="sec362"/>10.3.3 Gnuplot</H3>
<!--Gnuplot-->

<p>Gnuplot has an interactive command interface. To plot the data in
<tt>mysim1.vec</tt> and <tt>mysim4.vec</tt> (produced by <tt>splitvec</tt>)
plotted in the same graph, you can type:

<pre>
plot "mysim1.vec" with lines, "mysim4.vec" with lines
</pre>
<p>
To adjust the <i>y</i> range, you would type:

<pre>
set yrange [0:1.2]
replot
</pre>
<p>
Several commands are available to adjust ranges, plotting style, labels,
scaling etc. Gnuplot can also plot 3D graphs. Gnuplot
is available for Windows and other platforms.
On Windows, you can copy the resulting graph to the clipboard from
the Gnuplot window's system menu, then insert it into the application you
are working with.

<p>

</BODY>
</HTML>
<hr><hr><H1><A NAME="sec363"/>11 Documenting NED and Messages</H1>
<a name="cha:neddoc"></a>

<p><H2><A NAME="sec364"/>11.1 Overview</H2>

<p>OMNeT++ provides a tool which can generate HTML documentation from NED files
and message definitions. Like Javadoc and Doxygen, <tt>opp_neddoc</tt>
makes use of source code comments. <tt>opp_neddoc</tt>-generated
documentation lists simple and compound modules, and presents their details
including description, gates, parameters, unassigned submodule parameters
and syntax-highlighted source code.
The documentation also includes clickable network diagrams (exported via the GNED
graphical editor) and module usage diagrams as well as inheritance diagrams
for messages.

<p><tt>opp_neddoc</tt> works well with Doxygen, which means that it can hyperlink
simple modules and message classes to their C++ implementation classes in
the Doxygen documentation. If you also generate the C++ documentation with some
Doxygen features turned on (such as <i>inline-sources</i> and
<i>referenced-by-relation</i>, combined with
<i>extract-all</i>, <i>extract-private</i> and <i>extract-static</i>),
the result is an easily browsable and very informative presentation of the
source code. Of course, one still has to write documentation comments
in the code.

<p>

<p><H2><A NAME="sec365"/>11.2 Authoring the documentation</H2>

<p>
<H3><A NAME="sec366"/>11.2.1 Documentation comments</H3>

<p>Documentation is embedded in normal comments. All <tt>//</tt> comments
that are in the ``right place'' (from the documentation tool's
point of view) will be included in the generated documentation.
  <br><ul><font size=-1>[In contrast, Javadoc and Doxygen use special comments (those
     beginning with <tt>/**</tt>, <tt>///</tt>, <tt>//&lt;</tt> or a similar
     marker) to distinguish documentation from ``normal'' comments in the
     source code. In OMNeT++ there's no need for that: NED and the message
     syntax is so compact that practically all comments one would want to write
     in them can serve documentation purposes. Still, there is a way to write
     comments that <i>don't</i> make it into the documentation -- by starting
     them with <tt>//#</tt>.]</font></ul>

<p>Example:

<pre>
//
// An ad-hoc traffic generator to test the Ethernet models.
//
simple Gen
    parameters:
        destAddress: string,  // destination MAC address
        protocolId: numeric,  // value for SSAP/DSAP in Ethernet frame
        waitMean: numeric;    // mean for exponential interarrival times
    gates:
        out: out;             // to Ethernet LLC
endsimple
</pre>
<p>
You can also place comments above parameters and gates. This is useful
if they need long explanations. Example:

<pre>
//
// Deletes packets and optionally keeps statistics.
//
simple Sink
    parameters:
        // You can turn statistics generation on and off. This is
        // a very long comment because it has to be described what
        // statistics are collected (or not).
        statistics: bool;
    gates:
        in: in;
endsimple
</pre>
<p>
If you want a comment line <i>not</i> to appear in the documentation,
begin it with <tt>//#</tt>. Those lines will be ignored by the
documentation generation, and can be used to comment out
unused NED code or to make ``private'' comments like <tt>FIXME</tt> or
<tt>TBD</tt>.

<pre>
//
// An ad-hoc traffic generator to test the Ethernet models.
//# FIXME above description needs to be refined
//
simple Gen
    parameters:
        destAddress: string,  // destination MAC address
        protocolId: numeric,  // value for SSAP/DSAP in Ethernet frame
        //# burstiness: numeric;  -- not yet supported
        waitMean: numeric;    // mean for exponential interarrival times
    gates:
        out: out;             // to Ethernet LLC
endsimple
</pre>
<p>

<p><H3><A NAME="sec367"/>11.2.2 Text layout and formatting</H3>

<p>If you write longer descriptions, you'll need text formatting capabilities.
Text formatting works like in Javadoc or Doxygen -- you can break up the
text into paragraphs and create bulleted/numbered lists without
special commands, and use HTML for more fancy formatting.

<p>Paragraphs are separated by empty lines, like in LaTeX or Doxygen.
Lines beginning with `<tt>-</tt>' will be turned into bulleted lists,
and lines beginning with `<tt>-#</tt>' into numbered lists.

<p>Example:

<pre>
//
// Ethernet MAC layer. MAC performs transmission and reception of frames.
//
// Processing of frames received from higher layers:
// - sends out frame to the network
// - no encapsulation of frames -- this is done by higher layers.
// - can send PAUSE message if requested by higher layers (PAUSE protocol,
//   used in switches). PAUSE is not implemented yet.
//
// Supported frame types:
// -# IEEE 802.3
// -# Ethernet-II
//
</pre>
<p>

<p><H3><A NAME="sec368"/>11.2.3 Special tags</H3>

<p><tt>OMNeT++_neddoc</tt> understands the following tags and will render them accordingly:
<tt>@author</tt>, <tt>@date</tt>, <tt>@todo</tt>, <tt>@bug</tt>, <tt>@see</tt>, <tt>@since</tt>,
<tt>@warning</tt>, <tt>@version</tt>. An example usage:

<pre>
//
// @author Jack Foo
// @date 2005-02-11
//
</pre>
<p>

<p><H3><A NAME="sec369"/>11.2.4 Additional text formatting using HTML</H3>

<p>Common HTML tags are understood as formatting commands.
The most useful of these tags are: <tt>&lt;i&gt;..&lt;/i&gt;</tt> (italic),
<tt>&lt;b&gt;..&lt;/b&gt;</tt> (bold), <tt>&lt;tt&gt;..&lt;/tt&gt;</tt> (typewriter font),
<tt>&lt;sub&gt;..&lt;/sub&gt;</tt> (subscript), <tt>&lt;sup&gt;..&lt;/sup&gt;</tt> (superscript),
<tt>&lt;br&gt;</tt> (line break), <tt>&lt;h3&gt;</tt> (heading),
<tt>&lt;pre&gt;..&lt;/pre&gt;</tt> (preformatted text) and <tt>&lt;a href=..&gt;..&lt;/a&gt;</tt> (link),
as well as a few other tags used for table creation (see below).
For example, <tt>&lt;i&gt;Hello&lt;/i&gt;</tt> will be rendered as ``<i>Hello</i>''
(using an italic font).

<p>The complete list of HTML tags interpreted by <tt>opp_neddoc</tt> are:
<tt>&lt;a&gt;</tt>, <tt>&lt;b&gt;</tt>, <tt>&lt;body&gt;</tt>, <tt>&lt;br&gt;</tt>, <tt>&lt;center&gt;</tt>,
<tt>&lt;caption&gt;</tt>, <tt>&lt;code&gt;</tt>, <tt>&lt;dd&gt;</tt>, <tt>&lt;dfn&gt;</tt>, <tt>&lt;dl&gt;</tt>,
<tt>&lt;dt&gt;</tt>, <tt>&lt;em&gt;</tt>, <tt>&lt;form&gt;</tt>, <tt>&lt;font&gt;</tt>, <tt>&lt;hr&gt;</tt>,
<tt>&lt;h1&gt;</tt>, <tt>&lt;h2&gt;</tt>, <tt>&lt;h3&gt;</tt>, <tt>&lt;i&gt;</tt>, <tt>&lt;input&gt;</tt>, <tt>&lt;img&gt;</tt>,
<tt>&lt;li&gt;</tt>, <tt>&lt;meta&gt;</tt>, <tt>&lt;multicol&gt;</tt>, <tt>&lt;ol&gt;</tt>, <tt>&lt;p&gt;</tt>, <tt>&lt;small&gt;</tt>,
<tt>&lt;span&gt;</tt>, <tt>&lt;strong&gt;</tt>,
<tt>&lt;sub&gt;</tt>, <tt>&lt;sup&gt;</tt>, <tt>&lt;table&gt;</tt>, <tt>&lt;td&gt;</tt>, <tt>&lt;th&gt;</tt>, <tt>&lt;tr&gt;</tt>,
<tt>&lt;tt&gt;</tt>, <tt>&lt;kbd&gt;</tt>, <tt>&lt;ul&gt;</tt>, <tt>&lt;var&gt;</tt>.

<p>Any tags not in the above list will not be interpreted as formatting commands
but will be printed verbatim -- for example, <tt>&lt;what&gt;bar&lt;/what&gt;</tt>
will be rendered literally as ``&lt;what&gt;bar&lt;/what&gt;'' (unlike HTML where
unknown tags are simply ignored, i.e. HTML would display ``bar'').

<p>If you insert links to external pages (web sites), its useful to add
the <tt>target="_blank"</tt> attribute to ensure pages come up in a new
browser window and not just in the current frame which looks awkward.
(Alternatively, you can use the <tt>target="_top"</tt> attribute
which replaces all frames in the current browser).

<p>Examples:

<pre>
//
// For more info on Ethernet and other LAN standards, see the
// &lt;a href="http://www.ieee802.org/" target="_blank"&gt;IEEE 802
// Committee's site&lt;/a&gt;.
//
</pre>
<p>
You can also use the <tt>&lt;a href=..&gt;</tt> tag to create links within the page:

<pre>
//
// See the &lt;a href="#resources"&gt;resources&lt;/a&gt; in this page.
// ...
// &lt;a name="resources"&gt;&lt;b&gt;Resources&lt;/b&gt;&lt;/a&gt;
// ...
//
</pre>
<p>
You can use the <tt>&lt;pre&gt;..&lt;/pre&gt;</tt> HTML tag to insert souce code examples
into the documentation. Line breaks and indentation will be preserved,
but HTML tags continue to be interpreted (or you can turn them off
with <tt>&lt;nohtml&gt;</tt>, see later).

<p>Example:

<pre>
// &lt;pre&gt;
// // my preferred way of indentation in C/C++ is this:
// &lt;b&gt;for&lt;/b&gt; (&lt;b&gt;int&lt;/b&gt; i=0; i&lt;10; i++)
// {
//     printf(&lt;i&gt;"%d\n"&lt;/i&gt;, i);
// }
// &lt;/pre&gt;
</pre>
<p>
will be rendered as

<p><pre>
// my preferred way of indentation in C/C++ is this:
<b>for</b> (<b>int</b> i=0; i&lt;10; i++)
{
    printf(<i>"%d\n"</i>, i);
}
</pre>

<p>HTML is also the way to create tables. The example below

<pre>
//
// &lt;table border="1"&gt;
//   &lt;tr&gt;  &lt;th&gt;#&lt;/th&gt; &lt;th&gt;number&lt;/th&gt; &lt;/tr&gt;
//   &lt;tr&gt;  &lt;td&gt;1&lt;/td&gt; &lt;td&gt;one&lt;/td&gt;    &lt;/tr&gt;
//   &lt;tr&gt;  &lt;td&gt;2&lt;/td&gt; &lt;td&gt;two&lt;/td&gt;    &lt;/tr&gt;
//   &lt;tr&gt;  &lt;td&gt;3&lt;/td&gt; &lt;td&gt;three&lt;/td&gt;  &lt;/tr&gt;
// &lt;/table&gt;
//
</pre>
<p>
will be rendered approximately as:

<p><table border>
<TR> <TD align=left>

<p><b>#</b> </TD> <TD align=left> <b>number</b> </TD></TR>
<TR> <TD align=left> 1 </TD> <TD align=left> one </TD></TR>
<TR> <TD align=left> 2 </TD> <TD align=left> two </TD></TR>
<TR> <TD align=left> 3 </TD> <TD align=left> three </TD></TR>
</table>

<p>
<H3><A NAME="sec370"/>11.2.5 Escaping HTML tags</H3>

<p>Sometimes may need to off interpreting HTML tags (<tt>&lt;i&gt;</tt>, <tt>&lt;b&gt;</tt>, etc.)
as formatting instructions, and rather you want them to appear as literal
<tt>&lt;i&gt;</tt>, <tt>&lt;b&gt;</tt> texts in the documentation. You can achieve this via
surrounding the text with the <tt>&lt;nohtml&gt;</tt>...<tt>&lt;/nohtml&gt;</tt> tag.
For example,

<pre>
// Use the &lt;nohtml&gt;&lt;i&gt;&lt;/nohtml&gt; tag (like &lt;tt&gt;&lt;nohtml&gt;&lt;i&gt;this&lt;/i&gt;&lt;/nohtml&gt;&lt;tt&gt;)
// to write in &lt;i&gt;italic&lt;/i&gt;.
</pre>
<p>
will be rendered as ``Use the &lt;i&gt; tag (like <tt>&lt;i&gt;this&lt;/i&gt;</tt>) to write
in <i>italic</i>.''

<p><tt>&lt;nohtml&gt;</tt>...<tt>&lt;/nohtml&gt;</tt> will also prevent <tt>opp_neddoc</tt>
from hyperlinking words that are accidentally the same as an existing
module or message name. Prefixing the word with a backslash will achieve
the same. That is, either of the following will do:

<pre>
// In &lt;nohtml&gt;IP&lt;/nohtml&gt; networks, routing is...
</pre>
<p>
<pre>
// In \IP networks, routing is...
</pre>

<p>Both will prevent hyperlinking the word <i>IP</i> if you happen to have
an <tt>IP</tt> module in the NED files.

<p>

<p><H3><A NAME="sec371"/>11.2.6 Where to put comments</H3>

<p>You have to put the comments where nedtool will find them.
This is a) above the documented item, or b) after the
documented item, on the same line.

<p>If you put it above, make sure there's no blank line left
between the comment and the documented item. Blank lines
detach the comment from the documented item.

<p>Example:
<pre>
// This is wrong! Because of the blank line, this comment is not
// associated with the following simple module!

simple Gen
    parameters:
    ...
endsimple
</pre>

<p>Do not try to comment groups of parameters together. The result
will be awkward.

<p>
<H3><A NAME="sec372"/>11.2.7 Customizing the title page</H3>

<p>The title page is the one that appears in the main frame after
opening the documentation in the browser. By default it contains
a boilerplate text with the generic title <i>``OMNeT++ Model Documentation''</i>.
You probably want to customize that, and at least change the title
to the name of the documented simulation model.

<p>You can supply your own version of the title page adding a <tt>@titlepage</tt>
directive to a file-level comment (a comment that appears at the top of
a NED file, but is separated from the first <tt>import</tt>, <tt>channel</tt>,
<tt>module</tt>, etc. definition by at least one blank line).
In theory you can place your title page definition into
any NED or MSG file, but it is probably a good idea to create
a separate <tt>index.ned</tt> file for it.

<p>The lines you write after the <tt>@titlepage</tt> line up to the next
<tt>@page</tt> line (see later) or the end of the comment will be used
as the title page.
You probably want to begin with a title because the documentation
tool doesn't add one (it lets you have full control over the
page contents). You can use the <tt>&lt;h1&gt;..&lt;/h1&gt;</tt> HTML tag
to define a title.

<p>Example:

<pre>
//
// @titlepage
// &lt;h1&gt;Ethernet Model Documentation&lt;/h1&gt;
//
// This documents the Ethernet model created by David Wu and refined by Andras
// Varga at CTIE, Monash University, Melbourne, Australia.
//
</pre>
<p>

<p><H3><A NAME="sec373"/>11.2.8 Adding extra pages</H3>

<p>You can add new pages to the documentation in a similar way as customizing
the title page. The directive to be used is <tt>@page</tt>, and it can
appear in any file-level comment (see above).

<p>The syntax of the <tt>@page</tt> directive is the following:

<pre>
// @page filename.html, Title of the Page
</pre>
<p>
Please choose a file name that doesn't collide with the files generated
by the documentation tool (such as <tt>index.html</tt>).
The page title you supply will appear on the top of the page as well as
in the page index.

<p>The lines after the <tt>@page</tt> line up to the next <tt>@page</tt> line
or the end of the comment will be used as the page body.
You don't need to add a title because the documentation tool
automatically adds one.

<p>Example:
<pre>
//
// @page structure.html, Directory Structure
//
// The model core model files and the examples have been placed
// into different directories. The &lt;tt&gt;examples/&lt;/tt&gt; directory...
//
//
// @page examples.html, Examples
// ...
//
</pre>

<p>You can create links to the generated pages using standard HTML,
using the <tt>&lt;a href="..."&gt;...&lt;/a&gt;</tt> tag. All HTML files are
placed in a single directory, so you don't have to worry about
specifying directories.

<p>Example:
<pre>
//
// @titlepage
// ...
// The structure of the model is described &lt;a href="structure.html"&gt;here&lt;/a&gt;.
//
</pre>

<p>
<H3><A NAME="sec374"/>11.2.9 Incorporating externally created pages</H3>

<p>You may want to create pages outside the documentation tool
(e.g. using a HTML editor) and include them in the documentation.
This is possible, all you have to do is declare such pages with
the <tt>@externalpage</tt> directive in any of the NED files, and
they will be added to the page index. The pages can then be linked to
from other pages using the HTML <tt>&lt;a href="..."&gt;...&lt;/a&gt;</tt> tag.

<p>The <tt>@externalpage</tt> directive is similar in syntax
<tt>@page</tt>:

<pre>
// @externalpage filename.html, Title of the Page
</pre>
<p>
The documentation tool does not check if the page exists
or not. It is your responsibility to copy them manually into
the directory of the generated documentation and then to make
sure the hyperlinks work.

<p>

<p><H2><A NAME="sec375"/>11.3 Invoking opp_neddoc</H2>

<p>The <tt>opp_neddoc</tt> tool accepts the following command-line options:

<p>
<pre>
opp_neddoc - NED and MSG documentation tool, part of OMNeT++
(c) 2003-2004 Andras Varga

Generates HTML model documentation from .ned and .msg files.

Usage: opp_neddoc options files-or-directories ...
 -a, --all    process all *.ned and *.msg files recursively
              ('opp_neddoc -a' is equivalent to 'opp_neddoc .')
 -o &lt;dir&gt;     output directory, defaults to ./html
 -t &lt;filename&gt;, --doxytagfile &lt;filename&gt;
              turn on generating hyperlinks to Doxygen documentation;
              &lt;filename&gt; specifies name of XML tag file generated by Doxygen
 -d &lt;dir&gt;, --doxyhtmldir &lt;dir&gt;
              directory of Doxygen-generated HTML files, relative to the
              opp_neddoc output directory (-o option). -t option must also be
              present to turn on linking to Doxygen. Default: ../api-doc/html
 -n, --no-figures
              do not generate diagrams
 -p, --no-unassigned-pars
              do not document unassigned parameters
 -x, --no-diagrams
              do not generate usage and inheritance diagrams
 -z, --no-source
              do not generate source code listing
 -s, --silent suppress informational messages
 -g, --debug  print invocations of external programs and other info
 -h, --help   displays this help text

Files specified as arguments are parsed and documented. For directories as
arguments, all .ned and .msg files under them (in that directory subtree) are
documented. Wildcards are accepted and they are NOT recursive, e.g.
foo/*.ned does NOT process files in foo/bar/ or any other subdirectory.

Bugs:  (1) handles only files with .ned and .msg extensions, other files are
silently ignored; (2) does not filter out duplicate files (they will show up
multiple times in the documentation); (3) on Windows, file names are handled
case sensitively.
</pre>

<p>
<H3><A NAME="sec376"/>11.3.1 Multiple projects</H3>

<p>The generated <tt>tags.xml</tt> can be used to generate other documentation
that refers to pages in this documentation via HTML links.

<p>
<H2><A NAME="sec377"/>11.4 How does opp_neddoc work?</H2>

<p><tt>*.ned</tt> and <tt>*.msg</tt> files are collected (e.g. via the <tt>find</tt>
command if you used the <tt>-a</tt> option on Unix) and processed
with <tt>nedtool</tt>. <tt>nedtool</tt> parses them and outputs the resulting syntax
tree in XML -- a single large XML file which contains all files.

<p>The <tt>*.ned</tt> files are processed with the <tt>-c</tt> (export-diagrams-and-exit)
option of <tt>gned</tt>. This causes <tt>gned</tt> to export diagrams for the
compound modules in Postscript. Postscript files are then converted
to GIFs using <tt>convert</tt> (part of the ImageMagick package).
<tt>gned</tt> also exports an <tt>images.xml</tt> file which describes which
image was generated from which compound module, and also contains
additional info (coordinates of submodule rectangles and icons in the image)
for creating clickable image maps.

<p>The XML file containing parsed NED and message files is then processed
with an XSLT stylesheet to generate HTML. XSLT is a very powerful way
of converting an XML document into another XML (or HTML, or text) document.
Additionally, the stylesheet reads <tt>images.xml</tt> and uses its contents
to make the compound module images clickable.
The stylesheet also outputs a <tt>tags.xml</tt> file which describes what is documented
in which .html file, so that external documentation can link to this one.

<p>As a final step, the comments in the generated HTML file are processed
with a perl script. The perl script also performs syntax hightlighting
of the source listings in the HTML, and puts hyperlinks on module,
channel, message, etc. names. (It uses the info in the <tt>tags.xml</tt> file
for the latter task.) This last step, comment formatting and source code
coloring whould have been very difficult to achieve from XSLT, which
(at least in its 1.0 version of the standard) completely lacks powerful
string manipulation functions. (Not even simple find/replace
is supported in strings, let alone regular expressions. Perhaps the
2.0 version of XSLT will improve on this.)

<p>The whole process is controlled by the <tt>opp_neddoc</tt> script.

<p>

<p>

</BODY>
</HTML>
<hr><hr><H1><A NAME="sec378"/>12 Parallel Distributed Simulation</H1>
<a name="cha:parallel-execution"></a>


<H2><A NAME="sec379"/>12.1 Introduction to Parallel Discrete Event Simulation</H2>

<p>OMNeT++ supports parallel execution<!--parallel simulation--> of large
simulations. The following paragraphs provide a brief picture
of the problems and methods of parallel
discrete event simulation (PDES<!--PDES-->). Interested readers are
strongly encouraged to look into the literature.

<p>For parallel execution, the model is to be partitioned into several
LPs (logical processes) that will be simulated independently on
different hosts or processors. Each LP will have its own local
Future Event Set, thus they will maintain their own local simulation
times. The main issue with parallel simulations is keeping LPs
synchronized in order to avoid violating the causality of events.
Without synchronization, a message sent by one LP could arrive in
another LP when the simulation time in the receiving LP has already
passed the timestamp (arrival time) of the message. This would break
causality<!--event!causality--> of events in the receiving LP.

<p>There are two broad categories of parallel simulation algorithms
that differ in the way they handle causality problems outlined
above:

<p><ol>
  <li><b>Conservative algorithms</b><!--parallel simulation!conservative-->
    prevents incausalities from happening. The Null Message Algorithm
    exploits knowledge of the time when LPs send messages to other LPs,
    and uses `null' messages to propagate this information to other LPs.
    If an LP knows it won't receive any messages from other
    LPs until <i>t+&Delta; t</i> simulation time, it may advance until
    <i>t+&Delta; t</i> without the need for external synchronization.
    Conservative simulation tends to converge to sequential simulation
    (slowed down by communication between LPs) if there's not
    enough parallelism in the model, or parallelism is not exploited
    by sending a sufficient number of `null' messages.

<p>  <li><b>Optimistic synchronization</b><!--parallel simulation!optimistic-->
    allows incausalities to occur, but detects and
    repairs them. Repairing involves rollbacks to a previous state,
    sending out anti-messages to cancel messages sent out during the
    period that is being rolled back, etc.  Optimistic synchronization
    is extremely difficult to implement, because it requires periodic
    state saving and the ability to restore previous states. In any
    case, implementing optimistic synchronization in OMNeT++ would
    require -- in addition to a more complicated simulation kernel --
    writing significantly more complex simple<!--module!simple-->
    module code from the user.  Optimistic synchronization may be slow
    in cases of excessive rollbacks.
</ol>

<p>
<H2><A NAME="sec380"/>12.2 Assessing available parallelism in a simulation model</H2>

<p>OMNeT++ currently supports conservative synchronization
via the classic Chandy-Misra-Bryant (or null message) algorithm
[<a href="#bib-chandymisra79">chandymisra79</a>].
To assess how efficiently a simulation can be parallelized
with this algorithm, we'll need the following variables:

<p><ul>
  <li><i>P</i> <i>performance</i> represents the number of events processed per
    second (ev/sec).
       <br><ul><font size=-1>[Notations: <i>ev:</i> events, <i>sec:</i> real seconds,
       <i>simsec:</i> simulated seconds]</font></ul>
    <i>P</i> depends on the performance of the hardware and the computation-intensiveness
    of processing an event. <i>P</i> is independent of the size of the model.
    Depending on the nature of the simulation model and the performance of the
    computer, <i>P</i> is usually in the range of 20,000..500,000 ev/sec.
  <li><i>E</i> <i>event density</i> is the number of events that occur per
    simulated second (ev/simsec). <i>E</i> depends on the model only, and not
    where the model is executed. <i>E</i> is determined by the size, the detail level
    and also the nature of the simulated system (e.g. cell-level ATM models
    produce higher <i>E</i> values than call center simulations.)
  <li><i>R</i> <i>relative speed</i> measures the simulation time advancement
    per second (simsec/sec). <i>R</i> strongly depends on both the model and
    on the software/hardware environment where the model executes.
    Note that <i>R = P/E</i>.
  <li><i>L</i> <i>lookahead</i> is measured in simulated seconds (simsec).
    When simulating telecommunication networks and using link delays as
    lookahead, <i>L</i> is typically in the msimsec-<i>&mu;</i>simsec range.
  <li><i>&tau;</i> <i>latency</i> (sec) characterizes the parallel simulation hardware.
    <i>&tau;</i> is the latency of sending a message from one LP to another. <i>&tau;</i>
    can be determined using simple benchmark programs. The authors' measurements
    on a Linux cluster interconnected via a 100Mb Ethernet switch using MPI
    yielded <i>&tau;</i>=22<i>&mu;</i>s which is consistent with measurements reported
    in [<a href="#bib-ongfarrell2000">ongfarrell2000</a>]. Specialized hardware such as
    Quadrics Interconnect [<a href="#bib-quadrics">quadrics</a>] can provide <i>&tau;</i>=5<i>&mu;</i>s or better.
</ul>

<p>In large simulation models, <i>P</i>, <i>E</i> and <i>R</i> usually stay relatively constant
(that is, display little fluctuations in time). They are also intuitive and
easy to measure. The OMNeT++ displays these values on the GUI while the simulation
is running, see Figure <a href="#fig:perfbar-screenshot">below</a>. Cmdenv can also be configured
to display these values.

<p>
  <div align=center>
    <img src="perfbar-screenshot.gif">
    <center><i>Figure: Performance bar in OMNeT++ showing <i>P</i>, <i>R</i> and <i>E</i></i></center>
    <a name="fig:perfbar-screenshot"></a>
  </div>

<p>
After having approximate values of <i>P</i>, <i>E</i>, <i>L</i> and <i>&tau;</i>,
calculate the <i>&lambda;</i> <i>coupling factor</i> as the ratio of <i>LE</i> and <i>&tau; P</i>:

<p><i>&lambda; = (LE) / (&tau; P)</i>

<p>Without going into the details: if the resulting <i>&lambda;</i> value is at
minimum larger than one, but rather in the range 10..100, there is
a good change that the simulation will perform well when run in
parallel. With <i>&lambda; &lt; 1</i>, poor performance is guaranteed.
For details see the paper [<a href="#bib-ParsimCrit03">ParsimCrit03</a>].

<p>
<H2><A NAME="sec381"/>12.3 Parallel distributed simulation support in OMNeT++</H2>

<p><H3><A NAME="sec382"/>12.3.1 Overview</H3>

<p>This chapter presents the parallel simulation architecture
of OMNeT++. The design allows simulation models to be run
in parallel without code modification -- it only requires configuration.
The implementation relies on the approach of placeholder modules
and proxy gates to instantiate the model on different LPs --
the placeholder approach allows simulation techniques such as
topology discovery and direct message sending to work unmodified with
PDES. The architecture is modular and extensible, so it can
serve as a framework for research on parallel simulation.

<p>The OMNeT++ design places a big emphasis on
<i>separation of models from experiments</i>. The main rationale
is that usually a large number of simulation experiments need to be done
on a single model before a conclusion can be drawn about the real system.
Experiments tend to be ad-hoc and change much faster than simulation
models, thus it is a natural requirement to be able to
carry out experiments without disturbing the simulation model itself.

<p>Following the above principle, OMNeT++ allows simulation models
to be executed in parallel without modification. No special instrumentation
of the source code or the topology description is needed,
as partitioning and other PDES configuration is entirely described
in the configuration files.

<p>OMNeT++ supports the Null Message Algorithm with static
topologies, using link delays as lookahead. The laziness of null message
sending can be tuned. Also supported is the Ideal Simulation Protocol
(ISP) introduced by Bagrodia in 2000 [<a href="#bib-bagrodia00">bagrodia00</a>]. ISP is
a powerful research vehicle to measure the efficiency of
PDES algorithms, both optimistic and conservative;
more precisely, it helps determine the maximum speedup achievable
by any PDES algorithm for a particular model and simulation environment.
In OMNeT++, ISP can be used for benchmarking the performance of the
Null Message Algorithm.
Additionally, models can be executed without any synchronization, which
can be useful for educational purposes (to demonstrate the need for
synchronization) or for simple testing.

<p>For the communication between LPs (logical processes), OMNeT++
primarily uses MPI, the Message Passing Interface standard
[<a href="#bib-mpiforum94">mpiforum94</a>].  An alternative communication mechanism is based on
named pipes, for use on shared memory multiprocessors without the need
to install MPI.  Additionally, a file system based communication mechanism
is also available. It communicates via text files created in a shared
directory, and can be useful for educational purposes (to analyse or
demonstate messaging in PDES algorithms) or to debug PDES algorithms.
Implementation of a shared memory-based communication mechanism is also planned
for the future, to fully exploit the power of multiprocessors without
the overhead of and the need to install MPI.

<p>Nearly every model can be run in parallel. The constraints are the following:
<ul>
  <li>modules may communicate via sending messages only (no direct method call
        or member access) unless mapped to the same processor
  <li>no global variables
  <li>there are some limitations on direct sending (no sending to a <i>sub</i>module
        of another module, unless mapped to the same processor)
  <li>lookahead must be present in the form of link delays
  <li>currently static topologies are supported (we are working on a
      research project that aims to eliminate this limitation)
</ul>

<p>PDES support in OMNeT++ follows a modular and extensible architecture.
New communication mechanisms can be added by implementing a compact
API (expressed as a C++ class) and registering the implementation --
after that, the new communications mechanism can be selected for use
in the configuration.

<p>New PDES synchronization algorithms can be added in a similar way.
PDES algorithms are also represented by C++ classes that have
to implement a very small API
to integrate with the simulation kernel.
Setting up the model on various LPs as well as relaying
model messages across LPs is already taken care of and
not something the implementation of the synchronization algorithm
needs to worry about (although it can intervene if needed,
because the necessary hooks are provided).

<p>The implementation of the Null Message Algorithm is also
modular in itself in that the lookahead discovery can be plugged
in via a defined API. Currently implemented lookahead
discovery uses link delays, but it is possible to
implement more sophisticated ones and select them in the
configuration.

<p>

<p><H3><A NAME="sec383"/>12.3.2 Parallel Simulation Example</H3>

<p>We will use the Parallel CQN example simulation for demonstrating the
PDES capabilities of OMNeT++.
The model consists of <i>N</i> tandem queues where each tandem consists
of a switch and <i>k</i> single-server queues with exponential service times
(Figure <a href="#fig:cqn-model">below</a>).
The last queues are looped back to their switches. Each switch
randomly chooses the first queue of one of the tandems as destination,
using uniform distribution. The queues and switches are connected
with links that have nonzero propagation delays.
Our OMNeT++ model for CQN wraps tandems into compound modules.

<p>

<p>  <div align=center>
    <img src="cqn-model.gif">
    <center><i>Figure: The Closed Queueing Network (CQN) model</i></center>
    <a name="fig:cqn-model"></a>
  </div>

<p>
To run the model in parallel, we assign tandems to different LPs
(Figure <a href="#fig:cqn-partitioning">below</a>). Lookahead is provided
by delays on the marked links.

<p>
  <div align=center>
    <img src="cqn-partitioning.gif">
    <center><i>Figure: Partitioning the CQN model</i></center>
    <a name="fig:cqn-partitioning"></a>
  </div>

<p>
To run the CQN model in parallel, we have to configure it for parallel
execution. In OMNeT++, the configuration is in a text file called
<tt>omnetpp.ini</tt>. For configuration, first we have to specify
partitioning, that is, assign modules to processors. This is done
by the following lines:

<pre>
[Partitioning]
*.tandemQueue[0]**.partition-id = 0
*.tandemQueue[1]**.partition-id = 1
*.tandemQueue[2]**.partition-id = 2
</pre>
<p>
The numbers after the equal sign identify the LP.

<p>Then we have to select the communication library and the parallel
simulation algorithm, and enable parallel simulation:

<pre>
[General]
parallel-simulation=true
parsim-communications-class = "cMPICommunications"
parsim-synchronization-class = "cNullMessageProtocol"
</pre>
<p>
When the parallel simulation is run, LPs are represented
by multiple running instances of the same program.
When using LAM-MPI [<a href="#bib-lammpi">lammpi</a>], the mpirun program (part of LAM-MPI)
is used to launch the program on the desired processors.
When named pipes or file communications is selected, the opp_prun
OMNeT++ utility can be used to start the processes.
Alternatively, one can run the processes by hand (the -p flag
tells OMNeT++ the index of the given LP and the total number of LPs):

<pre>
./cqn -p0,3 &
./cqn -p1,3 &
./cqn -p2,3 &
</pre>
<p>
For PDES, one will usually want to select the command-line user interface,
and redirect the output to files. (OMNeT++ provides the necessary
configuration options.)

<p>The graphical user interface of OMNeT++ can also be used
(as evidenced by Figure <a href="#fig:parsim-screenshot">below</a>),
independent of the selected communication mechanism.
The GUI interface can be useful for educational or demonstation purposes.
OMNeT++ displays debugging output about the Null Message Algorithm,
EITs and EOTs can be inspected, etc.

<p>


<p>
  <div align=center>
    <img src="parsim-screenshot.gif">
    <center><i>Figure: Screenshot of CQN running in three LPs</i></center>
    <a name="fig:parsim-screenshot"></a>
  </div>

<p>

<p>
<H3><A NAME="sec384"/>12.3.3 Placeholder modules, proxy gates</H3>

<p>When setting up a model partitioned to several LPs,
OMNeT++ uses placeholder modules and proxy gates.
In the local LP, placeholders represent sibling submodules
that are instantiated on other LPs.
With placeholder modules, every module has all of its siblings
present in the local LP -- either as placeholder or as the ``real thing''.
Proxy gates take care of forwarding messages to the LP where
the module is instantiated (see Figure <a href="#fig:plach">below</a>).

<p>The main advantage of using placeholders is that algorithms such as
topology discovery embedded in the model can be used with PDES unmodified.
Also, modules can use direct message sending to any sibling module,
including placeholders. This is so because the destination of direct message
sending is an input gate of the destination module -- if the destination
module is a placeholder, the input gate will be a proxy gate which
transparently forwards the messages to the LP where the ``real'' module
was instantiated. A limitation is that the destination of direct message
sending cannot be a <i>submodule</i> of a sibling (which is
probably a bad practice anyway, as it violates encapsulation),
simply because placeholders are empty and so its submodules are
not present in the local LP.

<p>Instantiation of compound modules is slightly more complicated.
Since submodules can be on different LPs, the compound module may
not be ``fully present'' on any given LP, and it may have to be
present on several LPs (wherever it has submodules instantiated).
Thus, compound modules are instantiated wherever they have
at least one submodule instantiated, and are represented by placeholders
everywhere else (Figure <a href="#fig:inst">below</a>).

<p>

<p>  <div align=center>
    <img src="placeholders.gif">
    <center><i>Figure: Placeholder modules and proxy gates</i></center>
    <a name="fig:plach"></a>
  </div>

<p>

<p>  <div align=center>
    <img src="placeholders2.gif">
    <center><i>Figure: Instantiating compound modules</i></center>
    <a name="fig:inst"></a>
  </div>

<p>

<p>
<H3><A NAME="sec385"/>12.3.4 Configuration</H3>

<p>Parallel simulation configuration is the <tt>[General]</tt> section of <tt>omnetpp.ini</tt>.

<p><table border>
<TR> <TD align=left>

<p><b>Entry and default value</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=left colspan=2><b>[General]</b></TD></TR>
<TR> <TD align=left> 
parallel-simulation = &lt;true/false&gt;<br>
default: false
</TD> <TD align=left>
Enables parallel distributed simulation. The following configuration
entries are only examined if <tt>parallel-simulation=true</tt>
</TD></TR>
<TR> <TD align=left> 
parsim-debug = &lt;true/false&gt;<br>
default: true
</TD> <TD align=left>
Enables debugging output
</TD></TR>
<TR> <TD align=left> 
parsim-mpicommunications-mpibuffer = &lt;bytes&gt;<br>
default: 256K * (numPartitions-1) + 16K
</TD> <TD align=left>
Size of MPI send buffer to allocate; see MPI_Buffer_attach()
MPI call. If the buffer is too small, a deadlock can occur.
</TD></TR>
<TR> <TD align=left> 
parsim-namedpipecommunications-prefix = &lt;string&gt;<br>
default: "omnetpp" or "comm/"
</TD> <TD align=left>
Controls the naming of named pipes.
Windows: default value is "omnetpp", which means that pipe names will be of the form
"\\.\pipe\omnetpp-xx-yy"
(where xx and yy are numbers).
Unix: default value is "comm/", which means that the named pipes will
be created with the name "comm/pipe-xx-yy". The "comm/" subdirectory must
already exist when the simulation is launched.
</TD></TR>
<TR> <TD align=left> 
parsim-filecommunications-prefix = &lt;string&gt;<br>
default: "comm/"
</TD> <TD align=left>
(see below)
</TD></TR>
<TR> <TD align=left> 
parsim-filecommunications-preserve-read = &lt;true/false&gt;<br>
default: false
</TD> <TD align=left>
(see below)
</TD></TR>
<TR> <TD align=left> 
parsim-filecommunications-read-prefix = &lt;string&gt;<br>
default: "comm/read/"
</TD> <TD align=left>
The above 3 options control the <tt>cFileCommunications</tt> class.
By default, it deletes files that were read. By enabling the
"preserve-read" setting, you can make it move read files to
another directory instead ("comm/read/" by default).
BEWARE: for mysterious reasons, it appears that there cannot be more
than about 19800 files in a directory. When that point is reached,
an exception is thrown somewhere inside the standard C library, which
materializes itself in OMNeT++ as an "Error: (null)" message...
Strangely, this can be reproduced in both Linux and Windows.
</TD></TR>
<TR> <TD align=left> 
parsim-nullmessageprotocol-lookahead-class = &lt;class name string&gt;<br>
default: "cLinkDelayLookahead"
</TD> <TD align=left>
Selects the lookahead class for the Null Message Algorithm; the
class must be subclassed from cNMPLookahead.
</TD></TR>
<TR> <TD align=left> 
parsim-nullmessageprotocol-laziness = &lt;0..1&gt;<br>
default: 0.5
</TD> <TD align=left>
Controls how often the Null Message Algorithm should send out null
messages; the value is understood in proportion to the lookahead,
e.g. 0.5 means every lookahead/2 simsec.
</TD></TR>
<TR> <TD align=left> 
parsim-idealsimulationprotocol-tablesize = &lt;int&gt;<br>
default: 100,000
</TD> <TD align=left>
Size of chunks (in table entries) in which the external events
file (recorded by cISPEventLogger) should be loaded.
(one entry is 8 bytes, so 100,000 corresponds to ~800K allocated
memory)

<p></table>

<p>

<p>
When you are using cross-mounted home directories (the simulation's
directory is on a disk mounted on all nodes of the cluster),
a useful configuration setting is

<pre>
[General]
fname-append-host=yes
</pre>
<p>
It will cause the host names to be appended to the names of
all output vector files, so that partitions do not overwrite each other's
output files. (See section <a href="#sec326">[8.10.3]</a>)

<p>

<p>

<p><H3><A NAME="sec386"/>12.3.5 Design of PDES Support in OMNeT++</H3>

<p>Design of PDES support in OMNeT++ follows a layered approach,
with a modular and extensible architecture. The overall
architecture is depicted in Figure <a href="#fig:parsim-arch">below</a>.

<p>
  <div align=center>
    <img src="parsim-arch.gif">
    <center><i>Figure: Architecture of OMNeT++ PDES implementation</i></center>
    <a name="fig:parsim-arch"></a>
  </div>

<p>
The parallel simulation subsytem is an optional component
itself, which can be removed from the simulation kernel
if not needed. It consists of three layers, from the bottom up:
communication layer, partitioning layer and synchronization layer.

<p>The purpose of the <i>Communication layer</i> is to
provide elementary messaging services between partitions for the
upper layer. The services include send, blocking receive,
nonblocking receive and broadcast. The send/receive operations
work with <i>buffers</i>, which encapsulate packing and unpacking
operations for primitive C++ types. The message class and
other classes in the simulation library can pack and unpack
themselves into such buffers. The Communications layer API
is defined in the <tt>cFileCommunications</tt> interface
(abstract class); specific implementations like the MPI
one (<tt>cMPICommunications</tt>) subclass from this,
and encapsulate MPI send/receive calls. The matching buffer
class <tt>cMPICommBuffer</tt> encapsulates MPI pack/unpack
operations.

<p>The <i>Partitioning layer</i> is responsible for instantiating
modules on different LPs according to the partitioning specified
in the configuration, for configuring proxy gates.
During the simulation, this layer also ensures that cross-partition
simulation messages reach their destinations. It intercepts messages
that arrive at proxy gates and transmits them to the destination LP
using the services of the communication layer. The receiving LP
unpacks the message and injects it at the gate the proxy gate points at.
The implementation basically encapsulates the
<tt>cParsimSegment</tt>, <tt>cPlaceHolderModule</tt>,
<tt>cProxyGate</tt> classes.

<p>The <i>Synchronization layer</i> encapsulates the parallel
simulation algorithm. Parallel simulation algorithms are also represented
by classes, subclassed from the <tt>cParsimSynchronizer</tt> abstract class.
The parallel simulation algorithm is invoked on the following hooks:
event scheduling, processing model messages outgoing from the LP,
and messages (model messages or internal messages) arriving
from other LPs. The first hook, event scheduling is a function
invoked by the simulation kernel to determine the next simulation
event; it also has full access to the future event set (FES<!--FES-->) and
can add/remove events for its own use.
Conservative parallel simulation algorithms will use this hook
to block the simulation if the next event is unsafe, e.g. the
null message algorithm implementation (<tt>cNullMessageProtocol</tt>)
blocks the simulation if an EIT has been reached until a null message
arrives (see [<a href="#bib-bagrodia00">bagrodia00</a>] for terminology); also it uses
this hook to periodically send null messages. The second hook
is invoked when a model message is sent to another LP;
the null message algorithm uses this hook to piggyback null
messages on outgoing model messages. The third hook is invoked
when any message arrives from other LPs, and it allows the
parallel simulation algorithm to process its own internal messages
from other partitions; the null message algorithm processes
incoming null messages here.

<p>The null message protocol implementation itself is modular,
it employs a separate, configurable lookahead discovery object.
Currently only link delay based lookahead discovery has been
implemented, but it is possible to implement more sophisticated
ones.

<p>The Ideal Simulation Protocol (ISP; see [<a href="#bib-bagrodia00">bagrodia00</a>])
implementation consists in fact of two parallel simulation
protocol implementations:
the first one is based on the null message algorithm and
additionally records the external events (events received
from other LPs) to a trace file; the second one executes
the simulation using the trace file to find out which
events are safe and which are not.

<p>Note that although we implemented a conservative protocol,
the provided API itself would allow implementing optimistic
protocols, too. The parallel simulation algorithm has
access to the executing simulation model, so it could perform
saving/restoring model state if model objects support this
  <br><ul><font size=-1>[Unfortunately, support for state saving/restoration
  needs to be individually and manually added to each class
  in the simulation, including user-programmed simple modules.]</font></ul>.

<p>We also expect that because of the modularity, extensibility and
clean internal architecture of the parallel simulation subsystem,
the OMNeT++ framework has the potential to become a preferred platform
for PDES research.

<p>
</BODY>
</HTML>
<hr><hr><H1><A NAME="sec387"/>13 Customization and Embedding</H1>
<a name="cha:opp-design"></a>

<p><H2><A NAME="sec388"/>13.1 Architecture</H2>

<p>OMNeT++ has a modular architecture. The following diagram shows the
high-level architecture of OMNeT++ simulations:

<p>
  <div align=center>
    <img src="usmanFig18.gif">
    <center><i>Figure: Architecture of OMNeT++ simulation programs</i></center>
  </div>

<p>
The rectangles in the picture represent components:

<p><ul>
  <li><b>Sim</b> is the simulation kernel and class
    library<!--simulation!kernel-->. Sim exists as a library you link
    your simulation program with.
       <br><ul><font size=-1>[Use of dynamic (shared) libraries is also possible, but
       for simplicity we'll use the word <i>linking</i> here.]</font></ul>
    
  <li><b>Envir</b> is another library which contains all code
    that is common to all user interfaces. <tt>main()</tt> is also in Envir.
    Envir provides services like ini file handling for specific user interface
    implementations. Envir presents itself towards Sim and the executing model
    via the <tt>ev</tt> facade object, hiding all other user interface internals.
    Some aspects of Envir can be customized<!--customization--> via plugin
    interfaces. Embedding OMNeT++ into applications<!--embedding--> can
    be achieved implementing a new user interface in addition to Cmdenv and Tkev,
    or by replacing Envir with another implementation of <tt>ev</tt>
    (see sections <a href="#sec397">[13.5.3]</a> and
    <a href="#sec389">[13.2]</a>.)
  <li><b>Cmdenv and Tkenv</b> are specific user interface
    implementations. A simulation is linked with
    either Cmdenv or Tkenv.
  <li>The <b>Model Component Library</b> consists of simple module definitions and
    their C++ implementations, compound module types, channels, networks,
    message types and in general everything that belongs to models and
    has been linked into the simulation program. A simulation program is
    able to run any model that has all necessary components linked in.
  <li>The <b>Executing Model</b> is the model that has been set up
    for simulation. It contains objects (modules, channels, etc.) that
    are all instances of components in the model component library.
</ul>

<p>The arrows in the figure show how components interact with
each other:

<p><ul>
  <li><b>Executing Model vs Sim</b>. The simulation kernel
    manages the future events and invokes modules in the executing model
    as events occur. The modules of the executing model are stored
    in the main object of Sim, <tt>simulation</tt> (of class <tt><a href="../api/classcSimulation.html">cSimulation</a></tt>).
    In turn, the executing model calls functions in the
    simulation kernel and uses classes in the Sim library.
  <li><b>Sim vs Model Component Library</b>. The simulation kernel
    instantiates simple modules and other components when the simulation model
    is set up at the beginning of the simulation run. It also refers
    to the component library when dynamic module creation is used.
    The machinery for registering and looking up components in the model
    component library is implemented as part of Sim.
  <li><b>Executing Model vs Envir</b>. The <tt>ev</tt> object, logically
    part of Envir, is the facade of the user interface towards the executing model.
    The model uses <tt>ev</tt> to write debug logs (<tt>ev&lt;&lt;</tt>, <tt>ev.printf()</tt>).
  <li><b>Sim vs Envir</b>. Envir is in full command of what
    happens in the simulation program. Envir contains the <tt>main()</tt> function
    where execution begins. Envir determines which models should be set up
    for simulation, and instructs Sim to do so. Envir contains the main
    simulation loop (<i>determine-next-event</i>, <i>execute-event</i>
    sequence) and invokes the simulation kernel for the necessary
    functionality (event scheduling and event execution are implemented in Sim).
    Envir catches and handles errors and exceptions that occur
    in the simulation kernel or in the library
    classes during execution. Envir presents a single facade object (<tt>ev</tt>)
    that represents the environment (user interface) toward Sim -- no Envir
    internals are visible to Sim or the executing model.
    During simulation model setup, Envir supplies parameter values for
    Sim when Sim asks for them. Sim writes output vectors via Envir,
    so one can redefine the output vector storing mechanism by changing Envir.
    Sim and its classes use Envir to print debug information.
  <li><b>Envir vs Tkenv and Cmdenv</b>. Envir defines <tt>TOmnetApp</tt>
    as a base class for user interfaces, and Tkenv and Cmdenv both subclass
    from <tt>TOmnetApp</tt>. The <tt>main()</tt> function provided as part of Envir
    determines the appropriate user interface class (subclassed from
    <tt>TOmnetApp</tt>), creates an instance and runs it -- whatever
    happens next (opening a GUI window or running as a command-line program)
    is decided in the <tt>run()</tt> method of the appropriate <tt>TOmnetApp</tt>
    subclass. Sim's or the model's calls on the <tt>ev</tt> object are
    simply forwarded to the <tt>TOmnetApp</tt> instance. Envir presents
    a framework and base functionality to Tkenv and Cmdenv via the methods of
     <tt>TOmnetApp</tt> and some other classes.)
</ul>

<p>
<H2><A NAME="sec389"/>13.2 Embedding OMNeT++</H2>
<a name="sec:ch-opp-design:embedding"></a>

<p>This section discusses the issues of embedding the simulation kernel
or a simulation model into a larger application.

<p>What you'll absolutely need for a simulation to run is the Sim library. You
probably do not want to keep the appearance of the simulation program, so
you do not want Cmdenv and Tkenv. You may or may not want to keep Envir.
You can keep Envir if its philosophy and the infrastructure it provides
(<tt>omnetpp.ini</tt>, certain command-line options etc.) fit into your
design. Then your application, the embedding program will take the place of
Cmdenv and Tkenv.

<p>If Envir does not fit your needs (for example, you want the model
parameters to come from a database not from <tt>omnetpp.ini</tt>), then you
have to replace it. Your Envir replacement (the embedding application,
practically) must implement the <tt><a href="../api/classcEnvir.html">cEnvir</a></tt> member functions from
<tt>envir/cenvir.h</tt>, but you have full control over the simulation.

<p>Normally, code that sets up a network or builds the internals of a
compound module comes from compiled NED source.  You may not like the
restriction that your simulation program can only simulate networks
whose setup code is linked in. No problem; your program can contain
pieces of code similar to what is currently generated by nedtool and then
it can build any network whose components (primarily the simple modules)
are linked in. Moreover, it is possible to write an integrated environment
where you can put together a network using a graphical editor and right
after that you can run it, without intervening NED compilation and
linkage.

<p>

<p>

<p><H2><A NAME="sec390"/>13.3 Sim: the simulation kernel and class library</H2>

<p>There is little to say about Sim here, since chapters
<a href="#sec155">[4]</a> and <a href="#sec223">[6]</a>,
and part of chapter <a href="#sec206">[5]</a> are all about
this topic. Classes covered in those chapters are documented
in more detail in the API Reference generated by Doxygen.
What we can do here is elaborating on some internals
that have not been covered in the general chapters.

<p>The source code for the simulation kernel<!--simulation!kernel-->
and class library reside in the <tt>src/sim/</tt> subdirectory.

<p>
<H3><A NAME="sec391"/>13.3.1 The global simulation object</H3>

<p>The global <tt>simulation</tt> object is an instance of <tt><a href="../api/classcSimulation.html">cSimulation</a></tt>.
It stores the model, and encapsulates much of the functionality
of setting up and running a simulation model.

<p><tt>simulation</tt> has two basic roles:

<p><ul>
  <li>it stores modules of the executing model
  <li>it holds the future event set (FES<!--FES-->) object
</ul>

<p>

<p><H3><A NAME="sec392"/>13.3.2 The coroutine package</H3>

<p>The coroutine package is in fact made up of two coroutine
packages<!--coroutine-->:

<p><ul>
  <li> A portable coroutine package creates all coroutine stacks
     inside the main stack. It is based on Kofoed's solution[<a href="#bib-Kofoed95">Kofoed95</a>].
     It allocates stack by deep-deep recursions and then plays with
     <tt>setjmp()</tt> and <tt>longjmp()</tt> to switch from one to another.

<p>  <li> On Windows, the Fiber functions (<tt>CreateFiber()</tt>,
     <tt>SwitchToFiber()</tt>, etc) are used, which are part of
     the standard Win32 API.
</ul>

<p>The coroutines are represented by the <tt><a href="../api/classcCoroutine.html">cCoroutine</a></tt>
class. <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt> has <tt><a href="../api/classcCoroutine.html">cCoroutine</a></tt> as one a
base class.

<p>

<p><H2><A NAME="sec393"/>13.4 The Model Component Library</H2>

<p>All model components (simple module definitions and their C++
implementations, compound module types, channels, networks,
message types, etc.) that you compile and link into a simulation
program are registered in the Model Component Library.
Any model that has all its necessary components in the
component library of the simulation program can be run by that
simulation program.

<p>If your simulation program is linked with Cmdenv or Tkenv,
you can have the contents of its component library printed,
using the -h switch.

<pre>
% ./fddi -h

OMNeT++ Discrete Event Simulation  (C) 1992-2004 Andras Varga
...
Available networks:
  FDDI1
  NRing
  TUBw
  TUBs

Available modules:
  FDDI_MAC
  FDDI_MAC4Ring
  ...

Available channels:
  ...
End run of OMNeT++
</pre>
<p>
Information on components are kept on registration lists.
There are macros for registering components (that is, for adding
them to the registeration lists):
<tt><tt>Define_Module()</tt></tt>, <tt><tt>Define_Module_Like()</tt></tt>,
<tt><tt>Define_Network()</tt></tt>, <tt><tt>Define_Function()</tt></tt>,
<tt>Register_Class()</tt>, and a few others. For components defined
in NED files, the macro calls are generated by the NED compiler;
in other cases you have to write them in your C++ source.

<p>Let us see the module registrations as an example. The

<pre>
Define_Module(FIFO);
</pre>
<p>
macro expands to the following code:

<pre>
static <a href="../api/classcModule.html">cModule</a> *FIFO__create(const char *name, <a href="../api/classcModule.html">cModule</a> *parentmod)
{
    return new FIFO(name, parentmod);
}

EXECUTE_ON_STARTUP( FIFO__mod,
    modtypes.instance()-&gt;add(
       new <a href="../api/classcModuleType.html">cModuleType</a>("FIFO","FIFO",(ModuleCreateFunc)FIFO__create)
    );
)
</pre>
<p>
When the simulation program starts up, a new <tt><a href="../api/classcModuleType.html">cModuleType</a></tt>
object will be added to the <tt>modtypes</tt> object, which holds the list
of available module types. The <tt><a href="../api/classcModuleType.html">cModuleType</a></tt> object will act as a factory:
when its create() method is called it will produce a new module object
of class <tt>FIFO</tt> via the above static function <tt>FIFO__create</tt>.

<p>The <tt><a href="../api/classcModuleType.html">cModuleType</a></tt> object also stores the name of the corresponding
NED module declaration. This makes it possible to add the gates and parameters
declared in NED to the module when it is created.

<p>The machinery for managing the registration lists are part
of the Sim library. Registration lists are implemented
as global objects.

<p>The registration lists are:

<p><table border>
<TR> <TD align=left>

<b>List variable</b>
</TD> <TD align=left>
<b>Macro/</b><br>
<b>Objects on list</b>
</TD> <TD align=left>
<b>Function</b> </TD></TR>
<TR> <TD align=left> <tt>networks</tt>
</TD> <TD align=left>
<tt><tt>Define_Network()</tt></tt> <br>
<br>
<tt><tt><a href="../api/classcNetworkType.html">cNetworkType</a></tt></tt>
</TD> <TD align=left>
 List of available networks<!--network!list of-->.
Every <tt><a href="../api/classcNetworkType.html">cNetworkType</a></tt> object is a factory for a specific
network type. That is, a <tt><a href="../api/classcNetworkType.html">cNetworkType</a></tt> object has methods
for setting up a specific network.
<tt>Define_Network()</tt> macros occur in the code generated by the NED
compiler.</TD></TR>
<TR> <TD align=left> <tt>modtypes</tt>
</TD> <TD align=left>
<tt><tt>Define_Module()</tt>,</tt> <br>
<tt><tt>Define_Module_Like()</tt>,</tt>  <br>
<br>
<tt><tt><a href="../api/classcModuleType.html">cModuleType</a></tt></tt>
</TD> <TD align=left>
 List of available module types.
Every <tt><a href="../api/classcModuleType.html">cModuleType</a></tt> object is a factory for a specific module
type. Usually, <tt>Define_Module()</tt> macros for compound modules occur in
the code generated by the NED compiler; for simple modules,
the <tt>Define_Module()</tt> lines are added by the user.</TD></TR>
<TR> <TD align=left> <tt>channeltypes</tt>
</TD> <TD align=left>
<tt>Define_Channel()</tt> <br>
<br>
<tt><a href="../api/classcChannelType.html">cChannelType</a></tt>
</TD> <TD align=left>
 List of channel types.
Every <tt><a href="../api/classcChannelType.html">cChannelType</a></tt> object acts as a factory for a channel type,
a class derived from <tt><a href="../api/classcChannel.html">cChannel</a></tt>. </TD></TR>
<TR> <TD align=left> <tt>classes</tt>
</TD> <TD align=left>
<tt>Register_Class()</tt> <br>
<br>
<tt><a href="../api/classcClassRegister.html">cClassRegister</a></tt>
</TD> <TD align=left>
 List of available classes of which one can create
an instance.
Every <tt><a href="../api/classcClassRegister.html">cClassRegister</a></tt> object is a factory for objects
of a specific class. The list is used by the <tt>createOne()</tt> function:
it can create an object of any class, given the class name as a string.
(E.g. the statement <tt>ptr = createOne("<a href="../api/classcArray.html">cArray</a>")</tt> creates a <tt><a href="../api/classcArray.html">cArray</a></tt> object.)
To enable a class to work with <tt>createOne()</tt>, one has to register it using the
<tt>Register_Class(classname)</tt> macro</TD></TR>
<TR> <TD align=left> <tt>functions</tt>
</TD> <TD align=left>
<tt><tt>Define_Function()</tt></tt> <br>
<br>
<tt><tt><a href="../api/classcFunctionType.html">cFunctionType</a></tt></tt>
</TD> <TD align=left>
 List of functions taking <tt>double</tt>s and returning a <tt>double</tt>
(see type <tt>MathFuncNoArg</tt>...<tt>MathFunc3Args</tt>).
A <tt><a href="../api/classcFunctionType.html">cFunctionType</a></tt> object holds a pointer to the function and knows
how many arguments it takes.</TD></TR>
</table>

<p>

<p><H2><A NAME="sec394"/>13.5 Envir, Tkenv and Cmdenv</H2>

<p>The source code for the user interface of OMNeT++ resides in the
<tt>src/envir/</tt> directory (common part) and in the <tt>src/cmdenv/</tt>,
<tt>src/tkenv/</tt> directories.

<p>The classes in the user interface are <i>not</i> derived from <tt><a href="../api/classcObject.html">cObject</a></tt>,
they are completely separated from the simulation kernel.

<p>

<p><H3><A NAME="sec395"/>13.5.1 The main() function</H3>

<p>The <tt>main()</tt> function of OMNeT++ simply sets up the user
interface and runs it. Actual simulation is done in
<tt><a href="../api/classcEnvir.html">cEnvir</a>::run()</tt> (see later).

<p>

<p><H3><A NAME="sec396"/>13.5.2 The <a href="../api/classcEnvir.html">cEnvir</a> interface</H3>

<p>The <tt><a href="../api/classcEnvir.html">cEnvir</a></tt> class has only one instance, a global object
called <tt>ev</tt>:

<pre>
<a href="../api/classcEnvir.html">cEnvir</a> ev;
</pre>
<p>
<tt><a href="../api/classcEnvir.html">cEnvir</a></tt> basically a facade, its member functions
contain little code. <tt><a href="../api/classcEnvir.html">cEnvir</a></tt> maintains a pointer to a
dynamically allocated simulation application object (derived from
<tt>TOmnetApp</tt>, see later) which does all actual work.

<p>
<tt><a href="../api/classcEnvir.html">cEnvir</a></tt> member functions perform the following groups of tasks:
<ul>
  <li> I/O for module activities; the actual implementation is different
    for each user interface (e.g. stdin/stdout for Cmdenv, windowing
    in Tkenv)
  <li> <a href="../api/classcEnvir.html">cEnvir</a> provides methods for the simulation kernel to
    access configuration information (for example, module parameter settings)
  <li> <a href="../api/classcEnvir.html">cEnvir</a> also provides methods that are called by simulation kernel to
    notify the user interface of certain events (an object was deleted;
    a module was created or deleted; a message was sent or delivered, etc.)
</ul>

<p>
<H3><A NAME="sec397"/>13.5.3 Customizing Envir</H3>
<a name="sec:ch-opp-design:customization"></a>

<p>Certain aspects of Envir can be customized via plugin interfaces.
The following plugin interfaces are supported:

<p><ul>
   <li><tt><a href="../api/classcRNG.html">cRNG</a></tt>. Interface for the random number generator.
   <li><tt><a href="../api/classcScheduler.html">cScheduler</a></tt>. The scheduler class. This plugin interface
     allows for implementing real-time, hardware-in-the-loop, distributed
     and distributed parallel simulation.
   <li><tt><a href="../api/classcConfiguration.html">cConfiguration</a></tt>. It defines a class
     from which all configuration will be obtained. In other words, it
     option lets you replace <tt>omnetpp.ini</tt> with some other implementation,
     e.g. database input.
   <li><tt><a href="../api/classcOutputScalarManager.html">cOutputScalarManager</a></tt>. It handles recording the scalar output data,
     output via the <a href="../api/classcModule.html">cModule</a>::recordScalar() family of functions.
     The default output scalar manager is <tt>cFileOutputScalarManager</tt>,
     defined in the Envir library.
   <li><tt><a href="../api/classcOutputVectorManager.html">cOutputVectorManager</a></tt>. It handles recording the output
     for <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects.
     The default output vector manager is <tt>cFileOutputVectorManager</tt>,
     defined in the Envir library.
   <li><tt><a href="../api/classcSnapshotManager.html">cSnapshotManager</a></tt>. It provides an output stream to which
     snapshots are written (see section <a href="#sec266">[6.10.5]</a>).
     The default snapshot manager is <tt>cFileSnapshotManager</tt>,
     defined in the Envir library.
</ul>

<p>The classes (<tt><a href="../api/classcRNG.html">cRNG</a></tt>, <tt><a href="../api/classcScheduler.html">cScheduler</a></tt>, etc.) are documented in
the API Reference.

<p>To actually implement and select a plugin for use:

<p><ol>
   <li> Subclass the given interface class (e.g. for a custom RNG, <tt><a href="../api/classcRNG.html">cRNG</a></tt>)
     to create your own version.
   <li> Register the class by putting the <tt>Register_Class(MyRNGClass)</tt>
     line into the C++ source.
   <li> Compile and link your interface class into the OMNeT++ simulation
     executable. IMPORTANT: make sure the executable actually contains
     the code of your class! Over-optimizing linkers (esp. on Unix)
     tend to leave out code to which there seem to be no external reference.
   <li> Add an entry to <tt>omnetpp.ini</tt> to tell Envir use your class
     instead of the default one. For RNGs, this setting is <tt>rng-class</tt>
     in the <tt>[General]</tt> section.
</ol>

<p>Ini file entries that allow you to select your
plugin classes are <tt>configuration-class</tt>, <tt>scheduler-class</tt>,
<tt>rng-class</tt>, <tt>outputvectormanager-class</tt>,
<tt>outputscalarmanager-class</tt> and <tt>snapshotmanager-class</tt>,
documented in section <a href="#sec296">[8.2.6]</a>.

<p><p class="subheading">How plugin classes can access the configuration</p>

<p>The configuration is available to plugin classes via the <tt>config()</tt>
method of <tt><a href="../api/classcEnvir.html">cEnvir</a></tt>, which returns a pointer to the configuration
object (<tt><a href="../api/classcConfiguration.html">cConfiguration</a></tt>). This enables plugin classes to have
their own config entries.

<p>An example which reads the <tt>parsim-debug</tt> boolean entry from the
<tt>[General]</tt> section, with <tt>true</tt> as default:

<pre>
bool debug = ev.config()-&gt;getAsBool("General", "parsim-debug", true);
</pre>
<p>

<p><p class="subheading">Startup sequence for the configuration plugin</p>

<p>For the configuration plugin, the startup sequence is the following
(see <tt><a href="../api/classcEnvir.html">cEnvir</a>::setup()</tt> in the source code):

<p><ol>
  <li> First, <tt>omnetpp.ini</tt> (or the ini file(s) specified via the "-f"
     command-line option) are read.
  <li> Shared libraries in <tt>[General]/load-libs</tt> are loaded.
     (Also the ones specified with the "-l" command-line option.)
  <li> <tt>[General]/configuration-class</tt> is examined, and if it is present,
     a configuration object of the given class is instantiated.
     The configuration object may read further entries from the
     ini file (e.g. database connect parameters, or XML file name).
  <li> The original <tt>omnetpp.ini</tt> <tt>cInifile</tt> configuration
     object is deleted. No other settings are taken from it.
  <li> <tt>[General]/load-libs</tt> from the new configuration object is
     processed.
  <li> Then everything goes on as normally, using the new configuration
     object.
</ol>

<p>

<p><H3><A NAME="sec398"/>13.5.4 Implementation of the user interface: simulation applications</H3>

<p>The base class for simulation application is <tt>TOmnetApp</tt>.
Specific user interfaces such as <tt>TCmdenv</tt>,
<tt>TOmnetTkApp</tt> are derived from <tt>TOmnetApp</tt>.

<p><tt>TOmnetApp</tt>'s member functions are almost all virtual.
<ul>
  <li>Some of them implement the <tt><a href="../api/classcEnvir.html">cEnvir</a></tt> functions
    (described in the previous section)
  <li>Others implement the common part of all user interfaces (for
    example: reading options from the configuration files; making the
    options effective within the simulation kernel)
  <li>The <tt>run()</tt> function is pure virtual (it is different
    for each user interface).
</ul>

<p><tt>TOmnetApp</tt>'s data members:
<ul>
  <li>a pointer to the object holding configuration file contents
    (type <tt>cInifile</tt>);
  <li>the options and switches that can be set from the
    configuration file (these members begin with <tt>opt_</tt>)
</ul>

<p>Simulation applications:
<ul>
  <li>add new configuration options
  <li>provide a <tt>run()</tt> function
  
<p>  <li>implement functions left empty in <tt>TOmnetApp</tt> (like
    <tt>breakpointHit()</tt>, <tt>objectDeleted()</tt>).
</ul>

<p>

</BODY>
</HTML>
<hr><hr><H1><A NAME="sec399"/>14 NED Language Grammar</H1>
<a name="cha:ned-language-grammar"></a>

<p>The NED language<!--ned!language-->, the network topology description language of
OMNeT++ will be given using the extended BNF notation.

<p>Space, horizontal tab and new line characters counts as delimiters,
so one or more of them is required between two elements of the
description which would otherwise be unseparable. '//' (two slashes)
may be used to write comments that last to the end of the line.
The language only distinguishes between lower and upper case
letters in names, but not in keywords.

<p>
In this description, the {xxx...} notation stands for one or
more xxx's separated with spaces, tabs or new line characters,
and {xxx,,,} stands for one or more xxx's, separated with a
comma and (optionally) spaces, tabs or new line characters.

<p>
For ease of reading, in some cases we use textual definitions.
The <i>networkdescription</i> symbol is the sentence symbol of the
grammar.

<p>
<pre>
        <b>notation    meaning</b>
        [a]         0 or 1 time a
        {a}         a
        {a,,,}      1 or more times a, separated by commas
        {a...}      1 or more times a, separated by spaces
        a|b         a or b
        `a'         the character a
        <b>bold</b>        keyword
        <i>italic</i>      identifier


networkdescription ::=
    { definition... }

definition    ::=
      include
    | channeldefinition
    | simpledefinition
    | moduledefinition
    | networkdefinition

include ::=
    <b>include</b> { fileName ,,, } ;

channeldefinition ::=
    <b>channel</b> <i>channeltype</i>
     [ <b>delay</b> numericvalue ]
     [ <b>error</b> numericvalue ]
     [ <b>datarate</b> numericvalue ]
    <b>endchannel</b>

simpledefinition ::=
    <b>simple</b> <i>simplemoduletype</i><!--module!simple-->
     [ paramblock ]
     [ gateblock ]
    <b>endsimple</b> [ <i>simplemoduletype</i> ]

moduledefinition ::=
    <b>module</b> <i>compoundmoduletype</i><!--module!compound-->
     [ paramblock ]
     [ gateblock ]
     [ submodblock ]
     [ connblock ]
    <b>endmodule</b> [ <i>compoundmoduletype</i> ]

moduletype ::=
    <i>simplemoduletype</i> | <i>compoundmoduletype</i>

paramblock ::=
    <b>parameters:</b> { parameter ,,, } ;

parameter ::=
    <i>parametername</i>
    | <i>parametername</i> : <b>const</b> [ <b>numeric</b> ]
    | <i>parametername</i> <b>: string</b>
    | <i>parametername</i> <b>: bool</b>
    | <i>parametername</i> <b>: char</b>
    | <i>parametername</i> <b>: anytype</b>

gateblock ::=
    <b>gates:</b>
     [ <b>in:</b> { gate ,,, } ; ]
     [ <b>out:</b> { gate ,,, } ; ]
gate ::=
    <i>gatename</i> [ '[]' ]

submodblock ::=
    <b>submodules:</b> { submodule... }

submodule ::=
    { <i>submodulename</i> : <i>moduletype</i> [ vector ]
     [ substparamblock... ]
     [ gatesizeblock... ] }
  | { <i>submodulename</i> : <i>parametername</i> [ vector ] <b>like</b> <i>moduletype</i>
     [ substparamblock... ]
     [ gatesizeblock... ] }

substparamblock    ::=
    <b>parameters</b> [ <b>if</b> expression ]<b>:</b>
      { <i>substparamname</i> = substparamvalue,,, } ;

substparamvalue ::=
    ( [ <b>ancestor</b> ] [ <b>ref</b> ] <i>name</i> )
    | parexpression

gatesizeblock ::=
    <b>gatesizes</b> [ <b>if</b> expression ]<b>:</b>
      { <i>gatename</i> vector ,,, } ;

connblock ::=
    <b>connections</b> [ <b>nocheck</b> ]<b>:</b> { connection ,,, } ;

connection ::=
     normalconnection | loopconnection

loopconnection ::=
    <b>for</b> { index... } <b>do</b>
      { normalconnection ,,, } ;
    <b>endfor</b>

index ::=
    <i>indexvariable</i> '=' expression ``...'' expression

normalconnection ::=
     { gate { --&gt; | &lt;-- } gate [ <b>if</b> expression ]}
   | {gate --&gt; channel --&gt; gate [ <b>if</b> expression ]}
   | {gate &lt;-- channel &lt;-- gate [ <b>if</b> expression ]}

channel ::=
     <i>channeltype</i>
    | [ <b>delay</b> expression ] [ <b>error</b> expression ] [ <b>datarate</b> expression ]


gate ::=
    [ <i>modulename</i> [vector]. ] <i>gatename</i> [vector]

networkdefinition ::=
    <b>network</b> <i>networkname</i> : <i>moduletype</i>
     [ substparamblock ]
    <b>endnetwork</b>

vector ::=    '[' expression ']'

parexpression ::=
    expression | otherconstvalue

expression    ::=
      expression + expression
    | expression - expression
    | expression * expression
    | expression / expression
    | expression % expression
    | expression ^ expression
    | expression == expression
    | expression != expression
    | expression <tt>&lt;</tt> expression
    | expression <tt>&lt;</tt>= expression
    | expression <tt>&gt;</tt> expression
    | expression <tt>&gt;</tt>= expression
    | expression ? expression : expression
    | expression <b>and</b> expression
    | expression <b>or</b> expression
    | <b>not</b> expression
    | '(' expression ')'
    | <i>functionname</i> '(' [ expression ,,, ] ')'
    | - expression
    | numconstvalue
    | inputvalue
    | [ <b>ancestor</b> ] [ <b>ref</b> ] <i>parametername</i>
    | <b>sizeof</b> '(' <i>gatename</i> ')'
    | <b>index</b>

numconstvalue ::=
    <i>integerconstant</i> | <i>realconstant</i> | <i>timeconstant</i>

otherconstvalue ::=
      '<i>characterconstant'</i>
    | "<i>stringconstant</i>"
    | <b>true</b>
    | <b>false</b>

inputvalue ::=
    <b>input</b> '(' default , "<i>prompt-string</i>" ')'

default ::=
    expression | otherconstvalue
</pre>

<p>
</BODY>
</HTML>
<H1><A NAME="sec400"/>15 References</H1>

<p><a name="bib-bagrodia00"></a>[BT00]&nbsp;&nbsp;
R. L. Bagrodia and M. Takai.
 Performance Evaluation of Conservative Algorithms in Parallel
  Simulation Languages.
 11(4):395--414, 2000.

<p><a name="bib-chandymisra79"></a>[CM79]&nbsp;&nbsp;
M. Chandy and J. Misra.
 Distributed Simulation: A Case Study in Design and Verification of
  Distributed Programs.
  IEEE Transactions on Software Engineering, (5):440--452, 1979.

<p><a name="bib-Entacher02"></a>[EHW02]&nbsp;&nbsp;
K. Entacher, B. Hechenleitner, and S. Wegenkittl.
 A Simple OMNeT++ Queuing Experiment Using Parallel Streams.
  PARALLEL NUMERICS'02 - Theory and Applications, pages 89--105,
  2002.
 Editors: R. Trobec, P. Zinterhof, M. Vajtersic and A. Uhl.

<p><a name="bib-Akaroa99"></a>[EPM99]&nbsp;&nbsp;
G. Ewing, K. Pawlikowski, and D. McNickle.
 Akaroa2: Exploiting Network Computing by Distributing Stochastic
  Simulation.
 In  Proceedings of the European Simulation Multiconference
  ESM'99, Warsaw, June 1999, pages 175--181. International Society for
  Computer Simulation, 1999.

<p><a name="bib-mpiforum94"></a>[For94]&nbsp;&nbsp;
Message Passing~Interface Forum.
 MPI: A Message-Passing Interface Standard.
 8(3/4):165--414, 1994.

<p><a name="bib-Goldberg91what"></a>[Gol91]&nbsp;&nbsp;
David Goldberg.
 What Every Computer Scientist Should Know About Floating-Point
  Arithmetic.
  ACM Computing Surveys, 23(1):5--48, 1991.

<p><a name="bib-Hellekalek98"></a>[Hel98]&nbsp;&nbsp;
P. Hellekalek.
 Don't Trust Parallel Monte Carlo.
  ACM SIGSIM Simulation Digest, 28(1):82--89, jul 1998.
 Author's page is a great source of information, see
  <a href="http://random.mat.sbg.ac.at/">http://random.mat.sbg.ac.at/</a>.

<p><a name="bib-JAR"></a>[HPvdL95]&nbsp;&nbsp;
Jan Heijmans, Alex Paalvast, and Robert van~der Leij.
 Network Simulation Using the JAR Compiler for the OMNeT++
  Simulation System.
 Technical report, Technical University of Budapest, Dept. of
  Telecommunications, 1995.

<p><a name="bib-Jain91"></a>[Jai91]&nbsp;&nbsp;
Raj Jain.
  The Art of Computer Systems Performance Analysis.
 Wiley, New York, 1991.

<p><a name="bib-JCh85"></a>[JC85]&nbsp;&nbsp;
Raj Jain and Imrich Chlamtac.
 The <i>P<sup>2</sup></i> Algorithm for Dynamic Calculation of Quantiles and
  Histograms without Storing Observations.
  Communications of the ACM, 28(10):1076--1085, 1985.

<p><a name="bib-Kofoed95"></a>[Kof95]&nbsp;&nbsp;
Stig Kofoed.
 Portable Multitasking in C++.
  Dr. Dobb's Journal, November 1995.
 Download source from
  <a href="http://www.ddj.com/ftp/1995/1995.11/mtask.zip/">http://www.ddj.com/ftp/1995/1995.11/mtask.zip/</a>.

<p><a name="bib-lammpi"></a>[LAM]&nbsp;&nbsp;
LAM-MPI home page.
 <a href="http://www.lam-mpi.org/">http://www.lam-mpi.org/</a>.

<p><a name="bib-LGThesis"></a>[Len94]&nbsp;&nbsp;
G&aacute;bor Lencse.
 Graphical Network Editor for OMNeT++.
 Master's thesis, Technical University of Budapest, 1994.
 In Hungarian.

<p><a name="bib-LEcuyer02"></a>[LSCK02]&nbsp;&nbsp;
P. L'Ecuyer, R. Simard, E. J. Chen, and W. D. Kelton.
 An Objected-Oriented Random-Number Package with Many Long Streams
  and Substreams.
  Operations Research, 50(6):1073--1075, 2002.
 Source code can be downloaded from
  <a href="http://www.iro.umontreal.ca/~lecuyer/papers.html">http://www.iro.umontreal.ca/~lecuyer/papers.html</a>.

<p><a name="bib-Matsumoto98"></a>[MN98]&nbsp;&nbsp;
M. Matsumoto and T. Nishimura.
 Mersenne Twister: A 623-dimensionally Equidistributed Uniform
  Pseudorandom Number Generator.
  ACM Trans. on Modeling and Computer Simulation, 8(1):3--30,
  1998.
 Source code can be downloaded from
  <a href="http://www.math.keio.ac.jp/~matumoto/emt.html">http://www.math.keio.ac.jp/~matumoto/emt.html</a>.

<p><a name="bib-OMNeTExamples"></a>[MvMvdW95]&nbsp;&nbsp;
Andr&eacute; Maurits, George van Montfort, and Gerard van~de Weerd.
 OMNeT++ Extensions and Examples.
 Technical report, Technical University of Budapest, Dept. of
  Telecommunications, 1995.

<p><a name="bib-ongfarrell2000"></a>[OF00]&nbsp;&nbsp;
Hong Ong and Paul~A. Farrell.
 Performance Comparison of LAM/MPI, MPICH and MVICH on a
  Linux Cluster Connected by a Gigabit Ethernet Network.
 In  Proceedings of the 4th Annual Linux Showcase &amp; Conference,
  Atlanta, October 10-14, 2000. The USENIX Association, 2000.

<p><a name="bib-BFS86"></a>[PFS86]&nbsp;&nbsp;
Bratley P., B. L. Fox, and L. E. Schrage.
  A Guide to Simulation.
 Springer-Verlag, New York, 1986.

<p><a name="bib-Pawlikowsky02"></a>[PJL02]&nbsp;&nbsp;
K. Pawlikowski, H. Jeong, and J. Lee.
 On Credibility of Simulation Studies of Telecommunication Networks.
  IEEE Communications Magazine, pages 132--139, jan 2002.

<p><a name="bib-PongorOmnet"></a>[Pon91]&nbsp;&nbsp;
Gy&ouml;rgy Pongor.
 OMNET: An Object-Oriented Network Simulator.
 Technical report, Technical University of Budapest, Dept. of
  Telecommunications, 1991.

<p><a name="bib-PongorSSM92"></a>[Pon92]&nbsp;&nbsp;
Gy&ouml;rgy Pongor.
 Statistical Synchronization: A Different Approach of Parallel
  Discrete Event Simulation.
 Technical report, University of Technology, Data Communications
  Laboratory, Lappeenranta, Finland, 1992.

<p><a name="bib-PongorSSM93"></a>[Pon93]&nbsp;&nbsp;
Gy&ouml;rgy Pongor.
 On the Efficiency of the Statistical Synchronization Method.
 In  Proceedings of the European Simulation Symposium (ESS'93),
  Delft, The Netherlands, Oct. 25-28, 1993. International Society for Computer
  Simulation, 1993.

<p><a name="bib-quadrics"></a>[Qua]&nbsp;&nbsp;
Quadrics home page.
 <a href="http://www.quadrics.com/">http://www.quadrics.com/</a>.

<p><a name="bib-OppParsim03"></a>[SVE03]&nbsp;&nbsp;
Y. Ahmet Sekercioglu, Andr&aacute;s Varga, and Gregory~K. Egan.
 Parallel Simulation Made Easy with OMNeT++.
 In  Proceedings of the European Simulation Symposium (ESS 2003),
  26-29 Oct, 2003, Delft, The Netherlands. International Society for Computer
  Simulation, 2003.

<p><a name="bib-AVTDK"></a>[Var92]&nbsp;&nbsp;
Andr&aacute;s Varga.
 OMNeT++ - Portable Simulation Environment in C++.
 In  Proceedings of the Annual Students' Scientific Conference
  (TDK), 1992. Technical University of Budapest, 1992.
 In Hungarian.

<p><a name="bib-AVThesis"></a>[Var94]&nbsp;&nbsp;
Andr&aacute;s Varga.
 Portable User Interface for the OMNeT++ Simulation System.
 Master's thesis, Technical University of Budapest, 1994.
 In Hungarian.

<p><a name="bib-KSplit98"></a>[Var98a]&nbsp;&nbsp;
Andr&aacute;s Varga.
 K-split -- On-Line Density Estimation for Simulation Result
  Collection.
 In  Proceedings of the European Simulation Symposium (ESS'98),
  Nottingham, UK, October 26-28. International Society for Computer
  Simulation, 1998.

<p><a name="bib-Paramtop98"></a>[Var98b]&nbsp;&nbsp;
Andr&aacute;s Varga.
 Parameterized Topologies for Simulation Programs.
 In  Proceedings of the Western Multiconference on Simulation
  (WMC'98) Communication Networks and Distributed Systems (CNDS'98), San Diego,
  CA, January 11-14. International Society for Computer Simulation, 1998.

<p><a name="bib-Edu99"></a>[Var99]&nbsp;&nbsp;
Andr&aacute;s Varga.
 Using the OMNeT++ Discrete Event Simulation System in Education.
  IEEE Transactions on Education, 42(4):372, November 1999.
 (on CD-ROM issue; journal contains abstract).

<p><a name="bib-VZThesis"></a>[Vas96]&nbsp;&nbsp;
Zolt&aacute;n Vass.
 PVM Extension of OMNeT++ to Support Statistical
  Synchronization.
 Master's thesis, Technical University of Budapest, 1996.
 In Hungarian.

<p><a name="bib-KSplit97"></a>[VF97]&nbsp;&nbsp;
Andr&aacute;s Varga and Babak Fakhamzadeh.
 The K-Split Algorithm for the PDF Approximation of
  Multi-Dimensional Empirical Distributions without Storing Observations.
 In  Proceedings of the 9th European Simulation Symposium
  (ESS'97), Passau, Germany, October 19-22, 1997, pages 94--98. International
  Society for Computer Simulation, 1997.

<p><a name="bib-Flex97"></a>[VP97]&nbsp;&nbsp;
Andr&aacute;s Varga and Gy&ouml;rgy Pongor.
 Flexible Topology Description Language for Simulation Programs.
 In  Proceedings of the 9th European Simulation Symposium
  (ESS'97), Passau, Germany, October 19-22, 1997, pages 225--229, 1997.

<p><a name="bib-ParsimCrit03"></a>[VSE03]&nbsp;&nbsp;
Andr&aacute;s Varga, Y. Ahmet Sekercioglu, and Gregory~K. Egan.
 A practical efficiency criterion for the null message algorithm.
 In  Proceedings of the European Simulation Symposium (ESS 2003),
  26-29 Oct, 2003, Delft, The Netherlands. International Society for Computer
  Simulation, 2003.

<p><a name="bib-WelchBook"></a>[Wel95]&nbsp;&nbsp;
Brent Welch.
  Practical Programming in Tcl and Tk.
 Prentice-Hall, 1995.

<p>
</BODY>
</HTML>


<HR>
<EM>Document converted from LaTeX by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>
from <A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com">quong@best.com</A>)</EM>

</BODY>
</HTML>
