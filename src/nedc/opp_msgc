eval '(exit $?0)' && eval 'exec perl -S $0 ${1+"$@"}' && eval 'exec perl -S $0 $argv:q'
  if 0;

#!perl -w
#line 6
#
# opp_msgc: supports message subclassing: compiles NED files with message
# declarations into C++ code.
#

$MSGC_VERSION = "3.4";
$MSGC_VERSION_HEX = "0x0304";


#
# If no args, print usage
#
$Usage = 'opp_msgc - part of OMNeT++. (c) 2002-2005 Andras Varga
Translates .msg files into C++

Usage: opp_msgc [-s <cc-file-suffix>] [-t <h-file-suffix>]
                [-I <dir> -I ...] [-h] [-Xnc] [-Xnd] <nedfile>
  -I <dir>    add directory to include path
  -s <suffix> output C++ file suffix (defaults to: _m.cc)
  -t <suffix> output C++ header file suffix (defaults to: _m.h)
  -P <symbol> add dllexport/dllimport symbol to class declarations
  -h          output in current directory
  -Xnc        do not generate the classes, only object descriptions
  -Xnd        do not generate object descriptions
  -Xns        do not generate setters in object descriptions
';

if ($#ARGV == -1)
{
    print $Usage;
    exit(0);
}

#
#  Parse the command line for options and files.
#
$filename = '';
$ccsuffix = '_m.cc';
$hsuffix = '_m.h';
$exportdef = '';
$generate_classes = 1;
$generate_descriptions = 1;
$generate_setters_in_descr = 1;
while (@ARGV)
{
    $arg = shift @ARGV;

    if ($arg eq "-s")
    {
        $ccsuffix = shift @ARGV;
    }
    elsif ($arg eq "-t")
    {
        $hsuffix = shift @ARGV;
    }
    elsif ($arg eq "-I")
    {
        # import not supported: just ignore -I <dir> for now
        shift @ARGV;
    }
    elsif ($arg =~ /^-I/)
    {
        # import not supported: just ignore -I<dir> for now
    }
    elsif ($arg eq "-P")
    {
        $exportdef = shift @ARGV;
        $exportdef =~ s/[ \t]//g;
        $exportdef .= " ";
    }
    elsif ($arg =~ /^-P/)
    {
        $exportdef = $arg;
        $exportdef =~ s/^-P//;
        $exportdef =~ s/[ \t]//g;
        $exportdef .= " ";
    }
    elsif ($arg eq "-h")
    {
        $here = "true";
    }
    elsif ($arg eq "-Xnc")
    {
        $generate_classes = 0;
    }
    elsif ($arg eq "-Xnd")
    {
        $generate_descriptions = 0;
    }
    elsif ($arg eq "-Xns")
    {
        $generate_setters_in_descr = 0;
    }
    elsif ($filename eq '')
    {
        $filename = $arg;
    }
    else
    {
        print $Usage;
        exit(1);
    }
}

#
# parse file
#
$filename =~ /./ || die "*** Error: no file name given\n";
$filename =~ /\.[^\\\/]*$/ || die "*** Error: file name must contain a dot\n";
$filename =~ s|\\|/|g;
$hfile = $filename;
$hfile =~ s|\.[^.]*$|$hsuffix|;
if ($here eq "true")
{
    $hfile =~ s|^.*/||;
}
$hdef = $hfile;
$hdef =~ s|^.*/||;
$hdef =~ s|\.[^.]*$|_H_|;
$hdef = '_'.$hdef;
$hdef =~ tr/[a-z]/[A-Z]/;
$hdef =~ s/[^a-zA-Z0-9]/_/g;
$ccfile = $filename;
$ccfile =~ s|\.[^.]*$|$ccsuffix|;
if ($here eq "true")
{
    $ccfile =~ s|^.*/||;
}

$ret = 0;

$msg = "";
open(IN,$filename) || die "*** Error: cannot open input file $filename";
while (<IN>)
{
    s|\r||;
    s|//.*$||;
    $msg .= $_;
}
close(IN);

open(H,">$hfile") || die "*** Error: cannot open output file $hfile";
open(CC,">$ccfile") || die "*** Error: cannot open output file $ccfile";

print H "//\n// Generated file, do not edit! Created by opp_msgc $MSGC_VERSION from $filename.\n//\n\n";
print H "#ifndef $hdef\n";
print H "#define $hdef\n\n";
print H "#include <omnetpp.h>\n";
print H "\n";
print H "// opp_msgc version check\n";
print H "#define MSGC_VERSION $MSGC_VERSION_HEX\n";
print H "#if (MSGC_VERSION!=OMNETPP_VERSION)\n";
print H "#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.\n";
print H "#endif\n";
print H "\n";

print CC "//\n// Generated file, do not edit! Created by opp_msgc $MSGC_VERSION from $filename.\n//\n\n";
print CC "// Disable warnings about unused variables, empty switch stmts, etc:\n";
print CC "#ifdef _MSC_VER\n";
print CC "#  pragma warning(disable:4101)\n";
print CC "#  pragma warning(disable:4065)\n";
print CC "#endif\n\n";

print CC "#include <iostream>\n";
print CC "#include <sstream>\n";
print CC "#include \"$hfile\"\n\n";

print CC "// Template rule which fires if a struct or class doesn't have operator<<\n";
print CC "template<typename T>\n";
print CC "std::ostream& operator<<(std::ostream& out,const T&) {return out;}\n";

if ($generate_classes)
{
    print CC "\n";
    print CC "// Another default rule (prevents compiler from choosing base class' doPacking())\n";
    print CC "template<typename T>\n";
    print CC "void doPacking(cCommBuffer *, T& t) {\n";
    print CC "    throw new cRuntimeError(\"Parsim error: no doPacking() function for type %s or its base class (check .msg and _m.cc/h files!)\",opp_typename(typeid(t)));\n";
    print CC "}\n";
    print CC "template<typename T>\n";
    print CC "void doUnpacking(cCommBuffer *, T& t) {\n";
    print CC "    throw new cRuntimeError(\"Parsim error: no doUnpacking() function for type %s or its base class (check .msg and _m.cc/h files!)\",opp_typename(typeid(t)));\n";
    print CC "}\n";
    print CC "\n";
    print CC "// Automatically supply array (un)packing functions\n";
    print CC "template<typename T>\n";
    print CC "void doPacking(cCommBuffer *b, T *t, int n) {\n";
    print CC "    for (int i=0; i<n; i++)\n";
    print CC "        doPacking(b,t[i]);\n";
    print CC "}\n";
    print CC "template<typename T>\n";
    print CC "void doUnpacking(cCommBuffer *b, T *t, int n) {\n";
    print CC "    for (int i=0; i<n; i++)\n";
    print CC "        doUnpacking(b,t[i]);\n";
    print CC "}\n";
    print CC "inline void doPacking(cCommBuffer *, cPolymorphic&) {}\n";
    print CC "inline void doUnpacking(cCommBuffer *, cPolymorphic&) {}\n";
    print CC "\n";
    print CC "#define DOPACKING(T,R) \\\n";
    print CC "    inline void doPacking(cCommBuffer *b, T R a) {b->pack(a);}  \\\n";
    print CC "    inline void doPacking(cCommBuffer *b, T *a, int n) {b->pack(a,n);}  \\\n";
    print CC "    inline void doUnpacking(cCommBuffer *b, T& a) {b->unpack(a);}  \\\n";
    print CC "    inline void doUnpacking(cCommBuffer *b, T *a, int n) {b->unpack(a,n);}\n";
    print CC "#define _\n";
    print CC "DOPACKING(char,_)\n";
    print CC "DOPACKING(unsigned char,_)\n";
    print CC "DOPACKING(bool,_)\n";
    print CC "DOPACKING(short,_)\n";
    print CC "DOPACKING(unsigned short,_)\n";
    print CC "DOPACKING(int,_)\n";
    print CC "DOPACKING(unsigned int,_)\n";
    print CC "DOPACKING(long,_)\n";
    print CC "DOPACKING(unsigned long,_)\n";
    print CC "DOPACKING(float,_)\n";
    print CC "DOPACKING(double,_)\n";
    print CC "DOPACKING(long double,_)\n";
    print CC "DOPACKING(char *,_)\n";
    print CC "DOPACKING(const char *,_)\n";
    print CC "DOPACKING(opp_string,&)\n";
    print CC "//DOPACKING(std::string,&)\n"; #TBD add it after cCommBuffer support is done
    print CC "#undef _\n";
    print CC "#undef DOPACKING\n";
}
print CC "\n\n";

# pre-register some OMNeT++ classes so that one doesn't need to announce them
#
# note: $classtype values:
#  'cobject'      ==> subclasses from cObject
#  'cpolymorphic' ==> subclasses from cPolymorphic but NOT from cObject
#  'foreignclass' ==> non-cPolymorphic class (NOTE: currently only external
#                     classes announced as "class noncobject" belong here, because
#                     all classes *we* generate are cPolymorphic.)
#  'struct'       ==> struct (i.e. no member functions)
#
@classes = ('cPolymorphic', 'cObject', 'cMessage', 'cPacket');
$classtype{'cPolymorphic'} = 'cpolymorphic';
$classtype{'cObject'} = 'cobject';
$classtype{'cMessage'} = 'cobject';
$classtype{'cPacket'} = 'cobject';

@enums = ();

$reservedwords = 'abstract|allowunconnected|ancestor|anytype|bool|channelinterface|channel|char'
    . '|class|connections|const|cplusplus|datarate|default|delay|display|double|do|endchannel'
    . '|endfor|endmodule|endnetwork|endsimple|enum|error|extends|false|fields|for|function'
    . '|gatesizes|gates|if|import|index|inout|input|interface|int|like|long|message|module'
    . '|network|nocheck|noncobject|cpolymorphic|numeric|on|output|package|parameters|properties|property'
    . '|readonly|ref|short|simple|sizeof|string|struct|submodules|this|to|true|typename|types'
    . '|unsigned|where|withcppclass|xmldoc|xml';

# parse cppincludes
while ($msg =~ s/cppinclude\s+(["\<].*?["\>])//s)
{
    print STDERR "*** Warning: cppinclude is deprecated, use cplusplus {{ ... }} syntax instead\n";
    print H "#include $1\n";
}
while ($msg =~ s/cplusplus\s+{{(.*?)}};?//s)
{
    print H "// cplusplus {{ ... }} section:\n";
    print H "$1";
    print H "// end cplusplus\n\n";
}
print H "\n";

# parse imports
while ($msg =~ s/import\s+(".*?");//s)
{
    print STDERR "*** Error: imports are not supported (yet)\n"; $ret=1;
}

# parse type announcements in ned text
while ($msg =~ s/(struct|cobject|noncobject|class|class\s+noncobject|class\s+cpolymorphic|message)\s+([A-Za-z_][A-Za-z0-9_]*)\s*;//s)
{
    $class = $2;
    $type0 = $1;

    if ($type0 eq 'struct') {
        $type = 'struct';
    } elsif ($type0 eq 'cobject') {
        print STDERR "*** Warning: 'cobject' keyword is deprecated, write 'class' instead\n";
        $type = 'cobject';
    } elsif ($type0 eq 'noncobject') {
        print STDERR "*** Warning: 'noncobject' is deprecated, write 'class noncobject' instead\n";
        $type = 'foreignclass';
    } elsif ($type0 eq 'class' or $type0 eq 'message') {
        $type = 'cobject';
    } elsif ($type0 =~ /class\s+noncobject/) {
        $type = 'foreignclass';
    } elsif ($type0 =~ /class\s+cpolymorphic/) {
        $type = 'cpolymorphic';
    } else {
        die 'invalid type';
    }

    if ($class =~ /^($reservedwords)$/) {
        print STDERR "*** Error: type name '$class' is a reserved word\n"; $ret=1;
    }
    if (grep(/^\Q$class\E$/,@classes)) {
        if ($classtype{$class} ne $type) {
            print STDERR "*** Error: different declarations for '$class' are inconsistent\n"; $ret=1;
        }
    } else {
        $classtype{$class} = $type;
        push(@classes, $class);
    }
}

# parse enum announcements in ned text
while ($msg =~ s/enum\s+([A-Za-z_][A-Za-z0-9_]*)\s*;//s)
{
    $enumname = $1;

    if ($enumname =~ /^($reservedwords)$/) {
        print STDERR "*** Error: enum name '$enumname' is a reserved word\n"; $ret=1;
    }

    if (grep(/^\Q$enumname\E$/,@classes)) {
        print STDERR "*** Error: inconsistent declarations for '$enum'\n"; $ret=1;
    } else {
        push(@enums, $enumname);
    }
}


# parse enums in ned text
while ($msg =~ s/enum\s+([A-Za-z0-9_ \t]+?)\s*{(.*?)};?//s)
{
    $source = $&;
    $enumhdr = $1;
    $fields = $2;

    if ($enumhdr =~ /^([^ \t\n]+?)\s*extends\s*([^ \t\n]+?)$/s)
    {
        $enumname = $1;
        $baseenum = $2;
    }
    elsif ($enumhdr =~ /^([^ \t\n]+?)$/s)
    {
        $enumname = $enumhdr;
        $baseenum = '';
    }
    else
    {
        $enumhdr =~ s/\s+/ /sg;
        print STDERR "*** Error: invalid enum declaration syntax '$enumhdr'\n"; $ret=1;
        $enumname = "???";
        $baseenum = '';
    }

    if ($enumname =~ /^($reservedwords)$/) {
        print STDERR "*** Error: enum name '$enumname' is a reserved word\n"; $ret=1;
    }

    @fieldlist = ();
    undef %fval;

    #
    # parse enum { ... } syntax
    #
    $scrap = '';
    while ($fields =~ s/^(.*?);//s)
    {
        $field = $1;

        # value
        if ($field =~ s/=\s*(.*?)\s*$//s) {
            $fieldvalue = $1;
        } else {
            $fieldvalue = '';
        }

        # identifier
        if ($field =~ /^\s*([A-Za-z0-9_]+)\s*$/s) {
            $fieldname = $1;
        } else {
            $scrap .= $field;
            print STDERR "*** Error: missing identifier name in enum $enumname\n"; $ret=1;
        }

        if ($fieldname =~ /^($reservedwords)$/) {
            print STDERR "*** Error: enum field name '$fieldname' is a reserved word\n"; $ret=1;
        }

        # store field
        push(@fieldlist,$fieldname);
        $fval{$fieldname}=$fieldvalue;

    }
    $scrap .= $fields;
    if ($scrap =~ /[^ \t\n]/s) {
        $scrap =~ s/\n\n+/\n\n/sg;
        $scrap =~ s/^\n+//s;
        $scrap =~ s/\n+$//s;
        print STDERR "*** Error: some parts not understood in enum $enumname:\n"; $ret=1;
        print STDERR "'$scrap'\n";
    }

    #
    # generate code
    #
    if (grep(/^\Q$enumname\E$/,@enums)) {
        print STDERR "*** Error: enum '$enumname' already defined\n"; $ret=1;
    }
    push(@enums, $enumname);

    print H "/**\n";
    print H " * Enum generated from <tt>$filename</tt> by opp_msgc.\n";
    $source =~ s/^/ * /mg;
    print H " * <pre>\n$source\n * </pre>\n";
    print H " */\n";
    print H "enum $enumname {\n";
    foreach $fieldname (@fieldlist)
    {
        print H "    $fieldname = $fval{$fieldname}";
        print H "," unless ($fieldname eq $fieldlist[$#fieldlist]);
        print H "\n";
    }
    print H "};\n\n";

    print CC "EXECUTE_ON_STARTUP($enumname,\n";
    print CC "    cEnum *e = findEnum(\"$enumname\");\n";
    print CC "    if (!e) enums.instance()->add(e = new cEnum(\"$enumname\"));\n";
    foreach $fieldname (@fieldlist)
    {
        print CC "    e->insert($fieldname, \"$fieldname\");\n";
    }
    print CC ");\n\n";

    if ($baseenum ne '')
    {
        # add to base enum, too
        print CC "EXECUTE_ON_STARTUP(_${baseenum}_${enumname},\n";
        print CC "    cEnum *e = findEnum(\"$baseenum\");\n";
        print CC "    if (!e) enums.instance()->add(e = new cEnum(\"$baseenum\"));\n";
        foreach $fieldname (@fieldlist)
        {
            print CC "    e->insert($fieldname, \"$fieldname\");\n";
        }
        print CC ");\n\n";
    }
}

# parse message/class/struct definitions
while ($msg =~ s/(message|class|struct)\s+(.+?)\s*{(.*?)};?//s)
{
    #
    # parse message { ... } syntax
    #
    $source = $&;
    $keyword = $1;  # 'message' or 'class' or 'struct'
    $msghdr = $2;   # must be "<name>" or "<name> extends <name>"
    $body = $3;

    # reset
    @fieldlist = ();
    @baseclassfieldlist = ();
    undef %fprops;
    undef %props;

    if ($msghdr =~ /^([^ \t\n]+?)\s*extends\s*([^ \t\n]+?)$/s)
    {
        $msgname = $1;
        $msgbase = $2;
    }
    elsif ($msghdr =~ /^([^ \t\n]+?)$/s)
    {
        $msgname = $msghdr;
        $msgbase = '';
    }
    else
    {
        $msghdr =~ s/\s+/ /sg;
        print STDERR "*** Error: invalid declaration syntax for '$msghdr'\n"; $ret=1;
        $msgname = "???";
        $msgbase = '';
    }

    if ($msgname =~ /^($reservedwords)$/) {
        print STDERR "*** Error: type name '$msgname' is a reserved word\n"; $ret=1;
    }

    #
    # check if there's some garbage before "fields:" or "properties:"
    #
    $scrap = $body;
    $scrap =~ s/fields:(.*)$//s;
    $scrap =~ s/properties:(.*)$//s;
    if ($scrap =~ /[^ \t\n]/s)
    {
        $scrap =~ s/\n\n+/\n\n/sg;
        $scrap =~ s/^\n+//s;
        $scrap =~ s/\n+$//s;
        print STDERR "*** Error: some parts not understood in '$msgname' (nothing may occur before 'fields:' or 'properties:'):\n"; $ret=1;
        print STDERR "'$scrap'\n";
        next;
    }

    #
    # process "properties:"
    #
    $scrap = '';
    if ($body =~ /properties:(.*)$/s)
    {
        $properties = $1;
        $properties =~ s/fields:.*$//s;  # cut off fields section
        while ($properties =~ s/^(.*?);//s)
        {
            $prop = $1;
            if ($prop =~ /^\s*(.*?)\s*=\s*(.*?)\s*$/s)
            {
                $propname = $1;
                $propvalue = $2;
                $props{$propname} = $propvalue;

                if ($propname =~ /^($reservedwords)$/) {
                    print STDERR "*** Error: property name '$propname' is a reserved word\n"; $ret=1;
                }
            }
            else {$scrap.=$prop;}
        }
        $scrap.=$properties;
        if ($scrap =~ /[^ \t\n]/s)
        {
            $scrap =~ s/\n\n+/\n\n/sg;
            $scrap =~ s/^\n+//s;
            $scrap =~ s/\n+$//s;
            print STDERR "*** Error: some parts not understood in 'properties' section of '$msgname':\n"; $ret=1;
            print STDERR "'$scrap'\n";
        }
    }

    #
    # process "fields:"
    #
    $scrap = '';
    if ($body =~ /fields:(.*)$/s)
    {
        $fields = $1;
        while ($fields =~ s/^(.*?);//s)
        {
            $field = $1;

            #XXX property values cannot contain parens "(..)", because regex doesn't count parens, just stops at first ")"...

            # is this a single property, not a field?
            if ($field =~ s|^\s*\@([_a-z0-9]+)\((.*?)\)\s*$|$props{$1}=$2;""|sei) {
                next;
            }
            if ($field =~ s|^\s*\@([_a-z0-9]+)\s*$|$props{$1}="true";""|sei) {
                next;
            }

            # properties, with @propertyname(value) syntax
            %fieldprop = ();
            $field =~ s|\@([_a-z0-9]+)\((.*?)\)|$fieldprop{$1}=$2;""|gsei;
            $field =~ s|\@([_a-z0-9]+)|$fieldprop{$1}="true";""|gsei;

            # abstract
            if ($field =~ s/^\s*abstract\s+//s) {
                $isabstract = 1;
                if ($keyword eq 'struct') {
                    print STDERR "*** Error: a struct cannot have abstract fields in '$msgname'\n"; $ret=1;
                }
            } else {
                $isabstract = 0;
            }

            #
            # NOTE: we cannot properly support 'readonly' fields in opp_msgc,
            # because we don't know if a field is new or it's already defined
            # in the base class! So we cannot decide we should put it into the
            # descriptor class or not.
            #
            # Implementing proper imports will solve this issue.
            #

            # enum() -- treat it as @enum()
            if ($field =~ s/enum\s*\((.*?)\)\s*//s) {
                $fieldprop{"enum"} = $1;
            }

            # default value
            if ($field =~ s/=\s*(.*?)\s*$//s) {
                $fieldvalue = $1;
            } else {
                $fieldvalue = '';
            }

            # array
            if ($field =~ s/\[\s*(.*?)\s*\]\s*$//s) {
                $isarray = 1;
                $arraysize = $1;
                if ($arraysize !~ /^[0-9]*$/ && $arraysize !~ /^[A-Za-z_][A-Za-z0-9_]*$/) {
                    print STDERR "*** Error: array size must be numeric or symbolic constant (not '$arraysize') in '$msgname'\n"; $ret=1;
                }
                if ($arraysize eq '' && $keyword eq 'struct') {
                    print STDERR "*** Error: a struct cannot have dynamic array fields in '$msgname'\n"; $ret=1;
                }
            } else {
                $isarray = 0;
                $arraysize = '';
            }

            # 'fieldtype fieldname'...
            if ($field =~ /^\s*([A-Za-z_][A-Za-z0-9_* \t\n]*[* \t\n])([A-Za-z_][A-Za-z0-9_]*)\s*$/s)
            {
                $fieldtype = $1;
                $fieldname = $2;
                $fieldtype =~ s/\s*$//sg;
                $fieldtype =~ s/\s+/ /sg;

                if ($isabstract && $fieldvalue ne '') {
                    print STDERR "*** Error: an abstract field cannot be assigned a value in '$msgname'\n"; $ret=1;
                }

                push(@fieldlist,$fieldname);
                $ftype{$fieldname} = $fieldtype;
                $fval{$fieldname} = $fieldvalue;
                $fisabstract{$fieldname} = $isabstract;
                $fisarray{$fieldname} = $isarray;
                $farraysize{$fieldname} = $arraysize;
                #print "$msgname field=$fieldname type=$ftype{$fieldname} value=$fval{$fieldname} isarray=$fisarray{$fieldname} arraysize=$farraysize{$fieldname}\n";
                for $key (keys(%fieldprop)) {
                    $fprops{$fieldname}->{$key} = $fieldprop{$key};
                    #print "$key => $fprops{$fieldname}->{$key}\n";
                }
            }
            # ...or just fieldname
            elsif ($field =~ /^\s*([A-Za-z_][A-Za-z0-9_]*)\s*$/s)
            {
                $fieldname = $1;

                if ($isabstract) {
                    print STDERR "*** Error: an abstract field needs a type in '$msgname'\n"; $ret=1;
                }
                if ($isarray) {
                    print STDERR "*** Error: cannot set array field of the base class in '$msgname'\n"; $ret=1;
                }
                if ($fieldenum ne '') {
                    print STDERR "*** Error: cannot specify enum for base class field in '$msgname'\n"; $ret=1;
                }
                if ($fieldvalue eq '') {
                    print STDERR "*** Error: missing field type in '$msgname'\n"; $ret=1;
                }

                if ($fieldname =~ /^($reservedwords)$/) {
                    print STDERR "*** Error: field name '$fieldname' is a reserved word\n"; $ret=1;
                }

                push(@baseclassfieldlist,$fieldname);
                $fval{$fieldname} = $fieldvalue;
                #print "$msgname baseclassfield=$fieldname value=$fval{$fieldname}\n";
            }
            else {$scrap.=$field;}
        }
        $scrap.=$fields;
        if ($scrap =~ /[^ \t\n]/s)
        {
            $scrap =~ s/\n\n+/\n\n/sg;
            $scrap =~ s/^\n+//s;
            $scrap =~ s/\n+$//s;
            print STDERR "*** Error: some parts not understood in 'fields' section of '$msgname':\n"; $ret=1;
            print STDERR "'$scrap'\n";
        }
    }

    # now generate code
    prepareForCodeGeneration();
    if ($generate_classes) {
        if ($classtype eq 'struct') {
            generateStruct();
        } else {
            generateClass();
        }
    }
    if ($generate_descriptions) {
        generateDescriptorClass();
    }
}

$scrap = $msg;
if ($scrap =~ /[^ \t\n]/s)
{
    $scrap =~ s/\n\n+/\n\n/sg;
    $scrap =~ s/^\n//s;
    $scrap =~ s/\n$//s;
    print STDERR "*** Error: following parts of input file were not understood:\n"; $ret=1;
    print STDERR "'$scrap'\n";
}

print H "#endif // $hdef\n";


close(H);
close(CC);

if ($ret)
{
    unlink($hfile);
    unlink($ccfile);
}
exit $ret;


#
# prepare for code generation
#
# in variables:
#
#  $keyword
#  $classtype
#  $gap
#  $omitgetverb
#  $msgclass
#  $realmsgclass
#  $msgbaseclass
#
#  $msgdescclass
#
#  $fieldcount
#  @fieldlist
#  %props
#
#  %ftype{fieldname}
#  %fval{fieldname}
#  %fisabstract{fieldname}
#  %fispointer{$fieldname}
#  %fisarray{fieldname}
#  %farraysize{fieldname}
#  %fprops{fieldname}->{propname}
#
#  %fkind{fieldname}
#  %datatype{fieldname}
#  %argtype{fieldname}
#  %rettype{fieldname}
#  %var{fieldname}
#  %varsize{fieldname}
#  %getter{fieldname}
#  %setter{fieldname}
#  %alloc{fieldname}
#  %getsize{fieldname}
#  %tostring{fieldname}
#  %fromstring{fieldname}
#  %maybe_c_str{fieldname}
#

sub prepareForCodeGeneration
{

    # check base class and determine type of object
    if ($msgbase eq '') {
        if ($keyword eq 'message' || $msgname eq 'cObject') {
            $classtype = 'cobject';
        } elsif ($keyword eq 'class') {
            $classtype = 'cpolymorphic'; # Note: we never generate non-cPolymorphic classes
        } elsif ($keyword eq 'struct') {
            $classtype = 'struct';
        } else {
            die 'internal error';
        }
        # if announced earlier as noncpolymorphic, accept that. XXX needs to be re-thought
        if (grep(/^\Q$msgname\E$/,@classes)) {
            if ($classtype{$msgname} eq 'foreignclass' && $classtype eq 'cpolymorphic') {
                $classtype = 'foreignclass';
            }
        }

    } else {
        if (!grep(/^\Q$msgbase\E$/,@classes)) {
            print STDERR "*** Error: unknown base class '$msgbase'\n"; $ret=1;
        }
        $classtype = $classtype{$msgbase};
    }

    # check earlier declarations and register this class
    if (grep(/^\Q$msgname\E$/,@classes)) {
        if (0) { # XXX add condition
            print STDERR "*** Error: attempt to redefine '$msgname'\n"; $ret=1;
        } elsif ($classtype{$msgname} ne $classtype) {
            print STDERR "*** Error: definition of '$msgname' inconsistent with earlier declaration(s)\n"; $ret=1;
        }
    } else {
        push(@classes, $msgname);
        $classtype{$msgname} = $classtype;
    }

    #
    # produce all sorts of derived names
    #
    if ($props{"customize"} eq "true") {
        $gap = 1;
        $msgclass = $msgname."_Base";
        $realmsgclass = $msgname;
        $msgdescclass = $realmsgclass."Descriptor";
    } else {
        $gap = 0;
        $msgclass = $msgname;
        $realmsgclass = $msgclass;
        $msgdescclass = $msgclass."Descriptor";
    }
    if ($msgbase eq '') {
        if ($keyword eq 'message') {
            $msgbaseclass = 'cMessage';
        } elsif ($keyword eq 'class') {
            $msgbaseclass = 'cPolymorphic';  # note: all classes we generate subclass from cPolymorphic!
        } elsif ($keyword eq 'struct') {
            $msgbaseclass = '';
        } else {
            die 'internal error';
        }
    } else {
        $msgbaseclass = $msgbase;
    }

    if ($props{"omitGetVerb"} eq "true") {
        $omitgetverb = 1;
    } else {
        $omitgetverb = 0;
    }

    foreach $fieldname (@fieldlist)
    {
        if ($fisabstract{$fieldname} && !$gap) {
            print STDERR "*** Error: abstract fields need 'customize=true' property in '$msgname'\n"; $ret=1;
        }
        if ($fprops{$fieldname}->{"enum"} ne '' && !grep(/^\Q$fprops{$fieldname}->{"enum"}\E$/,@enums)) {
            print STDERR "*** Error: undeclared enum '$fprops{$fieldname}->{enum}' used in '$msgname'\n"; $ret=1;
        }
        if ($classtype{$ftype{$fieldname}} eq 'cobject' && ($classtype ne 'cobject')) {
            print STDERR "*** Error: cannot use cObject field '$ftype{$fieldname} $fieldname' in struct or non-cObject class '$msgname'\n"; $ret=1;
        }

        # variable name
        if ($classtype eq 'struct') {
            $var{$fieldname} = $fieldname;
        } else {
            $var{$fieldname} = $fieldname."_var";
        }
        $varsize{$fieldname} = $fieldname."_arraysize";

        # method names
        if ($classtype ne 'struct') {
            $capfieldname = $fieldname;
            $capfieldname =~ s/(.)(.*)/uc($1).$2/e;
            $setter{$fieldname} = "set".$capfieldname;
            $alloc{$fieldname} = "set".$capfieldname."ArraySize";
            if ($omitgetverb) {
                $getter{$fieldname} = $fieldname;
                $getsize{$fieldname} = $fieldname."ArraySize";
            } else {
                $getter{$fieldname} = "get".$capfieldname;
                $getsize{$fieldname} = "get".$capfieldname."ArraySize";
            }

            # allow customization of names
            if ($fprops{$fieldname}->{setter} ne '') {
                $setter{$fieldname} = $fprops{$fieldname}->{setter};
            }
            if ($fprops{$fieldname}->{getter} ne '') {
                $getter{$fieldname} = $fprops{$fieldname}->{getter};
            }
            if ($fprops{$fieldname}->{sizeSetter} ne '') {
                $alloc{$fieldname} = $fprops{$fieldname}->{sizeSetter};
            }
            if ($fprops{$fieldname}->{sizeGetter} ne '') {
                $getsize{$fieldname} = $fprops{$fieldname}->{sizeGetter};
            }
        }

        # pointer
        if ($ftype{$fieldname} =~ /^(.*?)\s*\*$/) {
            $ftype{$fieldname} = $1;
            $fispointer{$fieldname} = 1;
        } else {
            $fispointer{$fieldname} = 0;
        }

        $ftype = $ftype{$fieldname};

        # data type, argument type, conversion to/from string...
        if (grep(/^\Q$ftype\E$/,@classes)) {
            $fkind{$fieldname} = 'struct';
        } else {
            $fkind{$fieldname} = 'basic';
        }
        $maybe_c_str{$fieldname} = "";
        if ($fkind{$fieldname} eq 'struct') {
            $datatype{$fieldname} = $ftype;
            $argtype{$fieldname} = "const $ftype&";
            $rettype{$fieldname} = "$ftype&";
            $tostring{$fieldname} = "";
            $fromstring{$fieldname} = "";
            #$fval{$fieldname} = '' unless ($fval{$fieldname} ne '');
        } elsif ($fkind{$fieldname} eq 'basic') {
            if ($ftype eq "bool") {
                $datatype{$fieldname} = "bool";
                $argtype{$fieldname} = "bool";
                $rettype{$fieldname} = "bool";
                $tostring{$fieldname} = "bool2string";
                $fromstring{$fieldname} = "string2bool";
                $fval{$fieldname} = 'false' unless ($fval{$fieldname} ne '');
            } elsif ($ftype eq "char") {
                $datatype{$fieldname} = "char";
                $argtype{$fieldname} = "char";
                $rettype{$fieldname} = "char";
                $tostring{$fieldname} = "long2string";
                $fromstring{$fieldname} = "string2long";
                $fval{$fieldname} = '0' unless ($fval{$fieldname} ne '');
            } elsif ($ftype eq "unsigned char") {
                $datatype{$fieldname} = "unsigned char";
                $argtype{$fieldname} = "unsigned char";
                $rettype{$fieldname} = "unsigned char";
                $tostring{$fieldname} = "long2string";
                $fromstring{$fieldname} = "string2long";
                $fval{$fieldname} = '0' unless ($fval{$fieldname} ne '');
            } elsif ($ftype eq "short") {
                $datatype{$fieldname} = "short";
                $argtype{$fieldname} = "short";
                $rettype{$fieldname} = "short";
                $tostring{$fieldname} = "long2string";
                $fromstring{$fieldname} = "string2long";
                $fval{$fieldname} = '0' unless ($fval{$fieldname} ne '');
            } elsif ($ftype eq "unsigned short") {
                $datatype{$fieldname} = "unsigned short";
                $argtype{$fieldname} = "unsigned short";
                $rettype{$fieldname} = "unsigned short";
                $tostring{$fieldname} = "long2string";
                $fromstring{$fieldname} = "string2long";
                $fval{$fieldname} = '0' unless ($fval{$fieldname} ne '');
            } elsif ($ftype eq "int") {
                $datatype{$fieldname} = "int";
                $argtype{$fieldname} = "int";
                $rettype{$fieldname} = "int";
                $tostring{$fieldname} = "long2string";
                $fromstring{$fieldname} = "string2long";
                $fval{$fieldname} = '0' unless ($fval{$fieldname} ne '');
            } elsif ($ftype eq "unsigned int") {
                $datatype{$fieldname} = "unsigned int";
                $argtype{$fieldname} = "unsigned int";
                $rettype{$fieldname} = "unsigned int";
                $tostring{$fieldname} = "long2string";
                $fromstring{$fieldname} = "string2long";
                $fval{$fieldname} = '0' unless ($fval{$fieldname} ne '');
            } elsif ($ftype eq "long") {
                $datatype{$fieldname} = "long";
                $argtype{$fieldname} = "long";
                $rettype{$fieldname} = "long";
                $tostring{$fieldname} = "long2string";
                $fromstring{$fieldname} = "string2long";
                $fval{$fieldname} = '0' unless ($fval{$fieldname} ne '');
            } elsif ($ftype eq "unsigned long") {
                $datatype{$fieldname} = "unsigned long";
                $argtype{$fieldname} = "unsigned long";
                $rettype{$fieldname} = "unsigned long";
                $tostring{$fieldname} = "long2string";
                $fromstring{$fieldname} = "string2long";
                $fval{$fieldname} = '0' unless ($fval{$fieldname} ne '');
            } elsif ($ftype eq "double") {
                $datatype{$fieldname} = "double";
                $argtype{$fieldname} = "double";
                $rettype{$fieldname} = "double";
                $tostring{$fieldname} = "double2string";
                $fromstring{$fieldname} = "string2double";
                $fval{$fieldname} = '0' unless ($fval{$fieldname} ne '');
            } elsif ($ftype eq "simtime_t") {
                $datatype{$fieldname} = "simtime_t";
                $argtype{$fieldname} = "simtime_t";
                $rettype{$fieldname} = "simtime_t";
                $tostring{$fieldname} = "double2string";
                $fromstring{$fieldname} = "string2double";
                $fval{$fieldname} = '0' unless ($fval{$fieldname} ne '');
            } elsif ($ftype eq "string") {
                $datatype{$fieldname} = "opp_string";
                $argtype{$fieldname} = "const char *";
                $rettype{$fieldname} = "const char *";
                $tostring{$fieldname} = "oppstring2string";
                $fromstring{$fieldname} = "";
                $fval{$fieldname} = '""' unless ($fval{$fieldname} ne '');
                $maybe_c_str{$fieldname} = ".c_str()";
            } else {
                print STDERR "*** Error: unknown data type '$ftype' (is it struct?)\n"; $ret=1;
                $datatype{$fieldname} = $ftype;
                $argtype{$fieldname} = $ftype;
                $rettype{$fieldname} = $ftype;
                $tostring{$fieldname} = "";  # means op<<
                $fromstring{$fieldname} = "";
                $fval{$fieldname} = '0' unless ($fval{$fieldname} ne '');
            }
        } else {
            die 'internal error';
        }
    }
}


#
# print class
#
sub generateClass
{
    print H "/**\n";
    print H " * Class generated from <tt>$filename</tt> by opp_msgc.\n";
    $source =~ s/^/ * /mg;
    print H " * <pre>\n$source\n * </pre>\n";

    if ($gap)
    {
        print H " *\n";
        print H " * $msgclass is only useful if it gets subclassed, and $realmsgclass is derived from it.\n";
        print H " * The minimum code to be written for $realmsgclass is the following:\n";
        print H " *\n";
        print H " * <pre>\n";
        print H " * class $exportdef$realmsgclass : public $msgclass\n";
        print H " * {\n";
        print H " *   public:\n";
        if ($classtype eq "cobject") {
            if ($keyword eq "message") {
                print H " *     $realmsgclass(const char *name=NULL, int kind=0) : $msgclass(name,kind) {}\n";
            } else {
                print H " *     $realmsgclass(const char *name=NULL) : $msgclass(name) {}\n";
            }
            print H " *     $realmsgclass(const $realmsgclass& other) : $msgclass(other.name()) {operator=(other);}\n";
        } else {
            print H " *     $realmsgclass() : $msgclass() {}\n";
            print H " *     $realmsgclass(const $realmsgclass& other) : $msgclass() {operator=(other);}\n";
        }
        print H " *     $realmsgclass& operator=(const $realmsgclass& other) {$msgclass\:\:operator=(other); return *this;}\n";
        if ($classtype eq "cobject" || $classtype eq "cpolymorphic") {
            print H " *     virtual cPolymorphic *dup() const {return new $realmsgclass(*this);}\n";
        }
        print H " *     // ADD CODE HERE to redefine and implement pure virtual functions from $msgclass\n";
        print H " * };\n";
        print H " * </pre>\n";
        if ($classtype eq "cobject" || $classtype eq "cpolymorphic") {
            print H " *\n";
            print H " * The following should go into a .cc (.cpp) file:\n";
            print H " *\n";
            print H " * <pre>\n";
            print H " * Register_Class($realmsgclass);\n";
            print H " * </pre>\n";
        }
    }
    print H " */\n";
    if ($msgbaseclass eq "") {
        print H "class $exportdef$msgclass\n";
    } else {
        print H "class $exportdef$msgclass : public $msgbaseclass\n";
    }
    print H "{\n";
    print H "  protected:\n";
    foreach $fieldname (@fieldlist)
    {
        if ($fispointer{$fieldname}) {
            print STDERR "*** Error: pointers not supported yet in '$msgname'\n"; $ret=1; return;
        }
        if (!$fisabstract{$fieldname}) {
            if ($fisarray{$fieldname} && $farraysize{$fieldname} ne '') {
                print H "    $datatype{$fieldname} $var{$fieldname}\[$farraysize{$fieldname}\];\n";
            } elsif ($fisarray{$fieldname} && $farraysize{$fieldname} eq '') {
                print H "    $datatype{$fieldname} *$var{$fieldname}; // array ptr\n";
                print H "    unsigned int $varsize{$fieldname};\n";
            } else {
                print H "    $datatype{$fieldname} $var{$fieldname};\n";
            }
        }
    }
    print H "\n";
    print H "    // protected and unimplemented operator==(), to prevent accidental usage\n";
    print H "    bool operator==(const $msgclass&);\n";
    if ($gap) {
        print H "    // make constructors protected to avoid instantiation\n";
    } else {
        print H "\n";
        print H "  public:\n";
    }
    if ($classtype eq "cobject") {
        if ($keyword eq "message") {
            print H "    $msgclass(const char *name=NULL, int kind=0);\n";
        } else {
            print H "    $msgclass(const char *name=NULL);\n";
        }
    } else {
        print H "    $msgclass();\n";
    }
    print H "    $msgclass(const $msgclass& other);\n";
    if ($gap) {
        print H "    // make assignment operator protected to force the user override it\n";
        print H "    $msgclass& operator=(const $msgclass& other);\n";
        print H "\n";
        print H "  public:\n";
    }
    print H "    virtual ~$msgclass();\n";
    if (!$gap) {
        print H "    $msgclass& operator=(const $msgclass& other);\n";
    }
    # unfortunately we don't know whether this class is cPolymorphic or not, so we can't add a dup() there...
    # TODO once we drop MSVC 6.0 support, we can use covariant return types here, and that'll solve the problem.
    if ($classtype eq "cobject" || $classtype eq "cpolymorphic") {
        if ($gap) {
            print H "    virtual cPolymorphic *dup() const {throw new cRuntimeError(\"You forgot to manually add a dup() function to class $realmsgclass\");}\n";
        } else {
            print H "    virtual cPolymorphic *dup() const {return new $msgclass(*this);}\n";
        }
    }
    print H "    virtual void netPack(cCommBuffer *b);\n";
    print H "    virtual void netUnpack(cCommBuffer *b);\n";
    print H "\n";
    print H "    // field getter/setter methods\n";
    foreach $fieldname (@fieldlist)
    {
        if ($fisabstract{$fieldname}) {
            $pure = ' = 0';
        } else {
            $pure = '';
        }
        $isstruct = ($fkind{$fieldname} eq 'struct');
        $constifprimitivetype = (!$isstruct ? ' const' : '');
        if ($fisarray{$fieldname} && $farraysize{$fieldname} ne '') {
            print H "    virtual unsigned int $getsize{$fieldname}() const$pure;\n";
            print H "    virtual $rettype{$fieldname} $getter{$fieldname}(unsigned int k)$constifprimitivetype$pure;\n";
            print H "    virtual const $rettype{$fieldname} $getter{$fieldname}(unsigned int k) const {return const_cast<$msgclass*>(this)->$getter{$fieldname}(k);}\n" if ($isstruct);
            print H "    virtual void $setter{$fieldname}(unsigned int k, $argtype{$fieldname} $var{$fieldname})$pure;\n";
        } elsif ($fisarray{$fieldname} && $farraysize{$fieldname} eq '') {
            print H "    virtual void $alloc{$fieldname}(unsigned int size)$pure;\n";
            print H "    virtual unsigned int $getsize{$fieldname}() const$pure;\n";
            print H "    virtual $rettype{$fieldname} $getter{$fieldname}(unsigned int k)$constifprimitivetype$pure;\n";
            print H "    virtual const $rettype{$fieldname} $getter{$fieldname}(unsigned int k) const {return const_cast<$msgclass*>(this)->$getter{$fieldname}(k);}\n" if ($isstruct);
            print H "    virtual void $setter{$fieldname}(unsigned int k, $argtype{$fieldname} $var{$fieldname})$pure;\n";
        } else {
            print H "    virtual $rettype{$fieldname} $getter{$fieldname}()$constifprimitivetype$pure;\n";
            print H "    virtual const $rettype{$fieldname} $getter{$fieldname}() const {return const_cast<$msgclass*>(this)->$getter{$fieldname}();}\n" if ($isstruct);
            print H "    virtual void $setter{$fieldname}($argtype{$fieldname} $var{$fieldname})$pure;\n";
        }
    }
    print H "};\n\n";

    if (!$gap) {
        if ($classtype eq "cobject" || $classtype eq "cpolymorphic") {
            print CC "Register_Class($msgclass);\n\n";
        }
        print H "inline void doPacking(cCommBuffer *b, $realmsgclass& obj) {obj.netPack(b);}\n";
        print H "inline void doUnpacking(cCommBuffer *b, $realmsgclass& obj) {obj.netUnpack(b);}\n\n";
    }

    if ($classtype eq "cobject") {
        if ($keyword eq "message") {
            # CAREFUL when assigning values to existing members gets implemented!
            # The msg kind passed to the ctor should take priority!!!
            print CC "$msgclass\:\:$msgclass(const char *name, int kind) : $msgbaseclass(name,kind)\n";
        } else {
            if ($msgbaseclass eq "") {
                print CC "$msgclass\:\:$msgclass(const char *name)\n";
            } else {
                print CC "$msgclass\:\:$msgclass(const char *name) : $msgbaseclass(name)\n";
            }
        }
    } else {
        if ($msgbaseclass eq "") {
            print CC "$msgclass\:\:$msgclass()\n";
        } else {
            print CC "$msgclass\:\:$msgclass() : $msgbaseclass()\n";
        }
    }
    print CC "{\n";
    foreach $fieldname (@baseclassfieldlist)
    {
        $capfieldname = $fieldname;
        $capfieldname =~ s/(.)(.*)/uc($1).$2/e;
        $setter = "set".$capfieldname;
        print CC "    this->$setter($fval{$fieldname});\n";
    }
    print CC "\n" if (@baseclassfieldlist!=() && @fieldlist!=());
    my $hasarray=0;
    foreach $fieldname (@fieldlist) {$hasarray=1 if ($fisarray{$fieldname});}
    print CC "    unsigned int i;\n" if ($hasarray);
    foreach $fieldname (@fieldlist)
    {
        if (!$fisabstract{$fieldname}) {
            if ($fisarray{$fieldname} && $farraysize{$fieldname} ne '') {
                if ($fkind{$fieldname} eq 'basic') {
                    print CC "    for (i=0; i<$farraysize{$fieldname}; i++)\n";
                    print CC "        this->$var{$fieldname}\[i\] = $fval{$fieldname};\n";
                }
                if ($classtype{$ftype{$fieldname}} eq 'cobject') {
                  print CC "    for (i=0; i<$farraysize{$fieldname}; i++)\n";
                  print CC "        take(&(this->$var{$fieldname}\[i\]));\n";
                }
            } elsif ($fisarray{$fieldname} && $farraysize{$fieldname} eq '') {
                print CC "    $varsize{$fieldname} = 0;\n";
                print CC "    this->$var{$fieldname} = 0;\n";
            } else {
                if ($fval{$fieldname} ne '') {
                  print CC "    this->$var{$fieldname} = $fval{$fieldname};\n";
                }
                if ($classtype{$ftype{$fieldname}} eq 'cobject') {
                  print CC "    take(&(this->$var{$fieldname}));\n";
                }
            }
        }
    }
    print CC "}\n\n";
    if ($msgbaseclass eq "") {
        print CC "$msgclass\:\:$msgclass(const $msgclass& other)\n";
    } else {
        print CC "$msgclass\:\:$msgclass(const $msgclass& other) : $msgbaseclass()\n";
    }
    print CC "{\n";
    print CC "    unsigned int i;\n";
    if ($classtype eq "cobject") {
        print CC "    setName(other.name());\n";
    }
    foreach $fieldname (@fieldlist)
    {
      if (!$fisabstract{$fieldname}) {
        if ($fisarray{$fieldname} && $farraysize{$fieldname} ne '') {
          if ($classtype{$ftype{$fieldname}} eq 'cobject') {
            print CC "    for (i=0; i<$farraysize{$fieldname}; i++)\n";
            print CC "        take(&(this->$var{$fieldname}\[i\]));\n";
          }
        } elsif ($fisarray{$fieldname} && $farraysize{$fieldname} eq '') {
          print CC "    $varsize{$fieldname} = 0;\n";
          print CC "    this->$var{$fieldname} = 0;\n";
        } elsif (!$fisarray{$fieldname} && $classtype{$ftype{$fieldname}} eq 'cobject') {
          print CC "    take(&(this->$var{$fieldname}));\n";
        }
      }
    }
    print CC "    operator=(other);\n";
    print CC "}\n\n";
    print CC "$msgclass\:\:~$msgclass()\n";
    print CC "{\n";
    print CC "    unsigned int i;\n";
    foreach $fieldname (@fieldlist)
    {
        if (!$fisabstract{$fieldname}) {
            if ($classtype{$ftype{$fieldname}} eq 'cobject') {
                if (!$fisarray{$fieldname}) {
                    print CC "    drop(&(this->$var{$fieldname}));\n";
                } elsif ($farraysize{$fieldname} ne '') {
                    print CC "    for (i=0; i<$farraysize{$fieldname}; i++)\n";
                    print CC "        drop(&(this->$var{$fieldname}\[i\]));\n";
                } else {
                    print CC "    for (i=0; i<$varsize{$fieldname}; i++)\n";
                    print CC "        drop(&(this->$var{$fieldname}\[i\]));\n";
                }
            }
            if ($fisarray{$fieldname} && $farraysize{$fieldname} eq '') {
                print CC "    delete [] $var{$fieldname};\n";
            }
        }
    }
    print CC "}\n\n";
    print CC "$msgclass& $msgclass\:\:operator=(const $msgclass& other)\n";
    print CC "{\n";
    print CC "    if (this==&other) return *this;\n";
    print CC "    unsigned int i;\n";
    if ($msgbaseclass ne "") {
        print CC "    $msgbaseclass\:\:operator=(other);\n";
    }
    foreach $fieldname (@fieldlist)
    {
        if (!$fisabstract{$fieldname}) {
            if ($fisarray{$fieldname} && $farraysize{$fieldname} ne '') {
                print CC "    for (i=0; i<$farraysize{$fieldname}; i++)\n";
                print CC "        this->$var{$fieldname}\[i\] = other.$var{$fieldname}\[i\];\n";
                if ($classtype{$ftype{$fieldname}} eq 'cobject') {
                    print CC "    for (i=0; i<$farraysize{$fieldname}; i++)\n";
                    print CC "        this->$var{$fieldname}\[i\].setName(other.$var{$fieldname}\[i\].name());\n";
                }
            } elsif ($fisarray{$fieldname} && $farraysize{$fieldname} eq '') {
                print CC "    delete [] this->$var{$fieldname};\n";
                print CC "    this->$var{$fieldname} = (other.$varsize{$fieldname}==0) ? NULL : new $datatype{$fieldname}\[other.$varsize{$fieldname}\];\n";
                print CC "    $varsize{$fieldname} = other.$varsize{$fieldname};\n";
                print CC "    for (i=0; i<$varsize{$fieldname}; i++)\n";
                if ($classtype{$ftype{$fieldname}} eq 'cobject') {
                    print CC "    {\n";
                    print CC "        take(&(this->$var{$fieldname}\[i\]));\n";
                    print CC "        this->$var{$fieldname}\[i\] = other.$var{$fieldname}\[i\];\n";
                    print CC "        this->$var{$fieldname}\[i\].setName(other.$var{$fieldname}\[i\].name());\n";
                    print CC "    }\n";
                } else {
                    print CC "        this->$var{$fieldname}\[i\] = other.$var{$fieldname}\[i\];\n";
                }
            } else {
                print CC "    this->$var{$fieldname} = other.$var{$fieldname};\n";
                if (!$fisarray{$fieldname} && $classtype{$ftype{$fieldname}} eq 'cobject') {
                    print CC "    this->$var{$fieldname}.setName(other.$var{$fieldname}.name());\n";
                }
            }
        }
    }
    print CC "    return *this;\n";
    print CC "}\n\n";

    #
    # Note: This class may not be derived from cObject, and then this netPack()/
    # netUnpack() is NOT that of cObject. However it's still needed because a
    # "friend" doPacking() function could not access protected members otherwise.
    #
    print CC "void $msgclass\:\:netPack(cCommBuffer *b)\n";
    print CC "{\n";
    if ($msgbaseclass ne "") {
        if ($classtype eq "cobject" || $classtype eq "cpolymorphic") {
            print CC "    $msgbaseclass\:\:netPack(b);\n" unless ($msgbaseclass eq "cPolymorphic");
        } else {
            print CC "    doPacking(b,($msgbaseclass&)*this);\n"; # this would do for cObject too, but the other is nicer
        }
    }
    foreach $fieldname (@fieldlist)
    {
        if ($fisabstract{$fieldname}) {
            print CC "    // field $fieldname is abstract -- please do packing in customized class\n";
        } else {
            if ($fisarray{$fieldname} && $farraysize{$fieldname} ne '') {
                print CC "    doPacking(b,this->$var{$fieldname},$farraysize{$fieldname});\n";
            } elsif ($fisarray{$fieldname} && $farraysize{$fieldname} eq '') {
                print CC "    b->pack($varsize{$fieldname});\n";
                print CC "    doPacking(b,this->$var{$fieldname},$varsize{$fieldname});\n";
            } else {
                print CC "    doPacking(b,this->$var{$fieldname});\n";
            }
        }
    }
    print CC "}\n\n";

    print CC "void $msgclass\:\:netUnpack(cCommBuffer *b)\n";
    print CC "{\n";
    if ($msgbaseclass ne "") {
        if ($classtype eq "cobject" || $classtype eq "cpolymorphic") {
            print CC "    $msgbaseclass\:\:netUnpack(b);\n" unless ($msgbaseclass eq "cPolymorphic");
        } else {
            print CC "    doUnpacking(b,($msgbaseclass&)*this);\n"; # this would do for cObject too, but the other is nicer
        }
    }
    foreach $fieldname (@fieldlist)
    {
        if ($fisabstract{$fieldname}) {
            print CC "    // field $fieldname is abstract -- please do unpacking in customized class\n";
        } else {
            if ($fisarray{$fieldname} && $farraysize{$fieldname} ne '') {
                print CC "    doUnpacking(b,this->$var{$fieldname},$farraysize{$fieldname});\n";
            } elsif ($fisarray{$fieldname} && $farraysize{$fieldname} eq '') {
                print CC "    delete [] this->$var{$fieldname};\n";
                print CC "    b->unpack($varsize{$fieldname});\n";
                print CC "    if ($varsize{$fieldname}==0) {\n";
                print CC "        this->$var{$fieldname} = 0;\n";
                print CC "    } else {\n";
                print CC "        this->$var{$fieldname} = new $datatype{$fieldname}\[$varsize{$fieldname}\];\n";
                print CC "        doUnpacking(b,this->$var{$fieldname},$varsize{$fieldname});\n";
                print CC "    }\n";
            } else {
                print CC "    doUnpacking(b,this->$var{$fieldname});\n";
            }
        }
    }
    print CC "}\n\n";

    foreach $fieldname (@fieldlist)
    {
        if (!$fisabstract{$fieldname}) {
            $isstruct = ($fkind{$fieldname} eq 'struct');
            $constifprimitivetype = (!$isstruct ? ' const' : '');
            if ($fisarray{$fieldname} && $farraysize{$fieldname} ne '') {
                print CC "unsigned int $msgclass\:\:$getsize{$fieldname}() const\n";
                print CC "{\n";
                print CC "    return $farraysize{$fieldname};\n";
                print CC "}\n\n";
                print CC "$rettype{$fieldname} $msgclass\:\:$getter{$fieldname}(unsigned int k)$constifprimitivetype\n";
                print CC "{\n";
                print CC "    if (k>=$farraysize{$fieldname}) throw new cRuntimeError(\"Array of size $farraysize{$fieldname} indexed by \%d\", k);\n";
                print CC "    return $var{$fieldname}\[k\]$maybe_c_str{$fieldname};\n";
                print CC "}\n\n";
                print CC "void $msgclass\:\:$setter{$fieldname}(unsigned int k, $argtype{$fieldname} $var{$fieldname})\n";
                print CC "{\n";
                print CC "    if (k>=$farraysize{$fieldname}) throw new cRuntimeError(\"Array of size $farraysize{$fieldname} indexed by \%d\", k);\n";
                print CC "    this->$var{$fieldname}\[k\] = $var{$fieldname};\n";
                print CC "}\n\n";
            } elsif ($fisarray{$fieldname} && $farraysize{$fieldname} eq '') {
                print CC "void $msgclass\:\:$alloc{$fieldname}(unsigned int size)\n";
                print CC "{\n";
                print CC "    $datatype{$fieldname} *$var{$fieldname}2 = (size==0) ? NULL : new $datatype{$fieldname}\[size\];\n";
                print CC "    unsigned int sz = $varsize{$fieldname} < size ? $varsize{$fieldname} : size;\n";
                print CC "    unsigned int i;\n";
                print CC "    for (i=0; i<sz; i++)\n";
                print CC "        $var{$fieldname}2\[i\] = this->$var{$fieldname}\[i\];\n";
                if ($fkind{$fieldname} eq 'basic') {
                    print CC "    for (i=sz; i<size; i++)\n";
                    print CC "        $var{$fieldname}2\[i\] = 0;\n";
                }
                if ($classtype{$ftype{$fieldname}} eq 'cobject') {
                    print CC "    for (i=sz; i<size; i++)\n";
                    print CC "        take(&($var{$fieldname}2\[i\]));\n";
                }
                print CC "    $varsize{$fieldname} = size;\n";
                print CC "    delete [] this->$var{$fieldname};\n";
                print CC "    this->$var{$fieldname} = $var{$fieldname}2;\n";
                print CC "}\n\n";
                print CC "unsigned int $msgclass\:\:$getsize{$fieldname}() const\n";
                print CC "{\n";
                print CC "    return $varsize{$fieldname};\n";
                print CC "}\n\n";
                print CC "$rettype{$fieldname} $msgclass\:\:$getter{$fieldname}(unsigned int k)$constifprimitivetype\n";
                print CC "{\n";
                print CC "    if (k>=$varsize{$fieldname}) throw new cRuntimeError(\"Array of size \%d indexed by \%d\", $varsize{$fieldname}, k);\n";
                print CC "    return $var{$fieldname}\[k\]$maybe_c_str{$fieldname};\n";
                print CC "}\n\n";
                print CC "void $msgclass\:\:$setter{$fieldname}(unsigned int k, $argtype{$fieldname} $var{$fieldname})\n";
                print CC "{\n";
                print CC "    if (k>=$varsize{$fieldname}) throw new cRuntimeError(\"Array of size \%d indexed by \%d\", $varsize{$fieldname}, k);\n";
                print CC "    this->$var{$fieldname}\[k\]=$var{$fieldname};\n";
                print CC "}\n\n";
            } else {
                print CC "$rettype{$fieldname} $msgclass\:\:$getter{$fieldname}()$constifprimitivetype\n";
                print CC "{\n";
                print CC "    return $var{$fieldname}$maybe_c_str{$fieldname};\n";
                print CC "}\n\n";
                print CC "void $msgclass\:\:$setter{$fieldname}($argtype{$fieldname} $var{$fieldname})\n";
                print CC "{\n";
                print CC "    this->$var{$fieldname} = $var{$fieldname};\n";
                print CC "}\n\n";
            }
        }
    }
}


#
# print struct
#
sub generateStruct
{
    print H "/**\n";
    print H " * Struct generated from $filename by opp_msgc.\n";
    print H " */\n";
    if ($msgbaseclass eq "") {
        print H "struct $exportdef$msgclass\n";
    } else {
        print H "struct $exportdef$msgclass : public $msgbaseclass\n";
    }
    print H "{\n";
    print H "    $msgclass();\n";
    foreach $fieldname (@fieldlist)
    {
        if ($fisarray{$fieldname}) {
            print H "    $datatype{$fieldname} $var{$fieldname}\[$farraysize{$fieldname}\];\n";
        } else {
            print H "    $datatype{$fieldname} $var{$fieldname};\n";
        }
    }
    print H "};\n\n";

    print H "void $exportdef"."doPacking(cCommBuffer *b, $msgclass& a);\n";
    print H "void $exportdef"."doUnpacking(cCommBuffer *b, $msgclass& a);\n\n";

    print CC "$msgclass\:\:$msgclass()\n";
    print CC "{\n";
    foreach $fieldname (@baseclassfieldlist)
    {
        print CC "    this->$fieldname = $fval{$fieldname};\n";
    }
    print CC "\n" if (@baseclassfieldlist!=() && @fieldlist!=());
    my $hasarray=0;
    foreach $fieldname (@fieldlist) {$hasarray=1 if ($fisarray{$fieldname});}
    print CC "    unsigned int i;\n" if ($hasarray);
    foreach $fieldname (@fieldlist)
    {
        die "abstract field not possible in struct" if ($fisabstract{$fieldname});
        die "cObject field not possible in struct" if ($classtype{$ftype{$fieldname}} eq 'cobject');
        die "dynamic array not possible in struct" if ($fisarray{$fieldname} && $farraysize{$fieldname} eq '');
        if ($fisarray{$fieldname} && $farraysize{$fieldname} ne '') {
            if ($fkind{$fieldname} eq 'basic') {
                print CC "    for (i=0; i<$farraysize{$fieldname}; i++)\n";
                print CC "        $var{$fieldname}\[i\] = $fval{$fieldname};\n";
            }
        } else {
            if ($fval{$fieldname} ne '') {
                print CC "    $var{$fieldname} = $fval{$fieldname};\n";
            }
        }
    }
    print CC "}\n\n";
    print CC "void doPacking(cCommBuffer *b, $msgclass& a)\n";
    print CC "{\n";
    if ($msgbaseclass ne "") {
        print CC "    doPacking(b,($msgbaseclass&)a);\n";
    }
    foreach $fieldname (@fieldlist)
    {
        if ($fisarray{$fieldname}) {
            print CC "    doPacking(b,a.$var{$fieldname},$farraysize{$fieldname});\n";
        } else {
            print CC "    doPacking(b,a.$var{$fieldname});\n";
        }
    }
    print CC "}\n\n";

    print CC "void doUnpacking(cCommBuffer *b, $msgclass& a)\n";
    print CC "{\n";
    if ($msgbaseclass ne "") {
        print CC "    doUnpacking(b,($msgbaseclass&)a);\n";
    }
    foreach $fieldname (@fieldlist)
    {
        if ($fisarray{$fieldname}) {
            print CC "    doUnpacking(b,a.$var{$fieldname},$farraysize{$fieldname});\n";
        } else {
            print CC "    doUnpacking(b,a.$var{$fieldname});\n";
        }
    }
    print CC "}\n\n";
}


#
# print descriptor class
#
sub generateDescriptorClass
{
    print CC "class $msgdescclass : public cClassDescriptor\n";
    print CC "{\n";
    print CC "  public:\n";
    print CC "    $msgdescclass();\n";
    print CC "    virtual ~$msgdescclass();\n";
    print CC "\n";
    print CC "    virtual bool doesSupport(cPolymorphic *obj);\n";
    print CC "    virtual const char *getProperty(const char *propertyname);\n";
    print CC "    virtual int getFieldCount(void *object);\n";
    print CC "    virtual const char *getFieldName(void *object, int field);\n";
    print CC "    virtual unsigned int getFieldTypeFlags(void *object, int field);\n";
    print CC "    virtual const char *getFieldTypeString(void *object, int field);\n";
    print CC "    virtual const char *getFieldProperty(void *object, int field, const char *propertyname);\n";
    print CC "    virtual int getArraySize(void *object, int field);\n";
    print CC "\n";
    print CC "    virtual bool getFieldAsString(void *object, int field, int i, char *resultbuf, int bufsize);\n";
    print CC "    virtual bool setFieldAsString(void *object, int field, int i, const char *value);\n";
    print CC "\n";
    print CC "    virtual const char *getFieldStructName(void *object, int field);\n";
    print CC "    virtual void *getFieldStructPointer(void *object, int field, int i);\n";
    print CC "};\n\n";

    # register class
    print CC "Register_ClassDescriptor($msgdescclass);\n\n";

    # ctor, dtor
    $fieldcount = $#fieldlist+1;
    print CC "$msgdescclass\:\:$msgdescclass() : cClassDescriptor(\"$msgclass\", \"$msgbaseclass\")\n";
    print CC "{\n";
    print CC "}\n";
    print CC "\n";

    print CC "$msgdescclass\:\:~$msgdescclass()\n";
    print CC "{\n";
    print CC "}\n";
    print CC "\n";

    # doesSupport()
    print CC "bool $msgdescclass\:\:doesSupport(cPolymorphic *obj)\n";
    print CC "{\n";
    print CC "    return dynamic_cast<$msgclass *>(obj)!=NULL;\n";
    print CC "}\n";
    print CC "\n";

    # getProperty()
    print CC "const char *$msgdescclass\:\:getProperty(const char *propertyname)\n";
    print CC "{\n";
    for $key (keys %props) {
        $prop = quote($props{$key});
        print CC "    if (!strcmp(propertyname,\"$key\")) return \"$prop\";\n";
    }
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    return basedesc ? basedesc->getProperty(propertyname) : NULL;\n";
    print CC "}\n";
    print CC "\n";

    # getFieldCount()
    print CC "int $msgdescclass\:\:getFieldCount(void *object)\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    return basedesc ? $fieldcount+basedesc->getFieldCount(object) : $fieldcount;\n";
    print CC "}\n";
    print CC "\n";

    # getFieldTypeFlags()
    print CC "unsigned int $msgdescclass\:\:getFieldTypeFlags(void *object, int field)\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    if (basedesc) {\n";
    print CC "        if (field < basedesc->getFieldCount(object))\n";
    print CC "            return basedesc->getFieldTypeFlags(object, field);\n";
    print CC "        field -= basedesc->getFieldCount(object);\n";
    print CC "    }\n";
    print CC "    switch (field) {\n";
    for ($i=0; $i<$fieldcount; $i++)
    {
        @flags = ();
        $fieldname = $fieldlist[$i];
        push(@flags, "FD_ISARRAY") if ($fisarray{$fieldname});
        push(@flags, "FD_ISCOMPOUND") if ($fkind{$fieldname} eq 'struct');
        push(@flags, "FD_ISPOINTER") if ($fispointer{$fieldname});
        push(@flags, "FD_ISCPOLYMORPHIC") if ($classtype{$ftype{$fieldname}} eq 'cpolymorphic');
        push(@flags, "FD_ISCPOLYMORPHIC | FD_ISCOBJECT") if ($classtype{$ftype{$fieldname}} eq 'cobject');
        $editableprop = $fprops{$fieldname}->{editable};
        push(@flags, "FD_ISEDITABLE") if (($editableprop eq 'true' || $editableprop eq '1') ||
                                          ($generate_setters_in_descr && $fkind{$fieldname} eq 'basic'));
        $flags = join(" | ", @flags);
        $flags = "0" if (@flags==());
        print CC "        case $i: return $flags;\n";
    }
    print CC "        default: return 0;\n";
    print CC "    }\n";
    print CC "}\n";
    print CC "\n";

    # getFieldName()
    print CC "const char *$msgdescclass\:\:getFieldName(void *object, int field)\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    if (basedesc) {\n";
    print CC "        if (field < basedesc->getFieldCount(object))\n";
    print CC "            return basedesc->getFieldName(object, field);\n";
    print CC "        field -= basedesc->getFieldCount(object);\n";
    print CC "    }\n";
    print CC "    switch (field) {\n";
    for ($i=0; $i<$fieldcount; $i++)
    {
        print CC "        case $i: return \"$fieldlist[$i]\";\n";
    }
    print CC "        default: return NULL;\n";
    print CC "    }\n";
    print CC "}\n";
    print CC "\n";

    # getFieldTypeString()
    print CC "const char *$msgdescclass\:\:getFieldTypeString(void *object, int field)\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    if (basedesc) {\n";
    print CC "        if (field < basedesc->getFieldCount(object))\n";
    print CC "            return basedesc->getFieldTypeString(object, field);\n";
    print CC "        field -= basedesc->getFieldCount(object);\n";
    print CC "    }\n";
    print CC "    switch (field) {\n";
    for ($i=0; $i<$fieldcount; $i++)
    {
        print CC "        case $i: return \"$ftype{$fieldlist[$i]}\";\n";
    }
    print CC "        default: return NULL;\n";
    print CC "    }\n";
    print CC "}\n";
    print CC "\n";

    # getFieldProperty()
    print CC "const char *$msgdescclass\:\:getFieldProperty(void *object, int field, const char *propertyname)\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    if (basedesc) {\n";
    print CC "        if (field < basedesc->getFieldCount(object))\n";
    print CC "            return basedesc->getFieldProperty(object, field, propertyname);\n";
    print CC "        field -= basedesc->getFieldCount(object);\n";
    print CC "    }\n";
    print CC "    switch (field) {\n";
    for ($i=0; $i<$fieldcount; $i++)
    {
        $fieldname = $fieldlist[$i];
        $ref = $fprops{$fieldname};
        if (keys(%$ref) != ()) {
            print CC "        case $i:\n";
            for $key (keys %$ref) {
                $prop = quote($fprops{$fieldname}->{$key});
                print CC "            if (!strcmp(propertyname,\"$key\")) return \"$prop\";\n";
            }
            print CC "            return NULL;\n";
        }
    }
    print CC "        default: return NULL;\n";
    print CC "    }\n";
    print CC "}\n";
    print CC "\n";

    # getArraySize()
    print CC "int $msgdescclass\:\:getArraySize(void *object, int field)\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    if (basedesc) {\n";
    print CC "        if (field < basedesc->getFieldCount(object))\n";
    print CC "            return basedesc->getArraySize(object, field);\n";
    print CC "        field -= basedesc->getFieldCount(object);\n";
    print CC "    }\n";
    print CC "    $msgclass *pp _MAYBEUNUSED = ($msgclass *)object;\n";
    print CC "    switch (field) {\n";
    for ($i=0; $i<$fieldcount; $i++) {
        if ($fisarray{$fieldlist[$i]}) {
            if ($farraysize{$fieldlist[$i]} ne '') {
                print CC "        case $i: return $farraysize{$fieldlist[$i]};\n";
            } elsif ($classtype eq 'struct') {
                print CC "        case $i: return pp->$varsize{$fieldlist[$i]};\n";
            } else {
                print CC "        case $i: return pp->$getsize{$fieldlist[$i]}();\n";
            }
        }
    }
    print CC "        default: return 0;\n";
    print CC "    }\n";
    print CC "}\n";
    print CC "\n";

    # getFieldAsString()
    print CC "bool $msgdescclass\:\:getFieldAsString(void *object, int field, int i, char *resultbuf, int bufsize)\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    if (basedesc) {\n";
    print CC "        if (field < basedesc->getFieldCount(object))\n";
    print CC "            return basedesc->getFieldAsString(object,field,i,resultbuf,bufsize);\n";
    print CC "        field -= basedesc->getFieldCount(object);\n";
    print CC "    }\n";
    print CC "    $msgclass *pp _MAYBEUNUSED = ($msgclass *)object;\n";
    print CC "    switch (field) {\n";
    for ($i=0; $i<$fieldcount; $i++)
    {
        if ($fkind{$fieldlist[$i]} eq 'basic') {
            if ($classtype eq 'struct') {
                if ($fisarray{$fieldlist[$i]}) {
                    if ($farraysize{$fieldlist[$i]} ne '') {
                        print CC "        case $i: if (i>=$farraysize{$fieldlist[$i]}) return false;\n";
                    } else {
                        print CC "        case $i: if (i>=pp->$varsize{$fieldlist[$i]}) return false;\n";
                    }
                    print CC "                $tostring{$fieldlist[$i]}(pp->$var{$fieldlist[$i]}\[i\],resultbuf,bufsize); return true;\n";
                } else {
                    print CC "        case $i: $tostring{$fieldlist[$i]}(pp->$var{$fieldlist[$i]},resultbuf,bufsize); return true;\n";
                }
            } else {
                if ($fisarray{$fieldlist[$i]}) {
                    print CC "        case $i: $tostring{$fieldlist[$i]}(pp->$getter{$fieldlist[$i]}(i),resultbuf,bufsize); return true;\n";
                } else {
                    print CC "        case $i: $tostring{$fieldlist[$i]}(pp->$getter{$fieldlist[$i]}(),resultbuf,bufsize); return true;\n";
                }
            }
        } elsif ($fkind{$fieldlist[$i]} eq 'struct') {
            if ($classtype eq 'struct') {
                if ($fisarray{$fieldlist[$i]}) {
                    print CC "        case $i: {std::stringstream out; out << pp->$var{$fieldlist[$i]}\[i\]; opp_strprettytrunc(resultbuf,out.str().c_str(),bufsize-1); return true;}\n";
                } else {
                    print CC "        case $i: {std::stringstream out; out << pp->$var{$fieldlist[$i]}; opp_strprettytrunc(resultbuf,out.str().c_str(),bufsize-1); return true;}\n";
                }
            } else {
                if ($fisarray{$fieldlist[$i]}) {
                    print CC "        case $i: {std::stringstream out; out << pp->$getter{$fieldlist[$i]}(i); opp_strprettytrunc(resultbuf,out.str().c_str(),bufsize-1); return true;}\n";
                } else {
                    print CC "        case $i: {std::stringstream out; out << pp->$getter{$fieldlist[$i]}(); opp_strprettytrunc(resultbuf,out.str().c_str(),bufsize-1); return true;}\n";
                }
            }
        } else {
            die 'internal error';
        }
    }
    print CC "        default: return false;\n";
    print CC "    }\n";
    print CC "}\n";
    print CC "\n";

    # setFieldAsString()
    print CC "bool $msgdescclass\:\:setFieldAsString(void *object, int field, int i, const char *value)\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    if (basedesc) {\n";
    print CC "        if (field < basedesc->getFieldCount(object))\n";
    print CC "            return basedesc->setFieldAsString(object,field,i,value);\n";
    print CC "        field -= basedesc->getFieldCount(object);\n";
    print CC "    }\n";
    print CC "    $msgclass *pp _MAYBEUNUSED = ($msgclass *)object;\n";
    print CC "    switch (field) {\n";
    for ($i=0; $i<$fieldcount; $i++)
    {
        $fieldname = $fieldlist[$i];
        $editableprop = $fprops{$fieldname}->{editable};
        if ($editableprop eq 'true' || $editableprop eq '1' || ($generate_setters_in_descr && $fkind{$fieldname} eq 'basic')) {
            if ($classtype eq 'struct') {
                if ($fisarray{$fieldname}) {
                    if ($farraysize{$fieldname} ne '') {
                        print CC "        case $i: if (i>=$farraysize{$fieldname}) return false;\n";
                    } else {
                        print CC "        case $i: if (i>=pp->$varsize{$fieldname}) return false;\n";
                    }
                    print CC "                pp->$var{$fieldname}\[i\] = $fromstring{$fieldname}(value); return true;\n";
                } else {
                    print CC "        case $i: pp->$var{$fieldname} = $fromstring{$fieldname}(value); return true;\n";
                }
            } else {
                if ($fisarray{$fieldname}) {
                    print CC "        case $i: pp->$setter{$fieldname}(i,$fromstring{$fieldname}(value)); return true;\n";
                } else {
                    print CC "        case $i: pp->$setter{$fieldname}($fromstring{$fieldname}(value)); return true;\n";
                }
            }
        }
    }
    print CC "        default: return false;\n";
    print CC "    }\n";
    print CC "}\n";
    print CC "\n";

    # getFieldStructName()
    print CC "const char *$msgdescclass\:\:getFieldStructName(void *object, int field)\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    if (basedesc) {\n";
    print CC "        if (field < basedesc->getFieldCount(object))\n";
    print CC "            return basedesc->getFieldStructName(object, field);\n";
    print CC "        field -= basedesc->getFieldCount(object);\n";
    print CC "    }\n";
    print CC "    switch (field) {\n";
    for ($i=0; $i<$fieldcount; $i++)
    {
        if ($fkind{$fieldlist[$i]} eq 'struct') {
            print CC "        case $i: return \"$ftype{$fieldlist[$i]}\"; break;\n";
        }
    }
    print CC "        default: return NULL;\n";
    print CC "    }\n";
    print CC "}\n";
    print CC "\n";

    # getFieldStructPointer()
    print CC "void *$msgdescclass\:\:getFieldStructPointer(void *object, int field, int i)\n";
    print CC "{\n";
    print CC "    cClassDescriptor *basedesc = getBaseClassDescriptor();\n";
    print CC "    if (basedesc) {\n";
    print CC "        if (field < basedesc->getFieldCount(object))\n";
    print CC "            return basedesc->getFieldStructPointer(object, field, i);\n";
    print CC "        field -= basedesc->getFieldCount(object);\n";
    print CC "    }\n";
    print CC "    $msgclass *pp _MAYBEUNUSED = ($msgclass *)object;\n";
    print CC "    switch (field) {\n";
    for ($i=0; $i<$fieldcount; $i++)
    {
        $fieldname = $fieldlist[$i];

        if ($fkind{$fieldname} eq 'struct') {
            if ($classtype eq 'struct') {
                if ($fisarray{$fieldname}) {
                    $value = "pp->$var{$fieldname}\[i\]";
                } else {
                    $value = "pp->$var{$fieldname}";
                }
            } else {
                if ($fisarray{$fieldname}) {
                    $value = "pp->$getter{$fieldname}(i)";
                } else {
                    $value = "pp->$getter{$fieldname}()";
                }
            }
            $fieldclasstype = $classtype{$ftype{$fieldname}};
            $cast = "(void *)";
            $cast .= "static_cast<cPolymorphic *>" if ($fieldclasstype eq 'cpolymorphic' || $fieldclasstype eq 'cobject');
            if ($fispointer{$fieldname}) {
                print CC "        case $i: return $cast($value); break;\n";
            } else {
                print CC "        case $i: return $cast(\&$value); break;\n";
            }
        }
    }
    print CC "        default: return NULL;\n";
    print CC "    }\n";
    print CC "}\n";
    print CC "\n";
}

#
# replace newlines with \n, and prefix quotes with backslash
#
sub quote($)
{
    my($text) = @_;
    $text =~ s/\n/\\n/gs;
    $text =~ s/"/\\"/g;
    return $text;
}

